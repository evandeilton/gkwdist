[{"path":"https://evandeilton.github.io/gkwdist/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 gkwdist authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"gkwdist package provides comprehensive implementation Generalized Kumaraswamy (GKw) distribution family modeling bounded continuous data unit interval (0,1)(0,1). functions implemented C++ via RcppArmadillo, providing substantial performance improvements pure R implementations.","code":""},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"key-features","dir":"Articles","previous_headings":"Introduction","what":"Key Features","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"Seven nested distributions: GKw, BKw, KKw, EKw, Mc, Kw, Beta Standard distribution functions: density, CDF, quantile, random generation Analytical derivatives: log-likelihood, gradient, Hessian efficient inference High performance: C++ implementation 10-100√ó speedup external dependencies: Uses base R functions examples","code":"library(gkwdist)"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"mathematical-foundation","dir":"Articles","previous_headings":"The Distribution Family","what":"Mathematical Foundation","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"five-parameter Generalized Kumaraswamy distribution probability density function: f(x;Œ±,Œ≤,Œ≥,Œ¥,Œª)=ŒªŒ±Œ≤xŒ±‚àí1B(Œ≥,Œ¥+1)(1‚àíxŒ±)Œ≤‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œ≥Œª‚àí1{1‚àí[1‚àí(1‚àíxŒ±)Œ≤]Œª}Œ¥f(x; \\alpha, \\beta, \\gamma, \\delta, \\lambda) = \\frac{\\lambda\\alpha\\beta x^{\\alpha-1}}{B(\\gamma, \\delta+1)} (1-x^\\alpha)^{\\beta-1} [1-(1-x^\\alpha)^\\beta]^{\\gamma\\lambda-1} \\{1-[1-(1-x^\\alpha)^\\beta]^\\lambda\\}^\\delta x‚àà(0,1)x \\(0,1) parameters positive, B(‚ãÖ,‚ãÖ)B(\\cdot, \\cdot) denotes beta function.","code":""},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"nested-sub-families","dir":"Articles","previous_headings":"The Distribution Family","what":"Nested Sub-families","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"GKw distribution generalizes several important distributions: Nested Structure GKw Family","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"density-cdf-quantile-and-random-generation","dir":"Articles","previous_headings":"Basic Distribution Functions","what":"Density, CDF, Quantile, and Random Generation","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"distributions follow standard R naming convention:","code":"# Set parameters for Kumaraswamy distribution alpha <- 2.5 beta <- 3.5  # Density x <- seq(0.01, 0.99, length.out = 100) density <- dkw(x, alpha, beta)  # CDF cdf_values <- pkw(x, alpha, beta)  # Quantile function probabilities <- c(0.25, 0.5, 0.75) quantiles <- qkw(probabilities, alpha, beta)  # Random generation set.seed(123) random_sample <- rkw(1000, alpha, beta)"},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"visualization","dir":"Articles","previous_headings":"Basic Distribution Functions","what":"Visualization","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"# PDF plot(x, density,   type = \"l\", lwd = 2, col = \"#2E4057\",   main = \"Probability Density Function\",   xlab = \"x\", ylab = \"f(x)\", las = 1 ) grid(col = \"gray90\") # CDF plot(x, cdf_values,   type = \"l\", lwd = 2, col = \"#8B0000\",   main = \"Cumulative Distribution Function\",   xlab = \"x\", ylab = \"F(x)\", las = 1 ) grid(col = \"gray90\") # Histogram with theoretical density hist(random_sample,   breaks = 30, probability = TRUE,   col = \"lightblue\", border = \"white\",   main = \"Random Sample\", xlab = \"x\", ylab = \"Density\", las = 1 ) lines(x, density, col = \"#8B0000\", lwd = 2) grid(col = \"gray90\") # Q-Q plot theoretical_q <- qkw(ppoints(length(random_sample)), alpha, beta) empirical_q <- sort(random_sample) plot(theoretical_q, empirical_q,   pch = 19, col = rgb(0, 0, 1, 0.3),   main = \"Q-Q Plot\", xlab = \"Theoretical Quantiles\",   ylab = \"Sample Quantiles\", las = 1 ) abline(0, 1, col = \"#8B0000\", lwd = 2, lty = 2) grid(col = \"gray90\")"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"flexibility-across-families","dir":"Articles","previous_headings":"Comparing Distribution Shapes","what":"Flexibility Across Families","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"x_grid <- seq(0.001, 0.999, length.out = 500)  # Compute densities d_gkw <- dgkw(x_grid, 2, 3, 1.5, 2, 1.2) d_bkw <- dbkw(x_grid, 2, 3, 1.5, 2) d_ekw <- dekw(x_grid, 2, 3, 1.5) d_kw <- dkw(x_grid, 2, 3) d_beta <- dbeta_(x_grid, 2, 3)  # Plot comparison plot(x_grid, d_gkw,   type = \"l\", lwd = 2, col = \"#2E4057\",   ylim = c(0, max(d_gkw, d_bkw, d_ekw, d_kw, d_beta)),   main = \"Density Comparison Across Families\",   xlab = \"x\", ylab = \"Density\", las = 1 ) lines(x_grid, d_bkw, lwd = 2, col = \"#8B0000\") lines(x_grid, d_ekw, lwd = 2, col = \"#006400\") lines(x_grid, d_kw, lwd = 2, col = \"#FFA07A\") lines(x_grid, d_beta, lwd = 2, col = \"#808080\")  legend(\"topright\",   legend = c(     \"GKw (5 par)\", \"BKw (4 par)\", \"EKw (3 par)\",     \"Kw (2 par)\", \"Beta (2 par)\"   ),   col = c(\"#2E4057\", \"#8B0000\", \"#006400\", \"#FFA07A\", \"#808080\"),   lwd = 2, bty = \"n\", cex = 0.9 ) grid(col = \"gray90\")"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"basic-mle-workflow","dir":"Articles","previous_headings":"Maximum Likelihood Estimation","what":"Basic MLE Workflow","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"# Generate synthetic data set.seed(2024) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5) data <- rkw(n, true_params[1], true_params[2])  # Maximum likelihood estimation fit <- optim(   par = c(2, 3), # Starting values   fn = llkw, # Negative log-likelihood   gr = grkw, # Analytical gradient   data = data,   method = \"BFGS\",   hessian = TRUE )  # Extract results mle <- fit$par names(mle) <- c(\"alpha\", \"beta\") se <- sqrt(diag(solve(fit$hessian)))"},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"inference-results","dir":"Articles","previous_headings":"Maximum Likelihood Estimation","what":"Inference Results","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"Maximum Likelihood Estimates 95% Confidence Intervals","code":"# Construct summary table results <- data.frame(   Parameter = c(\"alpha\", \"beta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se,   Coverage = (mle - 1.96 * se <= true_params) &     (true_params <= mle + 1.96 * se) )  knitr::kable(results,   digits = 4,   caption = \"Maximum Likelihood Estimates with 95% Confidence Intervals\" ) # Information criteria cat(\"\\nModel Fit Statistics:\\n\") #>  #> Model Fit Statistics: cat(\"Log-likelihood:\", -fit$value, \"\\n\") #> Log-likelihood: 281.6324 cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> AIC: -559.2649 cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> BIC: -549.4494"},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"goodness-of-fit-assessment","dir":"Articles","previous_headings":"Maximum Likelihood Estimation","what":"Goodness-of-Fit Assessment","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"# Fitted vs true density x_grid <- seq(0.001, 0.999, length.out = 200) fitted_dens <- dkw(x_grid, mle[1], mle[2]) true_dens <- dkw(x_grid, true_params[1], true_params[2])  hist(data,   breaks = 40, probability = TRUE,   col = \"lightgray\", border = \"white\",   main = \"Goodness-of-Fit: Kumaraswamy Distribution\",   xlab = \"Data\", ylab = \"Density\", las = 1 ) lines(x_grid, fitted_dens, col = \"#8B0000\", lwd = 2) lines(x_grid, true_dens, col = \"#006400\", lwd = 2, lty = 2) legend(\"topright\",   legend = c(\"Observed Data\", \"Fitted Model\", \"True Model\"),   col = c(\"gray\", \"#8B0000\", \"#006400\"),   lwd = c(8, 2, 2), lty = c(1, 1, 2), bty = \"n\" ) grid(col = \"gray90\")"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"comparing-nested-models","dir":"Articles","previous_headings":"Model Selection","what":"Comparing Nested Models","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"Model Selection via Information Criteria","code":"# Generate data from EKw distribution set.seed(456) n <- 1500 data_ekw <- rekw(n, alpha = 2, beta = 3, lambda = 1.5)  # Define candidate models models <- list(   Beta = list(     fn = llbeta,     gr = grbeta,     start = c(2, 2),     npar = 2   ),   Kw = list(     fn = llkw,     gr = grkw,     start = c(2, 3),     npar = 2   ),   EKw = list(     fn = llekw,     gr = grekw,     start = c(2, 3, 1.5),     npar = 3   ),   Mc = list(     fn = llmc,     gr = grmc,     start = c(2, 2, 1.5),     npar = 3   ) )  # Fit all models results_list <- lapply(names(models), function(name) {   m <- models[[name]]   fit <- optim(     par = m$start,     fn = m$fn,     gr = m$gr,     data = data_ekw,     method = \"BFGS\"   )    loglik <- -fit$value   data.frame(     Model = name,     nPar = m$npar,     LogLik = loglik,     AIC = -2 * loglik + 2 * m$npar,     BIC = -2 * loglik + m$npar * log(n),     Converged = fit$convergence == 0   ) })  # Combine results comparison <- do.call(rbind, results_list) comparison <- comparison[order(comparison$AIC), ] rownames(comparison) <- NULL  knitr::kable(comparison,   digits = 2,   caption = \"Model Selection via Information Criteria\" )"},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"interpretation","dir":"Articles","previous_headings":"Model Selection","what":"Interpretation","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"best_model <- comparison$Model[1] cat(\"\\nBest model by AIC:\", best_model, \"\\n\") #>  #> Best model by AIC: Kw cat(\"Best model by BIC:\", comparison$Model[which.min(comparison$BIC)], \"\\n\") #> Best model by BIC: Kw  # Delta AIC comparison$Delta_AIC <- comparison$AIC - min(comparison$AIC) cat(\"\\nŒîAIC relative to best model:\\n\") #>  #> ŒîAIC relative to best model: print(comparison[, c(\"Model\", \"Delta_AIC\")]) #>   Model Delta_AIC #> 1    Kw 0.0000000 #> 2  Beta 0.7129854 #> 3    Mc 1.1677176 #> 4   EKw 1.4528716"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"profile-likelihood","dir":"Articles","previous_headings":"Advanced Topics","what":"Profile Likelihood","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"Profile likelihood provides accurate confidence intervals Wald intervals, especially small samples near parameter boundaries.","code":"# Generate data set.seed(789) data_profile <- rkw(500, alpha = 2.5, beta = 3.5)  # Fit model fit_profile <- optim(   par = c(2, 3),   fn = llkw,   gr = grkw,   data = data_profile,   method = \"BFGS\",   hessian = TRUE )  mle_profile <- fit_profile$par  # Compute profile likelihood for alpha alpha_grid <- seq(mle_profile[1] - 1, mle_profile[1] + 1, length.out = 50) alpha_grid <- alpha_grid[alpha_grid > 0] profile_ll <- numeric(length(alpha_grid))  for (i in seq_along(alpha_grid)) {   profile_fit <- optimize(     f = function(beta) llkw(c(alpha_grid[i], beta), data_profile),     interval = c(0.1, 10),     maximum = FALSE   )   profile_ll[i] <- -profile_fit$objective }  # Plot  # Profile likelihood chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll) - chi_crit / 2  plot(alpha_grid, profile_ll,   type = \"l\", lwd = 2, col = \"#2E4057\",   main = \"Profile Log-Likelihood\",   xlab = expression(alpha), ylab = \"Profile Log-Likelihood\", las = 1 ) abline(v = mle_profile[1], col = \"#8B0000\", lty = 2, lwd = 2) abline(v = 2.5, col = \"#006400\", lty = 2, lwd = 2) abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) legend(\"topright\",   legend = c(\"MLE\", \"True\", \"95% CI\"),   col = c(\"#8B0000\", \"#006400\", \"#808080\"),   lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8 ) grid(col = \"gray90\") # Wald vs Profile CI comparison se_profile <- sqrt(diag(solve(fit_profile$hessian))) wald_ci <- mle_profile[1] + c(-1.96, 1.96) * se_profile[1] profile_ci <- range(alpha_grid[profile_ll >= threshold])  plot(1:2, c(mle_profile[1], mle_profile[1]),   xlim = c(0.5, 2.5),   ylim = range(c(wald_ci, profile_ci)),   pch = 19, col = \"#8B0000\", cex = 1.5,   main = \"Confidence Interval Comparison\",   xlab = \"\", ylab = expression(alpha), xaxt = \"n\", las = 1 ) axis(1, at = 1:2, labels = c(\"Wald\", \"Profile\"))  # Add CIs segments(1, wald_ci[1], 1, wald_ci[2], lwd = 3, col = \"#2E4057\") segments(2, profile_ci[1], 2, profile_ci[2], lwd = 3, col = \"#8B0000\") abline(h = 2.5, col = \"#006400\", lty = 2, lwd = 2)  legend(\"topright\",   legend = c(\"MLE\", \"True\", \"Wald 95% CI\", \"Profile 95% CI\"),   col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#8B0000\"),   pch = c(19, NA, NA, NA), lty = c(NA, 2, 1, 1),   lwd = c(NA, 2, 3, 3), bty = \"n\", cex = 0.8 ) grid(col = \"gray90\")"},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"confidence-regions","dir":"Articles","previous_headings":"Advanced Topics","what":"Confidence Regions","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"multivariate inference, confidence ellipses show joint uncertainty parameter estimates.","code":"# Compute variance-covariance matrix vcov_matrix <- solve(fit_profile$hessian)  # Create confidence ellipse (95%) theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_matrix) ellipse <- matrix(NA, nrow = 100, ncol = 2)  for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle_profile + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) }  # Marginal CIs se_marg <- sqrt(diag(vcov_matrix)) ci_alpha_marg <- mle_profile[1] + c(-1.96, 1.96) * se_marg[1] ci_beta_marg <- mle_profile[2] + c(-1.96, 1.96) * se_marg[2]  # Plot plot(ellipse[, 1], ellipse[, 2],   type = \"l\", lwd = 2, col = \"#2E4057\",   main = \"95% Joint Confidence Region\",   xlab = expression(alpha), ylab = expression(beta), las = 1 )  # Add marginal CIs abline(v = ci_alpha_marg, col = \"#808080\", lty = 3, lwd = 1.5) abline(h = ci_beta_marg, col = \"#808080\", lty = 3, lwd = 1.5)  # Add points points(mle_profile[1], mle_profile[2], pch = 19, col = \"#8B0000\", cex = 1.5) points(2.5, 3.5, pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",   legend = c(\"MLE\", \"True\", \"Joint 95% CR\", \"Marginal 95% CI\"),   col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),   pch = c(19, 17, NA, NA), lty = c(NA, NA, 1, 3),   lwd = c(NA, NA, 2, 1.5), bty = \"n\" ) grid(col = \"gray90\")"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"computational-efficiency","dir":"Articles","previous_headings":"Performance Benchmarking","what":"Computational Efficiency","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"C++ implementation provides substantial performance gains:","code":"# Generate large dataset n_large <- 10000 data_large <- rkw(n_large, 2, 3)  # Compare timings system.time({   manual_ll <- -sum(log(dkw(data_large, 2, 3))) })  system.time({   cpp_ll <- llkw(c(2, 3), data_large) })  # Typical results: C++ is 10-50√ó faster"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"example-modeling-proportions","dir":"Articles","previous_headings":"Practical Applications","what":"Example: Modeling Proportions","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"# Simulate customer conversion rates set.seed(999) n_customers <- 800  # Generate conversion rates from EKw distribution conversion_rates <- rekw(n_customers, alpha = 1.8, beta = 2.5, lambda = 1.3)  # Fit model fit_app <- optim(   par = c(1.5, 2, 1),   fn = llekw,   gr = grekw,   data = conversion_rates,   method = \"BFGS\",   hessian = TRUE )  mle_app <- fit_app$par names(mle_app) <- c(\"alpha\", \"beta\", \"lambda\")  # Summary statistics cat(\"Sample Summary:\\n\") #> Sample Summary: cat(\"Mean:\", mean(conversion_rates), \"\\n\") #> Mean: 0.5039841 cat(\"Median:\", median(conversion_rates), \"\\n\") #> Median: 0.5102676 cat(\"SD:\", sd(conversion_rates), \"\\n\\n\") #> SD: 0.2020025  cat(\"Model Estimates:\\n\") #> Model Estimates: print(round(mle_app, 3)) #>  alpha   beta lambda  #>  3.435  3.584  0.606 # Visualization x_app <- seq(0.001, 0.999, length.out = 200) fitted_app <- dekw(x_app, mle_app[1], mle_app[2], mle_app[3])  hist(conversion_rates,   breaks = 30, probability = TRUE,   col = \"lightblue\", border = \"white\",   main = \"Customer Conversion Rates\",   xlab = \"Conversion Rate\", ylab = \"Density\", las = 1 ) lines(x_app, fitted_app, col = \"#8B0000\", lwd = 2) legend(\"topright\",   legend = c(\"Observed\", \"EKw Fit\"),   col = c(\"lightblue\", \"#8B0000\"),   lwd = c(8, 2), bty = \"n\" ) grid(col = \"gray90\")"},{"path":[]},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"model-selection-workflow","dir":"Articles","previous_headings":"Recommendations","what":"Model Selection Workflow","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"Exploratory Analysis: Examine histograms summary statistics Start Simple: Fit Beta Kumaraswamy (2 parameters) Diagnostic Checking: Use Q-Q plots formal tests Progressive Complexity: Add parameters needed (EKw ‚Üí BKw ‚Üí GKw) Information Criteria: Balance fit quality parsimony using AIC/BIC Validation: Check residuals perform cross-validation","code":""},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"gkwdist package provides comprehensive toolkit modeling bounded continuous data. Key advantages include: Flexibility: Seven nested distributions accommodate diverse data shapes Efficiency: C++ implementation ensures fast computation Completeness: Full suite distribution inference functions Reliability: Analytical derivatives guarantee numerical accuracy","code":""},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"further-reading","dir":"Articles","previous_headings":"Conclusion","what":"Further Reading","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"theoretical details applications, see: Carrasco, J. M. F., Ferrari, S. L. P., Cordeiro, G. M. (2010). ‚Äúnew generalized Kumaraswamy distribution.‚Äù arXiv:1004.0911. Jones, M. C. (2009). ‚ÄúKumaraswamy‚Äôs distribution: beta-type distribution tractability advantages.‚Äù Statistical Methodology, 6(1), 70-81. Kumaraswamy, P. (1980). ‚Äúgeneralized probability density function double-bounded random processes.‚Äù Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":"https://evandeilton.github.io/gkwdist/articles/into-gkwdist.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Introduction to gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"sessionInfo() #> R version 4.5.1 (2025-06-13) #> Platform: x86_64-pc-linux-gnu #> Running under: Zorin OS 18 #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=pt_BR.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=pt_BR.UTF-8        LC_COLLATE=en_US.UTF-8     #>  [5] LC_MONETARY=pt_BR.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=pt_BR.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=pt_BR.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: America/Sao_Paulo #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] gkwdist_1.0.10 #>  #> loaded via a namespace (and not attached): #>  [1] cli_3.6.5              knitr_1.50             rlang_1.1.6            #>  [4] xfun_0.53              textshaping_1.0.4      jsonlite_2.0.0         #>  [7] htmltools_0.5.8.1      ragg_1.5.0             sass_0.4.10            #> [10] rmarkdown_2.30         evaluate_1.0.5         jquerylib_0.1.4        #> [13] fastmap_1.2.0          numDeriv_2016.8-1.1    yaml_2.3.10            #> [16] lifecycle_1.0.4        compiler_4.5.1         fs_1.6.6               #> [19] htmlwidgets_1.6.4      Rcpp_1.1.0             rstudioapi_0.17.1      #> [22] systemfonts_1.3.1      digest_0.6.37          R6_2.6.1               #> [25] magrittr_2.0.4         bslib_0.9.0            tools_4.5.1            #> [28] RcppArmadillo_15.0.2-2 pkgdown_2.1.3          cachem_1.1.0           #> [31] desc_1.4.3"},{"path":"https://evandeilton.github.io/gkwdist/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jos√© Evandeilton Lopes. Author, maintainer.","code":""},{"path":"https://evandeilton.github.io/gkwdist/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lopes, J.E. (2025). gkwdist: Generalized Kumaraswamy Distribution Family. R package version 1.0.8. https://github.com/evandeilton/gkwdist","code":"@Manual{,   title = {{gkwdist}: Generalized Kumaraswamy Distribution Family},   author = {Jos√© Evandeilton Lopes},   year = {2025},   note = {R package version 1.0.8},   url = {https://github.com/evandeilton/gkwdist}, }"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"gkwdist implements Generalized Kumaraswamy (GKw) distribution family seven nested sub-models bounded continuous data (0,1)(0,1). functions implemented C++ via RcppArmadillo maximum computational efficiency. Key Features: - Seven flexible distributions proportions, rates, bounded data - Standard R distribution API: d*, p*, q*, r* - Analytical log-likelihood, gradient, Hessian functions - functions implemented C++ optimal performance - 10-50√ó faster equivalent R implementations - Numerically stable extreme parameter values","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"# Install from GitHub # install.packages(\"devtools\") devtools::install_github(\"evandeilton/gkwdist\")"},{"path":[]},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"function-types","dir":"","previous_headings":"The Distribution Family","what":"Function Types","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Distribution Functions (C++ implementation R interface): d*() ‚Äî Probability density function (PDF) p*() ‚Äî Cumulative distribution function (CDF) q*() ‚Äî Quantile function (inverse CDF) r*() ‚Äî Random number generation Analytical Functions Maximum Likelihood (C++ implementation): analytical functions use signature: function(par, data) par numeric vector parameters. ll*(par, data) ‚Äî Negative log-likelihood: ‚àí‚Ñì(ùõâ;ùê±)=‚àí‚àë=1nlogf(xi;ùõâ)-\\ell(\\boldsymbol{\\theta}; \\mathbf{x}) = -\\sum_{=1}^n \\log f(x_i; \\boldsymbol{\\theta}) gr*(par, data) ‚Äî Negative gradient (negative score vector): ‚àí‚àáùõâ‚Ñì(ùõâ;ùê±)-\\nabla_{\\boldsymbol{\\theta}} \\ell(\\boldsymbol{\\theta}; \\mathbf{x}) hs*(par, data) ‚Äî Negative Hessian matrix: ‚àí‚àáùõâ2‚Ñì(ùõâ;ùê±)-\\nabla^2_{\\boldsymbol{\\theta}} \\ell(\\boldsymbol{\\theta}; \\mathbf{x}) Note: functions return negative values facilitate direct use optimization routines like optim(), perform minimization default.","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"mathematical-specification","dir":"","previous_headings":"","what":"Mathematical Specification","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Notation: parameters strictly positive (Œ±,Œ≤,Œ≥,Œ¥,Œª>0\\alpha, \\beta, \\gamma, \\delta, \\lambda > 0); support x‚àà(0,1)x \\(0, 1). beta function B(,b)=Œì()Œì(b)/Œì(+b)B(,b) = \\Gamma()\\Gamma(b)/\\Gamma(+b), regularized incomplete beta function Iz(,b)=Bz(,b)/B(,b)I_z(,b) = B_z(,b)/B(,b) Bz(,b)=‚à´0zta‚àí1(1‚àít)b‚àí1dtB_z(,b) = \\int_0^z t^{-1}(1-t)^{b-1}dt.","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_1-generalized-kumaraswamy-gkw","dir":"","previous_headings":"Mathematical Specification","what":"1. Generalized Kumaraswamy (GKw)","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Parameters: Œ±,Œ≤,Œ≥,Œ¥,Œª>0\\alpha, \\beta, \\gamma, \\delta, \\lambda > 0 PDF: fGKw(x;Œ±,Œ≤,Œ≥,Œ¥,Œª)=ŒªŒ±Œ≤B(Œ≥,Œ¥)xŒ±‚àí1(1‚àíxŒ±)Œ≤‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œ≥Œª‚àí1{1‚àí[1‚àí(1‚àíxŒ±)Œ≤]Œª}Œ¥‚àí1f_{\\text{GKw}}(x; \\alpha, \\beta, \\gamma, \\delta, \\lambda) = \\frac{\\lambda \\alpha \\beta}{B(\\gamma, \\delta)} x^{\\alpha-1} (1-x^\\alpha)^{\\beta-1} \\left[1-(1-x^\\alpha)^\\beta\\right]^{\\gamma\\lambda-1} \\left\\{1-\\left[1-(1-x^\\alpha)^\\beta\\right]^\\lambda\\right\\}^{\\delta-1} CDF: FGKw(x;Œ±,Œ≤,Œ≥,Œ¥,Œª)=[1‚àí(1‚àíxŒ±)Œ≤]Œª(Œ≥,Œ¥)F_{\\text{GKw}}(x; \\alpha, \\beta, \\gamma, \\delta, \\lambda) = I_{[1-(1-x^\\alpha)^\\beta]^\\lambda}(\\gamma, \\delta) Quantile: Numerical inversion CDF via root-finding algorithms. Moments: Analytical expressions available closed form. Numerical integration simulation methods required.","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_2-beta-kumaraswamy-bkw","dir":"","previous_headings":"Mathematical Specification","what":"2. Beta-Kumaraswamy (BKw)","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Relationship: Special case GKw Œª=1\\lambda = 1 PDF: fBKw(x;Œ±,Œ≤,Œ≥,Œ¥)=Œ±Œ≤B(Œ≥,Œ¥)xŒ±‚àí1(1‚àíxŒ±)Œ≤‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œ≥‚àí1{1‚àí[1‚àí(1‚àíxŒ±)Œ≤]}Œ¥‚àí1f_{\\text{BKw}}(x; \\alpha, \\beta, \\gamma, \\delta) = \\frac{\\alpha \\beta}{B(\\gamma, \\delta)} x^{\\alpha-1} (1-x^\\alpha)^{\\beta-1} \\left[1-(1-x^\\alpha)^\\beta\\right]^{\\gamma-1} \\left\\{1-\\left[1-(1-x^\\alpha)^\\beta\\right]\\right\\}^{\\delta-1} Simplifying: fBKw(x;Œ±,Œ≤,Œ≥,Œ¥)=Œ±Œ≤B(Œ≥,Œ¥)xŒ±‚àí1(1‚àíxŒ±)Œ≤‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œ≥‚àí1(1‚àíxŒ±)Œ≤(Œ¥‚àí1)f_{\\text{BKw}}(x; \\alpha, \\beta, \\gamma, \\delta) = \\frac{\\alpha \\beta}{B(\\gamma, \\delta)} x^{\\alpha-1} (1-x^\\alpha)^{\\beta-1} \\left[1-(1-x^\\alpha)^\\beta\\right]^{\\gamma-1} (1-x^\\alpha)^{\\beta(\\delta-1)} =Œ±Œ≤B(Œ≥,Œ¥)xŒ±‚àí1(1‚àíxŒ±)Œ≤Œ¥‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œ≥‚àí1= \\frac{\\alpha \\beta}{B(\\gamma, \\delta)} x^{\\alpha-1} (1-x^\\alpha)^{\\beta\\delta-1} \\left[1-(1-x^\\alpha)^\\beta\\right]^{\\gamma-1} CDF: FBKw(x;Œ±,Œ≤,Œ≥,Œ¥)=I1‚àí(1‚àíxŒ±)Œ≤(Œ≥,Œ¥)F_{\\text{BKw}}(x; \\alpha, \\beta, \\gamma, \\delta) = I_{1-(1-x^\\alpha)^\\beta}(\\gamma, \\delta) Quantile: Numerical inversion via root-finding. inverse: u=Iy(Œ≥,Œ¥)wherey=1‚àí(1‚àíxŒ±)Œ≤u = I_y(\\gamma, \\delta) \\quad \\text{} \\quad y = 1-(1-x^\\alpha)^\\beta Solving xx: x=[1‚àí(1‚àíIu‚àí1(Œ≥,Œ¥))1/Œ≤]1/Œ±x = \\left[1-\\left(1-I_u^{-1}(\\gamma, \\delta)\\right)^{1/\\beta}\\right]^{1/\\alpha}","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_3-kumaraswamy-kumaraswamy-kkw","dir":"","previous_headings":"Mathematical Specification","what":"3. Kumaraswamy-Kumaraswamy (KKw)","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Relationship: Special case GKw Œ≥=1\\gamma = 1 PDF: fKKw(x;Œ±,Œ≤,Œ¥,Œª)=Œ±Œ≤Œ¥ŒªxŒ±‚àí1(1‚àíxŒ±)Œ≤‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œª‚àí1{1‚àí[1‚àí(1‚àíxŒ±)Œ≤]Œª}Œ¥‚àí1f_{\\text{KKw}}(x; \\alpha, \\beta, \\delta, \\lambda) = \\alpha \\beta \\delta \\lambda \\, x^{\\alpha-1} (1-x^\\alpha)^{\\beta-1} \\left[1-(1-x^\\alpha)^\\beta \\right]^{\\lambda-1} \\left\\{1-\\left[1-(1-x^\\alpha)^\\beta \\right]^\\lambda\\right\\}^{\\delta-1} CDF: FKKw(x;Œ±,Œ≤,Œ¥,Œª)=1‚àí{1‚àí[1‚àí(1‚àíxŒ±)Œ≤]Œª}Œ¥F_{\\text{KKw}}(x; \\alpha, \\beta, \\delta, \\lambda) = 1 - \\left\\{1-\\left[1-(1-x^\\alpha)^\\beta\\right]^\\lambda\\right\\}^\\delta Quantile (closed-form): QKKw(p;Œ±,Œ≤,Œ¥,Œª)=[1‚àí(1‚àí[1‚àí(1‚àíp)1/Œ¥]1/Œª)1/Œ≤]1/Œ±Q_{\\text{KKw}}(p; \\alpha, \\beta, \\delta, \\lambda) = \\left[1 - \\left(1 - \\left[1-(1-p)^{1/\\delta}\\right]^{1/\\lambda}\\right)^{1/\\beta}\\right]^{1/\\alpha} Moments: Analytical expressions available closed form.","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_4-exponentiated-kumaraswamy-ekw","dir":"","previous_headings":"Mathematical Specification","what":"4. Exponentiated Kumaraswamy (EKw)","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Relationship: Special case GKw Œ≥=Œ¥=1\\gamma = \\delta = 1 PDF: fEKw(x;Œ±,Œ≤,Œª)=ŒªŒ±Œ≤xŒ±‚àí1(1‚àíxŒ±)Œ≤‚àí1[1‚àí(1‚àíxŒ±)Œ≤]Œª‚àí1f_{\\text{EKw}}(x; \\alpha, \\beta, \\lambda) = \\lambda \\alpha \\beta \\, x^{\\alpha-1} (1-x^\\alpha)^{\\beta-1} \\left[1-(1-x^\\alpha)^\\beta \\right]^{\\lambda-1} CDF: FEKw(x;Œ±,Œ≤,Œª)=[1‚àí(1‚àíxŒ±)Œ≤]ŒªF_{\\text{EKw}}(x; \\alpha, \\beta, \\lambda) = \\left[1-(1-x^\\alpha)^\\beta \\right]^\\lambda Quantile (closed-form): QEKw(p;Œ±,Œ≤,Œª)=[1‚àí(1‚àíp1/Œª)1/Œ≤]1/Œ±Q_{\\text{EKw}}(p; \\alpha, \\beta, \\lambda) = \\left[1-\\left(1-p^{1/\\lambda}\\right)^{1/\\beta}\\right]^{1/\\alpha} Moments: ùîº(Xr)=Œª‚àëk=0‚àû(‚àí1)k(Œªk+1)k+1‚ãÖŒ≤B(1+rŒ±,(k+1)Œ≤)\\mathbb{E}(X^r) = \\lambda \\sum_{k=0}^{\\infty} \\frac{(-1)^k \\binom{\\lambda}{k+1}}{k+1} \\cdot \\beta B\\left(1 + \\frac{r}{\\alpha}, (k+1)\\beta\\right) binomial coefficient generalized: (Œªk+1)=Œª(Œª‚àí1)‚ãØ(Œª‚àík)(k+1)!\\binom{\\lambda}{k+1} = \\frac{\\lambda(\\lambda-1)\\cdots(\\lambda-k)}{(k+1)!}.","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_5-mcdonald-beta-power","dir":"","previous_headings":"Mathematical Specification","what":"5. McDonald (Beta Power)","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Relationship: Special case GKw Œ±=Œ≤=1\\alpha = \\beta = 1 PDF: fMC(x;Œ≥,Œ¥,Œª)=ŒªB(Œ≥,Œ¥)xŒ≥Œª‚àí1(1‚àíxŒª)Œ¥‚àí1f_{\\text{MC}}(x; \\gamma, \\delta, \\lambda) = \\frac{\\lambda}{B(\\gamma, \\delta)} x^{\\gamma\\lambda-1} (1-x^\\lambda)^{\\delta-1} CDF: FMC(x;Œ≥,Œ¥,Œª)=IxŒª(Œ≥,Œ¥)F_{\\text{MC}}(x; \\gamma, \\delta, \\lambda) = I_{x^\\lambda}(\\gamma, \\delta) Quantile: QMC(p;Œ≥,Œ¥,Œª)=[Ip‚àí1(Œ≥,Œ¥)]1/ŒªQ_{\\text{MC}}(p; \\gamma, \\delta, \\lambda) = \\left[I_p^{-1}(\\gamma, \\delta)\\right]^{1/\\lambda} Ip‚àí1(Œ≥,Œ¥)I_p^{-1}(\\gamma, \\delta) inverse regularized incomplete beta function (quantile function Beta distribution). Moments: ùîº(Xr)=B(Œ≥+r/Œª,Œ¥)B(Œ≥,Œ¥)\\mathbb{E}(X^r) = \\frac{B(\\gamma + r/\\lambda, \\delta)}{B(\\gamma, \\delta)} valid r/Œª>‚àíŒ≥r/\\lambda > -\\gamma.","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_6-kumaraswamy-kw","dir":"","previous_headings":"Mathematical Specification","what":"6. Kumaraswamy (Kw)","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Relationship: Special case GKw Œ≥=Œ¥=Œª=1\\gamma = \\delta = \\lambda = 1 PDF: fKw(x;Œ±,Œ≤)=Œ±Œ≤xŒ±‚àí1(1‚àíxŒ±)Œ≤‚àí1f_{\\text{Kw}}(x; \\alpha, \\beta) = \\alpha \\beta \\, x^{\\alpha-1} (1-x^\\alpha)^{\\beta-1} CDF: FKw(x;Œ±,Œ≤)=1‚àí(1‚àíxŒ±)Œ≤F_{\\text{Kw}}(x; \\alpha, \\beta) = 1 - (1-x^\\alpha)^\\beta Quantile (closed-form): QKw(p;Œ±,Œ≤)=[1‚àí(1‚àíp)1/Œ≤]1/Œ±Q_{\\text{Kw}}(p; \\alpha, \\beta) = \\left[1-(1-p)^{1/\\beta} \\right]^{1/\\alpha} Moments: ùîº(Xr)=Œ≤B(1+rŒ±,Œ≤)=Œ≤Œì(1+r/Œ±)Œì(Œ≤)Œì(1+r/Œ±+Œ≤)\\mathbb{E}(X^r) = \\beta B\\left(1 + \\frac{r}{\\alpha}, \\beta\\right) = \\frac{\\beta \\, \\Gamma(1+r/\\alpha) \\, \\Gamma(\\beta)}{\\Gamma(1+r/\\alpha+\\beta)} valid r/Œ±>‚àí1r/\\alpha > -1. Special Cases: ùîº(X)=Œ≤Œì(1+1/Œ±)Œì(Œ≤)Œì(1+1/Œ±+Œ≤)\\mathbb{E}(X) = \\frac{\\beta \\, \\Gamma(1+1/\\alpha) \\, \\Gamma(\\beta)}{\\Gamma(1+1/\\alpha+\\beta)} ùîº(X2)=Œ≤Œì(1+2/Œ±)Œì(Œ≤)Œì(1+2/Œ±+Œ≤)\\mathbb{E}(X^2) = \\frac{\\beta \\, \\Gamma(1+2/\\alpha) \\, \\Gamma(\\beta)}{\\Gamma(1+2/\\alpha+\\beta)} Var(X)=ùîº(X2)‚àí[ùîº(X)]2\\text{Var}(X) = \\mathbb{E}(X^2) - [\\mathbb{E}(X)]^2","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"id_7-beta","dir":"","previous_headings":"Mathematical Specification","what":"7. Beta","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Relationship: Special case GKw Œ±=Œ≤=Œª=1\\alpha = \\beta = \\lambda = 1 PDF: fBeta(x;Œ≥,Œ¥)=1B(Œ≥,Œ¥)xŒ≥‚àí1(1‚àíx)Œ¥‚àí1f_{\\text{Beta}}(x; \\gamma, \\delta) = \\frac{1}{B(\\gamma, \\delta)} x^{\\gamma-1} (1-x)^{\\delta-1} CDF: FBeta(x;Œ≥,Œ¥)=Ix(Œ≥,Œ¥)F_{\\text{Beta}}(x; \\gamma, \\delta) = I_x(\\gamma, \\delta) Quantile: QBeta(p;Œ≥,Œ¥)=Ip‚àí1(Œ≥,Œ¥)Q_{\\text{Beta}}(p; \\gamma, \\delta) = I_p^{-1}(\\gamma, \\delta) Moments: ùîº(Xr)=B(Œ≥+r,Œ¥)B(Œ≥,Œ¥)=Œì(Œ≥+r)Œì(Œ¥)Œì(Œ≥+Œ¥)Œì(Œ≥)Œì(Œ≥+Œ¥+r)Œì(Œ¥)\\mathbb{E}(X^r) = \\frac{B(\\gamma+r, \\delta)}{B(\\gamma, \\delta)} = \\frac{\\Gamma(\\gamma+r) \\, \\Gamma(\\delta) \\, \\Gamma(\\gamma+\\delta)}{\\Gamma(\\gamma) \\, \\Gamma(\\gamma+\\delta+r) \\, \\Gamma(\\delta)} ùîº(X)=Œ≥Œ≥+Œ¥\\mathbb{E}(X) = \\frac{\\gamma}{\\gamma+\\delta} Var(X)=Œ≥Œ¥(Œ≥+Œ¥)2(Œ≥+Œ¥+1)\\text{Var}(X) = \\frac{\\gamma\\delta}{(\\gamma+\\delta)^2(\\gamma+\\delta+1)}","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"hierarchical-structure","dir":"","previous_headings":"","what":"Hierarchical Structure","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Note: Beta distribution obtained MC setting Œª=1\\lambda = 1, GKw setting Œ±=Œ≤=Œª=1\\alpha = \\beta = \\lambda = 1. Kumaraswamy distribution obtained EKw setting Œª=1\\lambda = 1, GKw setting Œ≥=Œ¥=Œª=1\\gamma = \\delta = \\lambda = 1.","code":"GKw(Œ±, Œ≤, Œ≥, Œ¥, Œª)                               /               \\                            Œª = 1             Œ≥ = 1                             /                    \\                    BKw(Œ±, Œ≤, Œ≥, Œ¥)         KKw(Œ±, Œ≤, Œ¥, Œª)                          |                          |                      Œ± = Œ≤ = 1                    Œ¥ = 1                          |                          |                     MC(Œ≥, Œ¥, Œª)              EKw(Œ±, Œ≤, Œª)                          |                          |                       Œª = 1                    Œ≥ = Œ¥ = 1                          |                          |                     Beta(Œ≥, Œ¥)                   Kw(Œ±, Œ≤)"},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-1-basic-distribution-functions","dir":"","previous_headings":"Usage Examples","what":"Example 1: Basic Distribution Functions","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Set parameters alpha <- 2; beta <- 3; gamma <- 1.5; delta <- 2; lambda <- 1.2 x <- seq(0.01, 0.99, length.out = 100)  # Density dens <- dgkw(x, alpha, beta, gamma, delta, lambda)  # CDF cdf <- pgkw(x, alpha, beta, gamma, delta, lambda)  # Quantiles q <- qgkw(c(0.25, 0.5, 0.75), alpha, beta, gamma, delta, lambda) print(q)  # Random generation set.seed(123) random_sample <- rgkw(1000, alpha, beta, gamma, delta, lambda)  # Visualization par(mfrow = c(1, 2)) plot(x, dens, type = \"l\", lwd = 2, col = \"blue\",      main = \"GKw PDF\", xlab = \"x\", ylab = \"Density\") grid()  plot(x, cdf, type = \"l\", lwd = 2, col = \"red\",      main = \"GKw CDF\", xlab = \"x\", ylab = \"F(x)\") grid()"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-2-comparing-distribution-families","dir":"","previous_headings":"Usage Examples","what":"Example 2: Comparing Distribution Families","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  par(mfrow = c(1,1), mar = c(3,3,2,2))  x <- seq(0.001, 0.999, length.out = 500)  # Compute densities for all families d_gkw  <- dgkw(x, 2, 3, 1.5, 2, 1.2) d_bkw  <- dbkw(x, 2, 3, 1.5, 2) d_kkw  <- dkkw(x, 2, 3, 2, 1.2) d_ekw  <- dekw(x, 2, 3, 1.5) d_mc   <- dmc(x, 2, 3, 1.2) d_kw   <- dkw(x, 2, 5) d_beta <- dbeta_(x, 2, 3)  # Plot comparison plot(x, d_gkw, type = \"l\", lwd = 2, col = \"black\",      ylim = c(0, max(d_gkw, d_bkw, d_kkw, d_ekw, d_mc, d_kw, d_beta)),      main = \"Distribution Family Comparison\",      xlab = \"x\", ylab = \"Density\") lines(x, d_bkw, lwd = 2, col = \"red\") lines(x, d_kkw, lwd = 2, col = \"blue\") lines(x, d_ekw, lwd = 2, col = \"green\") lines(x, d_mc,  lwd = 2, col = \"purple\") lines(x, d_kw,  lwd = 2, col = \"orange\") lines(x, d_beta, lwd = 2, col = \"brown\") legend(\"topright\",        legend = c(\"GKw\", \"BKw\", \"KKw\", \"EKw\", \"MC\", \"Kw\", \"Beta\"),        col = c(\"black\", \"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\"),        lwd = 2, cex = 0.85) grid()"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-3-maximum-likelihood-estimation-using-optim","dir":"","previous_headings":"Usage Examples","what":"Example 3: Maximum Likelihood Estimation Using optim()","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Generate synthetic data from Kumaraswamy distribution set.seed(2024)  n <- 2000 true_alpha <- 2.5 true_beta  <- 3.5 data <- rkw(n, true_alpha, true_beta)  # Get starting values par_ini <- gkwgetstartvalues(data, family = \"kw\", n_starts = 2)  # Optimization using BFGS with analytical gradient fit <- optim(   par = par_ini,   fn = llkw,  # Negative log-likelihood function   gr = grkw,  # Negative gradient (negative score function)   data = data,   method = \"BFGS\",   hessian = TRUE )  # Standard errors from observed information matrix se <- sqrt(diag(solve(fit$hessian)))  # 95% Confidence intervals ci <- cbind(   Lower    = fit$par - 1.96 * se,   Estimate = fit$par,   Upper    = fit$par + 1.96 * se ) rownames(ci) <- c(\"alpha\", \"beta\")  cat(\"True parameters:    \", true_alpha, true_beta, \"\\n\") cat(\"Estimated parameters:\", fit$par, \"\\n\\n\") print(ci)"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-4-goodness-of-fit-diagnostic-plot","dir":"","previous_headings":"Usage Examples","what":"Example 4: Goodness-of-Fit Diagnostic Plot","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Using fitted model from Example 3 x_grid <- seq(0.001, 0.999, length.out = 200)  # Fitted density fitted_dens <- dkw(x_grid, fit$par[1], fit$par[2])  # True density (for comparison) true_dens <- dkw(x_grid, true_alpha, true_beta)  # Diagnostic plot hist(data, breaks = 30, probability = TRUE,      col = \"lightgray\", border = \"white\",      main = \"Kumaraswamy Distribution Fit\",      xlab = \"Data\", ylab = \"Density\") lines(x_grid, fitted_dens, col = \"red\", lwd = 2, lty = 1) lines(x_grid, true_dens, col = \"blue\", lwd = 2, lty = 2) legend(\"topright\",        legend = c(\"Observed Data\", \"Fitted Model\", \"True Model\"),        col = c(\"gray\", \"red\", \"blue\"),        lwd = c(10, 2, 2), lty = c(1, 1, 2)) grid()"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-5-model-selection-using-aic-and-bic","dir":"","previous_headings":"Usage Examples","what":"Example 5: Model Selection Using AIC and BIC","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Generate data from Exponentiated Kumaraswamy set.seed(456) n <- 1500 data <- rekw(n, alpha = 2, beta = 3, lambda = 1.5)  # Define competing models models <- list(   Beta = list(     nll = function(par) llbeta(par, data),     gr = function(par) grbeta(par, data),     start = gkwgetstartvalues(data, family = \"beta\"),     npar = 2   ),   Kw = list(     nll = function(par) llkw(par, data),     gr = function(par) grkw(par, data),     start = gkwgetstartvalues(data, family = \"kw\"),     npar = 2   ),   EKw = list(     nll = function(par) llekw(par, data),     gr = function(par) grekw(par, data),     start = gkwgetstartvalues(data, family = \"ekw\"),     npar = 3   ),   MC = list(     nll = function(par) llmc(par, data),     gr = function(par) grmc(par, data),     start = gkwgetstartvalues(data, family = \"mc\"),     npar = 3   ) )  # Fit all models using optim with analytical gradients fits <- lapply(models, function(m) {   optim(par = m$start, fn = m$nll, gr = m$gr, method = \"BFGS\") })  # Extract log-likelihoods and compute information criteria loglik <- sapply(fits, function(f) -f$value) k <- sapply(models, `[[`, \"npar\")  results <- data.frame(   Model  = names(models),   Coefs  = sapply(fits, function(f) paste0(round(f$par, 3), collapse = \"|\")),   LogLik = round(loglik, 2),   nPar   = k,   AIC    = round(-2 * loglik + 2 * k, 2),   BIC    = round(-2 * loglik + k * log(n), 2) )  # Sort by AIC results <- results[order(results$AIC), ] print(results, row.names = FALSE) cat(\"\\nBest model by AIC:\", results$Model[1], \"\\n\")"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-6-using-analytical-functions-directly","dir":"","previous_headings":"Usage Examples","what":"Example 6: Using Analytical Functions Directly","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Generate data from EKw set.seed(789) n <- 1000 data <- rekw(n, alpha = 2, beta = 3, lambda = 1.5) params <- c(2, 3, 1.5)  # Compute analytical functions at true parameters nll <- llekw(params, data) neg_score <- grekw(params, data) neg_hess <- hsekw(params, data)  # Fisher information matrix (negative of negative Hessian = Hessian) fisher <- -neg_hess  # Asymptotic standard errors se <- sqrt(diag(solve(fisher))) names(se) <- c(\"alpha\", \"beta\", \"lambda\")  cat(\"Negative log-likelihood:\", nll, \"\\n\") cat(\"\\nNegative score vector (should be close to zero at true params):\\n\") print(neg_score) cat(\"\\nNegative Hessian matrix:\\n\") print(neg_hess) cat(\"\\nFisher Information matrix:\\n\") print(fisher) cat(\"\\nAsymptotic standard errors:\\n\") print(se)"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-7-q-q-plot-for-model-validation","dir":"","previous_headings":"Usage Examples","what":"Example 7: Q-Q Plot for Model Validation","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Generate data and fit model set.seed(101) n <- 2000 data <- rkw(n, alpha = 2, beta = 3)  # Fit using optim fit <- optim(   par = c(1, 1),   fn = function(par) llkw(par, data),   gr = function(par) grkw(par, data),   method = \"BFGS\" )  # Theoretical quantiles p <- ppoints(n) theoretical_q <- qkw(p, fit$par[1], fit$par[2])  # Empirical quantiles empirical_q <- sort(data)  # Q-Q plot plot(theoretical_q, empirical_q,      xlab = \"Theoretical Quantiles\",      ylab = \"Empirical Quantiles\",      main = \"Q-Q Plot: Kumaraswamy Distribution\",      pch = 19, col = rgb(0, 0, 1, 0.5)) abline(0, 1, col = \"red\", lwd = 2, lty = 2) grid()"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-8-fitting-gkw-full-model-using-optim","dir":"","previous_headings":"Usage Examples","what":"Example 8: Fitting GKw (Full Model) Using optim()","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Generate data from GKw set.seed(2025) n <- 10000 true_params <- c(alpha = 2, beta = 2.5, gamma = 1.5, delta = 2, lambda = 1.3) data <- rgkw(n, true_params[1], true_params[2], true_params[3],              true_params[4], true_params[5])  # Get starting values par_ini <- gkwgetstartvalues(data, family = \"gkw\", n_starts = 5)  # Fit using optim with analytical gradient fit_gkw <- optim(   par = par_ini,    fn = llgkw,    # Negative log-likelihood   gr = grgkw,    # Negative gradient   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(maxit = 1000) )  # Results se <- sqrt(diag(solve(fit_gkw$hessian))) estimates <- data.frame(   Parameter = names(true_params),   True = true_params,   Estimate = fit_gkw$par,   SE = se ) print(estimates, digits = 4)"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"example-9-comparing-analytical-vs-numerical-derivatives","dir":"","previous_headings":"Usage Examples","what":"Example 9: Comparing Analytical vs Numerical Derivatives","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"library(gkwdist)  # Generate data set.seed(999) n <- 10000 data <- rkw(n, alpha = 2, beta = 3) par <- c(2, 3)  # Negative analytical gradient neg_grad_analytical <- grkw(par, data)  # Numerical gradient (using finite differences) neg_grad_numerical <- numDeriv::grad(   func = function(p) llkw(p, data),   x = par )  # Compare comparison <- data.frame(   Parameter = c(\"alpha\", \"beta\"),   Analytical = neg_grad_analytical,   Numerical = neg_grad_numerical,   Difference = abs(neg_grad_analytical - neg_grad_numerical) ) print(comparison, digits = 8)"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"performance-comparison","dir":"","previous_headings":"","what":"Performance Comparison","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"C++ implementation provides substantial performance gains: C++ Implementation Matters: Speed: Critical maximum likelihood estimation large datasets Numerical Stability: Better handling extreme parameter values edge cases Memory Efficiency: Optimized memory allocation tight loops Scalability: Linear scaling sample size Precision: Analytical derivatives exact (floating-point precision)","code":"library(microbenchmark)  # Generate large dataset n <- 10000 data <- rkw(n, 2, 3)  # Compare log-likelihood computation benchmark <- microbenchmark(   R_sum_log_d = -sum(log(dkw(data, 2, 3))),  # Manual negative log-likelihood   Cpp_ll = llkw(c(2, 3), data),               # C++ negative log-likelihood   times = 100 )  print(benchmark) plot(benchmark) # Typical results: C++ implementation is 10-50√ó faster"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"when-to-use-each-distribution","dir":"","previous_headings":"","what":"When to Use Each Distribution","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Model Selection Workflow: Start Beta Kumaraswamy (2 parameters) Check goodness--fit using Q-Q plots formal tests inadequate, try EKw MC (3 parameters) complex patterns, use BKw, KKw, GKw (4-5 parameters) Use AIC/BIC balance fit quality parsimony Validate final model residual diagnostics","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, 81(7), 883-898. doi:10.1080/00949650903530745 Carrasco, J. M. F., Ferrari, S. L. P., & Cordeiro, G. M. (2010). new generalized Kumaraswamy distribution. arXiv:1004.0911. arxiv.org/abs/1004.0911 Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. doi:10.1016/0022-1694(80)90036-0 Jones, M. C. (2009). Kumaraswamy‚Äôs distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81. doi:10.1016/j.stamet.2008.04.001 Lemonte, . J., & Cordeiro, G. M. (2013). extended Lomax distribution. Statistics, 47(4), 800-816. doi:10.1080/02331888.2011.568119 Cordeiro, G. M., & Lemonte, . J. (2011). Œ≤-Birnbaum‚ÄìSaunders distribution: improved distribution fatigue life modeling. Computational Statistics & Data Analysis, 55(3), 1445-1461. doi:10.1016/j.csda.2010.10.007 McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. doi:10.2307/1913469 Cordeiro, G. M., & Brito, R. S. (2012). beta power distribution. Brazilian Journal Probability Statistics, 26(1), 88-112. doi:10.1214/10-BJPS124","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"","code":"citation(\"gkwdist\") @Manual{gkwdist2025,   title  = {gkwdist: Generalized Kumaraswamy Distribution Family},   author = {J. E. Lopes},   year   = {2025},   note   = {R package},   url    = {https://github.com/evandeilton/gkwdist} }"},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"J. E. Lopes LEG - Laboratory Statistics Geoinformation PPGMNE - Graduate Program Numerical Methods Engineering Federal University Paran√° (UFPR), Brazil Email: evandeilton@gmail.com","code":""},{"path":"https://evandeilton.github.io/gkwdist/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"gkwdist: Generalized Kumaraswamy Distribution Family","text":"MIT License. See LICENSE file details.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"Computes probability density function (PDF) standard Beta distribution, using parameterization common generalized distribution families. distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1. distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"","code":"dbeta_(x, gamma, delta, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"x Vector quantiles (values 0 1). gamma First shape parameter (shape1), \\(\\gamma > 0\\). Can scalar vector. Default: 1.0. delta Second shape parameter delta + 1 (shape2), requires \\(\\delta \\ge 0\\) shape2 >= 1. Can scalar vector. Default: 0.0 (leading shape2 = 1). log_prob Logical; TRUE, logarithm density returned (\\(\\log(f(x))\\)). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, gamma, delta). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid (e.g., gamma <= 0, delta < 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"probability density function (PDF) calculated function corresponds standard Beta distribution \\(Beta(\\gamma, \\delta+1)\\): $$ f(x; \\gamma, \\delta) = \\frac{x^{\\gamma-1} (1-x)^{(\\delta+1)-1}}{B(\\gamma, \\delta+1)} = \\frac{x^{\\gamma-1} (1-x)^{\\delta}}{B(\\gamma, \\delta+1)} $$ \\(0 < x < 1\\), \\(B(,b)\\) Beta function (beta). specific parameterization arises special case five-parameter Generalized Kumaraswamy (GKw) distribution (dgkw) obtained setting parameters \\(\\alpha = 1\\), \\(\\beta = 1\\), \\(\\lambda = 1\\). therefore equivalent McDonald (Mc)/Beta Power distribution (dmc) \\(\\lambda = 1\\). Note difference second parameter compared dbeta, dbeta(x, shape1, shape2) uses shape2 directly. , shape1 = gamma shape2 = delta + 1.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation,","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbeta_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî dbeta_","text":"","code":"# \\donttest{ # Example values x_vals <- c(0.2, 0.5, 0.8) gamma_par <- 2.0 # Corresponds to shape1 delta_par <- 3.0 # Corresponds to shape2 - 1 shape1 <- gamma_par shape2 <- delta_par + 1  # Calculate density using dbeta_ densities <- dbeta_(x_vals, gamma_par, delta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(densities) #> Error: object 'densities' not found  # Compare with stats::dbeta densities_stats <- stats::dbeta(x_vals, shape1 = shape1, shape2 = shape2) print(paste(\"Max difference vs stats::dbeta:\", max(abs(densities - densities_stats)))) #> Error: object 'densities' not found  # Compare with dgkw setting alpha=1, beta=1, lambda=1 densities_gkw <- dgkw(x_vals, alpha = 1.0, beta = 1.0, gamma = gamma_par,                       delta = delta_par, lambda = 1.0) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference vs dgkw:\", max(abs(densities - densities_gkw)))) #> Error: object 'densities' not found  # Compare with dmc setting lambda=1 densities_mc <- dmc(x_vals, gamma = gamma_par, delta = delta_par, lambda = 1.0) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference vs dmc:\", max(abs(densities - densities_mc)))) #> Error: object 'densities' not found  # Calculate log-density log_densities <- dbeta_(x_vals, gamma_par, delta_par, log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_densities) #> Error: object 'log_densities' not found print(stats::dbeta(x_vals, shape1 = shape1, shape2 = shape2, log = TRUE)) #> [1]  0.7168637  0.2231436 -2.0557250  # Plot the density curve_x <- seq(0.001, 0.999, length.out = 200) curve_y <- dbeta_(curve_x, gamma = 2, delta = 3) # Beta(2, 4) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt plot(curve_x, curve_y, type = \"l\", main = \"Beta(2, 4) Density via dbeta_\",      xlab = \"x\", ylab = \"f(x)\", col = \"blue\") #> Error: object 'curve_y' not found curve(stats::dbeta(x, 2, 4), add=TRUE, col=\"red\", lty=2) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet legend(\"topright\", legend=c(\"dbeta_(gamma=2, delta=3)\", \"stats::dbeta(shape1=2, shape2=4)\"),        col=c(\"blue\", \"red\"), lty=c(1,2), bty=\"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"Computes probability density function (PDF) Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"","code":"dbkw(x, alpha, beta, gamma, delta, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"x Vector quantiles (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. log_prob Logical; TRUE, logarithm density returned (\\(\\log(f(x))\\)). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, alpha, beta, gamma, delta). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid (e.g., alpha <= 0, beta <= 0, gamma <= 0, delta < 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"probability density function (PDF) Beta-Kumaraswamy (BKw) distribution given : $$ f(x; \\alpha, \\beta, \\gamma, \\delta) = \\frac{\\alpha \\beta}{B(\\gamma, \\delta+1)} x^{\\alpha - 1} \\bigl(1 - x^\\alpha\\bigr)^{\\beta(\\delta+1) - 1} \\bigl[1 - \\bigl(1 - x^\\alpha\\bigr)^\\beta\\bigr]^{\\gamma - 1} $$ \\(0 < x < 1\\), \\(B(,b)\\) Beta function (beta). BKw distribution special case five-parameter Generalized Kumaraswamy (GKw) distribution (dgkw) obtained setting parameter \\(\\lambda = 1\\). Numerical evaluation performed using algorithms similar dgkw, ensuring stability.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the Beta-Kumaraswamy (BKw) Distribution ‚Äî dbkw","text":"","code":"# \\donttest{ # Example values x_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 1.5 gamma_par <- 1.0 # Equivalent to Kw when gamma=1 delta_par <- 0.5  # Calculate density densities <- dbkw(x_vals, alpha_par, beta_par, gamma_par, delta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(densities) #> Error: object 'densities' not found  # Calculate log-density log_densities <- dbkw(x_vals, alpha_par, beta_par, gamma_par, delta_par,                       log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_densities) #> Error: object 'log_densities' not found # Check: should match log(densities) print(log(densities)) #> Error: object 'densities' not found  # Compare with dgkw setting lambda = 1 densities_gkw <- dgkw(x_vals, alpha_par, beta_par, gamma = gamma_par,                       delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(densities - densities_gkw)))) # Should be near zero #> Error: object 'densities' not found  # Plot the density for different gamma values curve_x <- seq(0.01, 0.99, length.out = 200) curve_y1 <- dbkw(curve_x, alpha = 2, beta = 3, gamma = 0.5, delta = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_y2 <- dbkw(curve_x, alpha = 2, beta = 3, gamma = 1.0, delta = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_y3 <- dbkw(curve_x, alpha = 2, beta = 3, gamma = 2.0, delta = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  plot(curve_x, curve_y1, type = \"l\", main = \"BKw Density Examples (alpha=2, beta=3, delta=1)\",      xlab = \"x\", ylab = \"f(x)\", col = \"blue\", ylim = range(0, curve_y1, curve_y2, curve_y3)) #> Error: object 'curve_y1' not found lines(curve_x, curve_y2, col = \"red\") #> Error: object 'curve_y2' not found lines(curve_x, curve_y3, col = \"green\") #> Error: object 'curve_y3' not found legend(\"topright\", legend = c(\"gamma=0.5\", \"gamma=1.0\", \"gamma=2.0\"),        col = c(\"blue\", \"red\", \"green\"), lty = 1, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"Computes probability density function (PDF) Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"","code":"dekw(x, alpha, beta, lambda, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"x Vector quantiles (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. lambda Shape parameter lambda > 0 (exponent parameter). Can scalar vector. Default: 1.0. log_prob Logical; TRUE, logarithm density returned (\\(\\log(f(x))\\)). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, alpha, beta, lambda). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid (e.g., alpha <= 0, beta <= 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"probability density function (PDF) Exponentiated Kumaraswamy (EKw) distribution given : $$ f(x; \\alpha, \\beta, \\lambda) = \\lambda \\alpha \\beta x^{\\alpha-1} (1 - x^\\alpha)^{\\beta-1} \\bigl[1 - (1 - x^\\alpha)^\\beta \\bigr]^{\\lambda - 1} $$ \\(0 < x < 1\\). EKw distribution special case five-parameter Generalized Kumaraswamy (GKw) distribution (dgkw) obtained setting parameters \\(\\gamma = 1\\) \\(\\delta = 0\\). \\(\\lambda = 1\\), EKw distribution reduces standard Kumaraswamy distribution.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî dekw","text":"","code":"# \\donttest{ # Example values x_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 3.0 lambda_par <- 1.5 # Exponent parameter  # Calculate density densities <- dekw(x_vals, alpha_par, beta_par, lambda_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(densities) #> Error: object 'densities' not found  # Calculate log-density log_densities <- dekw(x_vals, alpha_par, beta_par, lambda_par, log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_densities) #> Error: object 'log_densities' not found # Check: should match log(densities) print(log(densities)) #> Error: object 'densities' not found  # Compare with dgkw setting gamma = 1, delta = 0 densities_gkw <- dgkw(x_vals, alpha_par, beta_par, gamma = 1.0, delta = 0.0,                       lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(densities - densities_gkw)))) # Should be near zero #> Error: object 'densities' not found  # Plot the density for different lambda values curve_x <- seq(0.01, 0.99, length.out = 200) curve_y1 <- dekw(curve_x, alpha = 2, beta = 3, lambda = 0.5) # less peaked #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_y2 <- dekw(curve_x, alpha = 2, beta = 3, lambda = 1.0) # standard Kw #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_y3 <- dekw(curve_x, alpha = 2, beta = 3, lambda = 2.0) # more peaked #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  plot(curve_x, curve_y2, type = \"l\", main = \"EKw Density Examples (alpha=2, beta=3)\",      xlab = \"x\", ylab = \"f(x)\", col = \"red\", ylim = range(0, curve_y1, curve_y2, curve_y3)) #> Error: object 'curve_y2' not found lines(curve_x, curve_y1, col = \"blue\") #> Error: object 'curve_y1' not found lines(curve_x, curve_y3, col = \"green\") #> Error: object 'curve_y3' not found legend(\"topright\", legend = c(\"lambda=0.5\", \"lambda=1.0 (Kw)\", \"lambda=2.0\"),        col = c(\"blue\", \"red\", \"green\"), lty = 1, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"Computes probability density function (PDF) five-parameter Generalized Kumaraswamy (GKw) distribution, defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"","code":"dgkw(x, alpha, beta, gamma, delta, lambda, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"x Vector quantiles (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. log_prob Logical; TRUE, logarithm density returned. Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, alpha, beta, gamma, delta, lambda). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"probability density function Generalized Kumaraswamy (GKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)) given : $$ f(x; \\alpha, \\beta, \\gamma, \\delta, \\lambda) =   \\frac{\\lambda \\alpha \\beta x^{\\alpha-1}(1-x^{\\alpha})^{\\beta-1}}        {B(\\gamma, \\delta+1)}   [1-(1-x^{\\alpha})^{\\beta}]^{\\gamma\\lambda-1}   [1-[1-(1-x^{\\alpha})^{\\beta}]^{\\lambda}]^{\\delta} $$ \\(x \\(0,1)\\), \\(B(, b)\\) Beta function beta. distribution proposed Cordeiro & de Castro (2011) includes several distributions special cases: Kumaraswamy (Kw): gamma = 1, delta = 0, lambda = 1 Exponentiated Kumaraswamy (EKw): gamma = 1, delta = 0 Beta-Kumaraswamy (BKw): lambda = 1 Generalized Beta type 1 (GB1 - implies McDonald): alpha = 1, beta = 1 Beta distribution: alpha = 1, beta = 1, lambda = 1 function includes checks valid parameters input values x. uses numerical stabilization x close 0 1.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, 81(7), 883-898. Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the Generalized Kumaraswamy Distribution ‚Äî dgkw","text":"","code":"# \\donttest{ # Simple density evaluation at a point dgkw(0.5, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) # Kw case #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Plot the PDF for various parameter sets x_vals <- seq(0.01, 0.99, by = 0.01)  # Standard Kumaraswamy (gamma=1, delta=0, lambda=1) pdf_kw <- dgkw(x_vals, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Beta equivalent (alpha=1, beta=1, lambda=1) - Beta(gamma, delta+1) pdf_beta <- dgkw(x_vals, alpha = 1, beta = 1, gamma = 2, delta = 3, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt # Compare with stats::dbeta pdf_beta_check <- stats::dbeta(x_vals, shape1 = 2, shape2 = 3 + 1) # max(abs(pdf_beta - pdf_beta_check)) # Should be close to zero  # Exponentiated Kumaraswamy (gamma=1, delta=0) pdf_ekw <- dgkw(x_vals, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 2) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  plot(x_vals, pdf_kw, type = \"l\", ylim = range(c(pdf_kw, pdf_beta, pdf_ekw)),      main = \"GKw Densities Examples\", ylab = \"f(x)\", xlab=\"x\", col = \"blue\") #> Error: object 'pdf_kw' not found lines(x_vals, pdf_beta, col = \"red\") #> Error: object 'pdf_beta' not found lines(x_vals, pdf_ekw, col = \"green\") #> Error: object 'pdf_ekw' not found legend(\"topright\", legend = c(\"Kw(2,3)\", \"Beta(2,4) equivalent\", \"EKw(2,3, lambda=2)\"),        col = c(\"blue\", \"red\", \"green\"), lty = 1, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Log-density log_pdf_val <- dgkw(0.5, 2, 3, 1, 0, 1, log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_pdf_val) #> Error: object 'log_pdf_val' not found print(log(dgkw(0.5, 2, 3, 1, 0, 1))) # Should match #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(log(dgkw(0.5, 2, 3, 1, 0, 1))): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"Computes probability density function (PDF) Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"","code":"dkkw(x, alpha, beta, delta, lambda, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"x Vector quantiles (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. log_prob Logical; TRUE, logarithm density returned (\\(\\log(f(x))\\)). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, alpha, beta, delta, lambda). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid (e.g., alpha <= 0, beta <= 0, delta < 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"Kumaraswamy-Kumaraswamy (kkw) distribution special case five-parameter Generalized Kumaraswamy distribution (dgkw) obtained setting parameter \\(\\gamma = 1\\). probability density function given : $$ f(x; \\alpha, \\beta, \\delta, \\lambda) = (\\delta + 1) \\lambda \\alpha \\beta x^{\\alpha - 1} (1 - x^\\alpha)^{\\beta - 1} \\bigl[1 - (1 - x^\\alpha)^\\beta\\bigr]^{\\lambda - 1} \\bigl\\{1 - \\bigl[1 - (1 - x^\\alpha)^\\beta\\bigr]^\\lambda\\bigr\\}^{\\delta} $$ \\(0 < x < 1\\). Note \\(1/(\\delta+1)\\) corresponds Beta function term \\(B(1, \\delta+1)\\) \\(\\gamma=1\\). Numerical evaluation follows similar stability considerations dgkw.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî dkkw","text":"","code":"# \\donttest{ # Example values x_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 3.0 delta_par <- 0.5 lambda_par <- 1.5  # Calculate density densities <- dkkw(x_vals, alpha_par, beta_par, delta_par, lambda_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(densities) #> Error: object 'densities' not found  # Calculate log-density log_densities <- dkkw(x_vals, alpha_par, beta_par, delta_par, lambda_par,                        log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_densities) #> Error: object 'log_densities' not found # Check: should match log(densities) print(log(densities)) #> Error: object 'densities' not found  # Compare with dgkw setting gamma = 1 densities_gkw <- dgkw(x_vals, alpha_par, beta_par, gamma = 1.0,                       delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(densities - densities_gkw)))) # Should be near zero #> Error: object 'densities' not found  # Plot the density curve_x <- seq(0.01, 0.99, length.out = 200) curve_y <- dkkw(curve_x, alpha_par, beta_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt plot(curve_x, curve_y, type = \"l\", main = \"kkw Density Example\",      xlab = \"x\", ylab = \"f(x)\", col = \"blue\") #> Error: object 'curve_y' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"Computes probability density function (PDF) two-parameter Kumaraswamy (Kw) distribution shape parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"","code":"dkw(x, alpha, beta, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"x Vector quantiles (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. log_prob Logical; TRUE, logarithm density returned (\\(\\log(f(x))\\)). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, alpha, beta). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid (e.g., alpha <= 0, beta <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"probability density function (PDF) Kumaraswamy (Kw) distribution given : $$ f(x; \\alpha, \\beta) = \\alpha \\beta x^{\\alpha-1} (1 - x^\\alpha)^{\\beta-1} $$ \\(0 < x < 1\\), \\(\\alpha > 0\\), \\(\\beta > 0\\). Kumaraswamy distribution identical Generalized Kumaraswamy (GKw) distribution (dgkw) parameters \\(\\gamma = 1\\), \\(\\delta = 0\\), \\(\\lambda = 1\\). also special case Exponentiated Kumaraswamy (dekw) \\(\\lambda = 1\\), Kumaraswamy-Kumaraswamy (dkkw) \\(\\delta = 0\\) \\(\\lambda = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the Kumaraswamy (Kw) Distribution ‚Äî dkw","text":"","code":"# \\donttest{ # Example values x_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 3.0  # Calculate density using dkw densities <- dkw(x_vals, alpha_par, beta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(densities) #> Error: object 'densities' not found  # Calculate log-density log_densities <- dkw(x_vals, alpha_par, beta_par, log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_densities) #> Error: object 'log_densities' not found # Check: should match log(densities) print(log(densities)) #> Error: object 'densities' not found  # Compare with dgkw setting gamma = 1, delta = 0, lambda = 1 densities_gkw <- dgkw(x_vals, alpha_par, beta_par, gamma = 1.0, delta = 0.0,                       lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(densities - densities_gkw)))) # Should be near zero #> Error: object 'densities' not found  # Plot the density for different shape parameter combinations curve_x <- seq(0.001, 0.999, length.out = 200) plot(curve_x, dkw(curve_x, alpha = 2, beta = 3), type = \"l\",      main = \"Kumaraswamy Density Examples\", xlab = \"x\", ylab = \"f(x)\",      col = \"blue\", ylim = c(0, 4)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y, xlabel, ylabel, log): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_x, dkw(curve_x, alpha = 3, beta = 2), col = \"red\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_x, dkw(curve_x, alpha = 0.5, beta = 0.5), col = \"green\") # U-shaped #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_x, dkw(curve_x, alpha = 5, beta = 1), col = \"purple\") # J-shaped #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_x, dkw(curve_x, alpha = 1, beta = 3), col = \"orange\") # J-shaped (reversed) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"top\", legend = c(\"a=2, b=3\", \"a=3, b=2\", \"a=0.5, b=0.5\", \"a=5, b=1\", \"a=1, b=3\"),        col = c(\"blue\", \"red\", \"green\", \"purple\", \"orange\"), lty = 1, bty = \"n\", ncol = 2) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"Computes probability density function (PDF) McDonald (Mc) distribution (also previously referred Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"","code":"dmc(x, gamma, delta, lambda, log_prob = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"x Vector quantiles (values 0 1). gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. log_prob Logical; TRUE, logarithm density returned (\\(\\log(f(x))\\)). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"vector density values (\\(f(x)\\)) log-density values (\\(\\log(f(x))\\)). length result determined recycling rule applied arguments (x, gamma, delta, lambda). Returns 0 (-Inf log_prob = TRUE) x outside interval (0, 1), NaN parameters invalid (e.g., gamma <= 0, delta < 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"probability density function (PDF) McDonald (Mc) distribution given : $$ f(x; \\gamma, \\delta, \\lambda) = \\frac{\\lambda}{B(\\gamma,\\delta+1)} x^{\\gamma \\lambda - 1} (1 - x^\\lambda)^\\delta $$ \\(0 < x < 1\\), \\(B(,b)\\) Beta function (beta). Mc distribution special case five-parameter Generalized Kumaraswamy (GKw) distribution (dgkw) obtained setting parameters \\(\\alpha = 1\\) \\(\\beta = 1\\). introduced McDonald (1984) related Generalized Beta distribution first kind (GB1). \\(\\lambda=1\\), simplifies standard Beta distribution parameters \\(\\gamma\\) \\(\\delta+1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/dmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of the McDonald (Mc)/Beta Power Distribution Distribution ‚Äî dmc","text":"","code":"# \\donttest{ # Example values x_vals <- c(0.2, 0.5, 0.8) gamma_par <- 2.0 delta_par <- 1.5 lambda_par <- 1.0 # Equivalent to Beta(gamma, delta+1)  # Calculate density using dmc densities <- dmc(x_vals, gamma_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(densities) #> Error: object 'densities' not found # Compare with Beta density print(stats::dbeta(x_vals, shape1 = gamma_par, shape2 = delta_par + 1)) #> [1] 1.252198 1.546796 0.626099  # Calculate log-density log_densities <- dmc(x_vals, gamma_par, delta_par, lambda_par, log_prob = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_densities) #> Error: object 'log_densities' not found  # Compare with dgkw setting alpha = 1, beta = 1 densities_gkw <- dgkw(x_vals, alpha = 1.0, beta = 1.0, gamma = gamma_par,                       delta = delta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(densities - densities_gkw)))) # Should be near zero #> Error: object 'densities' not found  # Plot the density for different lambda values curve_x <- seq(0.01, 0.99, length.out = 200) curve_y1 <- dmc(curve_x, gamma = 2, delta = 3, lambda = 0.5) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_y2 <- dmc(curve_x, gamma = 2, delta = 3, lambda = 1.0) # Beta(2, 4) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_y3 <- dmc(curve_x, gamma = 2, delta = 3, lambda = 2.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  plot(curve_x, curve_y2, type = \"l\", main = \"McDonald (Mc) Density (gamma=2, delta=3)\",      xlab = \"x\", ylab = \"f(x)\", col = \"red\", ylim = range(0, curve_y1, curve_y2, curve_y3)) #> Error: object 'curve_y2' not found lines(curve_x, curve_y1, col = \"blue\") #> Error: object 'curve_y1' not found lines(curve_x, curve_y3, col = \"green\") #> Error: object 'curve_y3' not found legend(\"topright\", legend = c(\"lambda=0.5\", \"lambda=1.0 (Beta)\", \"lambda=2.0\"),        col = c(\"blue\", \"red\", \"green\"), lty = 1, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"gkwdist package provides comprehensive, high-performance implementation five-parameter Generalized Kumaraswamy (GKw) distribution seven nested sub-families modeling bounded continuous data unit interval \\((0,1)\\). distribution likelihood functions implemented C++ via RcppArmadillo maximum computational efficiency.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"Generalized Kumaraswamy distribution, proposed Carrasco, Ferrari Cordeiro (2010), extends Kumaraswamy distribution (Jones, 2009) incorporating three additional shape parameters. generalization provides remarkable flexibility accommodating various density shapes including unimodality, bimodality, asymmetry, J-shapes, inverted J-shapes, U-shapes, bathtub shapes, heavy light tails.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"mathematical-specification","dir":"Reference","previous_headings":"","what":"Mathematical Specification","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"probability density function (PDF) GKw distribution parameters \\(\\theta = (\\alpha, \\beta, \\gamma, \\delta, \\lambda)\\) (positive) : $$f(x; \\theta) = \\frac{\\lambda\\alpha\\beta x^{\\alpha-1}}{B(\\gamma, \\delta + 1)} (1 - x^\\alpha)^{\\beta-1} [1 - (1 - x^\\alpha)^\\beta]^{\\gamma\\lambda-1} \\{1 - [1 - (1 - x^\\alpha)^\\beta]^\\lambda\\}^\\delta$$ \\(0 < x < 1\\), \\(B(,b) = \\Gamma()\\Gamma(b)/\\Gamma(+b)\\) beta function. cumulative distribution function (CDF) : $$F(x; \\theta) = I_{[1-(1-x^\\alpha)^\\beta]^\\lambda}(\\gamma, \\delta + 1)$$ \\(I_y(,b)\\) denotes regularized incomplete beta function ratio.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"distribution-family-hierarchy","dir":"Reference","previous_headings":"","what":"Distribution Family Hierarchy","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"GKw distribution nests seven important sub-models: Beta-Kumaraswamy (BKw) 4 parameters: \\((\\alpha, \\beta, \\gamma, \\delta)\\). Set \\(\\lambda = 1\\) GKw. Kumaraswamy-Kumaraswamy (KKw) 4 parameters: \\((\\alpha, \\beta, \\delta, \\lambda)\\). Set \\(\\gamma = 1\\) GKw. Exponentiated Kumaraswamy (EKw) 3 parameters: \\((\\alpha, \\beta, \\lambda)\\). Set \\(\\gamma = 1, \\delta = 0\\) GKw. closed-form quantile function. McDonald (Mc) 3 parameters: \\((\\gamma, \\delta, \\lambda)\\). Set \\(\\alpha = \\beta = 1\\) GKw. Also known Beta-Power distribution. Kumaraswamy (Kw) 2 parameters: \\((\\alpha, \\beta)\\). Set \\(\\gamma = \\delta = \\lambda = 1\\) GKw. closed-form CDF quantile function. Beta 2 parameters: \\((\\gamma, \\delta)\\). Set \\(\\alpha = \\beta = \\lambda = 1\\) GKw. Classical beta distribution shape1 = gamma, shape2 = delta + 1. Uniform 0 parameters. Set shape parameters 1.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"distribution-functions","dir":"Reference","previous_headings":"","what":"Distribution Functions","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"package provides standard R distribution function API seven distributions. distribution four core functions prefix d, p, q, r: Generalized Kumaraswamy (GKw): dgkw: Density function pgkw: Distribution function (CDF) qgkw: Quantile function (inverse CDF) rgkw: Random generation Beta-Kumaraswamy (BKw): dbkw, pbkw, qbkw, rbkw Kumaraswamy-Kumaraswamy (KKw): dkkw, pkkw, qkkw, rkkw Exponentiated Kumaraswamy (EKw): dekw, pekw, qekw, rekw McDonald (Mc): dmc, pmc, qmc, rmc Kumaraswamy (Kw): dkw, pkw, qkw, rkw Beta: dbeta_, pbeta_, qbeta_, rbeta_ distribution functions implemented C++ optimal performance.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"likelihood-functions","dir":"Reference","previous_headings":"","what":"Likelihood Functions","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"High-performance analytical log-likelihood, gradient, Hessian functions provided maximum likelihood estimation. functions return negative values facilitate direct use optimization routines like optim, perform minimization default. Function signature: function(par, data) par numeric vector parameters data observed sample. ll* Negative log-likelihood: \\(-\\ell(\\theta) = -\\sum_{=1}^n \\log f(x_i; \\theta)\\) gr* Negative gradient (negative score vector): \\(-\\nabla_\\theta \\ell(\\theta)\\) hs* Negative Hessian matrix: \\(-\\nabla^2_\\theta \\ell(\\theta)\\) Available distributions: GKw: llgkw, grgkw, hsgkw BKw: llbkw, grbkw, hsbkw KKw: llkkw, grkkw, hskkw EKw: llekw, grekw, hsekw Mc: llmc, grmc, hsmc Kw: llkw, grkw, hskw Beta: llbeta, grbeta, hsbeta analytical derivatives exact (floating-point precision) provide substantial performance gains numerical approximations.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"utility-functions","dir":"Reference","previous_headings":"","what":"Utility Functions","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"gkwgetstartvalues: Compute starting values optimization using method moments quantile matching","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"applications","dir":"Reference","previous_headings":"","what":"Applications","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"GKw distribution family particularly suitable modeling: Proportions rates: Bounded continuous data \\((0,1)\\) Percentages: Economic indices, market shares, conversion rates Fractions: Parts whole, concentration measures Scores indices: Normalized measurements, standardized tests Reliability data: Component lifetimes bounded domains Hydrological phenomena: Reservoir levels, soil moisture content Financial ratios: Debt--equity, current ratio, profit margins Quality metrics: Defect rates, efficiency scores, purity levels Biostatistics: Survival probabilities, dose-response curves","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"advantages-over-standard-distributions","dir":"Reference","previous_headings":"","what":"Advantages Over Standard Distributions","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"Compared classical Beta distribution, GKw family offers: Greater flexibility density shapes (bimodal, U-shaped, bathtub) Better accommodation asymmetry tail behavior Closed-form CDF quantile sub-models (Kw, EKw, KKw) Computational efficiency via C++ implementation Easy parameter interpretation nested structure Superior performance extreme parameter values","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"functions implemented C++ using RcppArmadillo, providing: 10-100√ó speedup pure R implementations Linear scaling sample size Optimized memory allocation Numerical stability extreme parameter values Efficient vectorized operations Typical benchmarks modern hardware: Density evaluation: \\(>10^7\\) evaluations per second Log-likelihood: \\(n = 10^6\\) observations \\(<100\\)ms Gradient computation: \\(<5\\)√ó slower log-likelihood","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"model-selection-workflow","dir":"Reference","previous_headings":"","what":"Model Selection Workflow","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"Recommended strategy choosing among distributions: Exploratory Analysis: Examine histograms, kernel density estimates, summary statistics data. Start Simple: Fit Beta Kumaraswamy distributions (2 parameters). Use optim method = \"BFGS\" analytical gradients. Diagnostic Checking: Assess fit quality using Q-Q plots, probability plots, goodness--fit tests (e.g., Kolmogorov-Smirnov). Progressive Complexity: simple models inadequate, try 3-parameter models (EKw Mc), 4-parameter models (BKw KKw). Information Criteria: Use AIC, BIC, AICc balance goodness--fit model parsimony. Lower values indicate better models. Nested Testing: Perform likelihood ratio tests comparing nested models (e.g., Kw vs. EKw). Cross-Validation: Validate final model held-data via bootstrap procedures. Residual Analysis: Examine probability integral transform residuals uniformity independence.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"statistical-inference","dir":"Reference","previous_headings":"","what":"Statistical Inference","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"Maximum likelihood estimation performed using numerical optimization: Obtain starting values via gkwgetstartvalues manual specification based sample moments Minimize negative log-likelihood using optim method = \"BFGS\" \"L-BFGS-B\" Provide analytical gradient via gr argument faster convergence improved accuracy Set hessian = TRUE obtain observed information matrix Compute standard errors sqrt(diag(solve(hessian))) Construct confidence intervals using normal approximation profile likelihood Perform hypothesis tests using Wald, score, likelihood ratio statistics large samples (\\(n > 10^4\\)), consider using method = \"L-BFGS-B\" box constraints prevent parameter estimates drifting boundary values becoming numerically unstable.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"Carrasco, J. M. F., Ferrari, S. L. P., Cordeiro, G. M. (2010). new generalized Kumaraswamy distribution. arXiv preprint arXiv:1004.0911. doi:10.48550/arXiv.1004.0911 Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81. doi:10.1016/j.stamet.2008.04.001 Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. doi:10.1016/0022-1694(80)90036-0 Cordeiro, G. M., de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, 81(7), 883-898. doi:10.1080/00949650903530745 McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. doi:10.2307/1913469 Eddelbuettel, D., Francois, R. (2011). Rcpp: Seamless R C++ Integration. Journal Statistical Software, 40(8), 1-18. doi:10.18637/jss.v040.i08 Eddelbuettel, D., Sanderson, C. (2014). RcppArmadillo: Accelerating R high-performance C++ linear algebra. Computational Statistics & Data Analysis, 71, 1054-1063. doi:10.1016/j.csda.2013.02.005","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"J. E. Lopes evandeilton@gmail.com ORCID: 0009-0007-5887-4084 LEG - Laboratory Statistics Geoinformation PPGMNE - Graduate Program Numerical Methods Engineering Federal University Paran√° (UFPR), Brazil","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwdist-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Kumaraswamy Distribution Family ‚Äî gkwdist-package","text":"","code":"# \\donttest{ ## Example 1: Basic Distribution Functions  library(gkwdist)  # Set parameters for GKw distribution alpha <- 2.0 beta <- 3.0 gamma <- 1.5 delta <- 2.0 lambda <- 1.2  # Create sequence of x values x <- seq(0.01, 0.99, length.out = 200)  # Compute density dens <- dgkw(x, alpha, beta, gamma, delta, lambda) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Compute CDF cdf <- pgkw(x, alpha, beta, gamma, delta, lambda) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Compute specific quantiles probs <- c(0.05, 0.25, 0.5, 0.75, 0.95) quants <- qgkw(probs, alpha, beta, gamma, delta, lambda) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(round(quants, 4)) #> Error: object 'quants' not found  # Generate random sample set.seed(123) sample <- rgkw(1000, alpha, beta, gamma, delta, lambda) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # PDF plot(x, dens,      type = \"l\", lwd = 2, col = \"darkblue\",      main = \"GKw Probability Density Function\",      xlab = \"x\", ylab = \"f(x)\", las = 1 ) #> Error: object 'dens' not found grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # CDF plot(x, cdf,      type = \"l\", lwd = 2, col = \"darkred\",      main = \"GKw Cumulative Distribution Function\",      xlab = \"x\", ylab = \"F(x)\", las = 1 ) #> Error: object 'cdf' not found grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Histogram of random sample hist(sample,      breaks = 30, probability = TRUE,      col = \"lightblue\", border = \"white\",      main = \"Random Sample from GKw\",      xlab = \"x\", ylab = \"Density\", las = 1 ) #> Error in hist.default(sample, breaks = 30, probability = TRUE, col = \"lightblue\",     border = \"white\", main = \"Random Sample from GKw\", xlab = \"x\",     ylab = \"Density\", las = 1): 'x' must be numeric lines(x, dens, col = \"darkblue\", lwd = 2) #> Error: object 'dens' not found grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Q-Q plot theoretical <- qgkw(ppoints(length(sample)), alpha, beta, gamma, delta, lambda) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt empirical <- sort(sample) #> Error in sort.int(x, na.last = na.last, decreasing = decreasing, ...): 'x' must be atomic plot(theoretical, empirical,      pch = 19, col = rgb(0, 0, 1, 0.3),      main = \"Q-Q Plot\",      xlab = \"Theoretical Quantiles\", ylab = \"Sample Quantiles\", las = 1 ) #> Error: object 'theoretical' not found abline(0, 1, col = \"red\", lwd = 2, lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 2: Comparing Distribution Families  # Create comparison plot x <- seq(0.001, 0.999, length.out = 500)  # GKw (5 parameters) - most flexible plot(x, dgkw(x, 2, 3, 1.5, 2, 1.2),      type = \"l\", lwd = 2, col = \"black\",      main = \"GKw Distribution (5 params)\",      xlab = \"x\", ylab = \"Density\", las = 1, ylim = c(0, 3) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y, xlabel, ylabel, log): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # BKw (4 parameters) plot(x, dbkw(x, 2, 3, 1.5, 2),      type = \"l\", lwd = 2, col = \"darkgreen\",      main = \"BKw Distribution (4 params)\",      xlab = \"x\", ylab = \"Density\", las = 1, ylim = c(0, 3) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y, xlabel, ylabel, log): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # EKw (3 parameters) plot(x, dekw(x, 2, 3, 1.5),      type = \"l\", lwd = 2, col = \"darkred\",      main = \"EKw Distribution (3 params)\",      xlab = \"x\", ylab = \"Density\", las = 1, ylim = c(0, 3) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y, xlabel, ylabel, log): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Kw (2 parameters) - base distribution plot(x, dkw(x, 2, 3),      type = \"l\", lwd = 2, col = \"darkblue\",      main = \"Kw Distribution (2 params)\",      xlab = \"x\", ylab = \"Density\", las = 1, ylim = c(0, 3) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y, xlabel, ylabel, log): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 3: Maximum Likelihood Estimation  # Generate data from Kumaraswamy distribution set.seed(2024) n <- 2000 true_alpha <- 2.5 true_beta <- 3.5 data <- rkw(n, true_alpha, true_beta) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Obtain starting values start_vals <- gkwgetstartvalues(data, family = \"kw\", n_starts = 3) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Maximum likelihood estimation with analytical gradient fit <- optim(   par = start_vals,   fn = llkw, # Negative log-likelihood   gr = grkw, # Analytical gradient   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(maxit = 500) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_vals, fn = llkw, gr = grkw, data = data, method = \"BFGS\",     hessian = TRUE, control = list(maxit = 500)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Extract results mle <- fit$par #> Error: object 'fit' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  # Construct confidence intervals (95%) ci <- data.frame(   Parameter = c(\"alpha\", \"beta\"),   True = c(true_alpha, true_beta),   MLE = mle,   SE = se,   Lower = mle - 1.96 * se,   Upper = mle + 1.96 * se ) #> Error: object 'mle' not found  print(ci, digits = 4) #> Error: object 'ci' not found  # Goodness-of-fit diagnostic x_grid <- seq(0.001, 0.999, length.out = 200) fitted_dens <- dkw(x_grid, mle[1], mle[2]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt true_dens <- dkw(x_grid, true_alpha, true_beta) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  hist(data,      breaks = 40, probability = TRUE,      col = \"lightgray\", border = \"white\",      main = \"Kumaraswamy Distribution Fit\",      xlab = \"Data\", ylab = \"Density\", las = 1 ) #> Error in hist.default(data, breaks = 40, probability = TRUE, col = \"lightgray\",     border = \"white\", main = \"Kumaraswamy Distribution Fit\",     xlab = \"Data\", ylab = \"Density\", las = 1): 'x' must be numeric lines(x_grid, fitted_dens, col = \"red\", lwd = 2, lty = 1) #> Error: object 'fitted_dens' not found lines(x_grid, true_dens, col = \"blue\", lwd = 2, lty = 2) #> Error: object 'true_dens' not found legend(\"topright\",        legend = c(\"Data\", \"Fitted\", \"True\"),        col = c(\"gray\", \"red\", \"blue\"),        lwd = c(8, 2, 2), lty = c(1, 1, 2),        bty = \"n\" ) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray80\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 4: Model Selection Using Information Criteria  # Generate data from Exponentiated Kumaraswamy set.seed(456) n <- 1500 data <- rekw(n, alpha = 2, beta = 3, lambda = 1.5) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Define competing models models <- list(   Beta = list(     ll = function(par) llbeta(par, data),     gr = function(par) grbeta(par, data),     start = gkwgetstartvalues(data, family = \"beta\", n_starts = 2),     k = 2   ),   Kw = list(     ll = function(par) llkw(par, data),     gr = function(par) grkw(par, data),     start = gkwgetstartvalues(data, family = \"kw\", n_starts = 2),     k = 2   ),   EKw = list(     ll = function(par) llekw(par, data),     gr = function(par) grekw(par, data),     start = gkwgetstartvalues(data, family = \"ekw\", n_starts = 2),     k = 3   ),   Mc = list(     ll = function(par) llmc(par, data),     gr = function(par) grmc(par, data),     start = gkwgetstartvalues(data, family = \"mc\", n_starts = 2),     k = 3   ) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fit all models results <- lapply(names(models), function(name) {   m <- models[[name]]   fit <- optim(par = m$start, fn = m$ll, gr = m$gr, method = \"BFGS\")      loglik <- -fit$value   aic <- -2 * loglik + 2 * m$k   bic <- -2 * loglik + m$k * log(n)      data.frame(     Model = name,     k = m$k,     LogLik = round(loglik, 2),     AIC = round(aic, 2),     BIC = round(bic, 2),     stringsAsFactors = FALSE   ) }) #> Error: object 'models' not found  # Combine and sort by AIC comparison <- do.call(rbind, results) #> Error: object 'results' not found comparison <- comparison[order(comparison$AIC), ] #> Error: object 'comparison' not found rownames(comparison) <- NULL #> Error: object 'comparison' not found  print(comparison) #> Error: object 'comparison' not found cat(\"\\nBest model by AIC:\", comparison$Model[1], \"\\n\") #> Error: object 'comparison' not found cat(\"Best model by BIC:\", comparison$Model[which.min(comparison$BIC)], \"\\n\") #> Error: object 'comparison' not found # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"Estimates parameters various distribution families Generalized Kumaraswamy family using method moments. implementation optimized numerical stability computational efficiency Nelder-Mead optimization adaptive numerical integration.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"","code":"gkwgetstartvalues(x, family = \"gkw\", n_starts = 5L)"},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"x Numeric vector observations. values must open interval (0,1). Values outside range automatically truncated avoid numerical issues. family Character string specifying distribution family. Valid options : \"gkw\" (Generalized Kumaraswamy - 5 parameters), \"bkw\" (Beta-Kumaraswamy - 4 parameters), \"kkw\" (Kumaraswamy-Kumaraswamy - 4 parameters), \"ekw\" (Exponentiated Kumaraswamy - 3 parameters), \"mc\" (McDonald - 3 parameters), \"kw\" (Kumaraswamy - 2 parameters), \"beta\" (Beta - 2 parameters). string case-insensitive. Default \"gkw\". n_starts Integer specifying number different initial parameter values try optimization. starting points increase probability finding global optimum cost longer computation time. Default 5.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"Named numeric vector containing estimated parameters specified distribution family. Parameter names correspond distribution specification. estimation fails, returns vector NA values appropriate parameter names.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"function uses method moments estimate distribution parameters minimizing weighted sum squared relative errors theoretical sample moments (orders 1 5). optimization employs Nelder-Mead simplex algorithm, derivative-free particularly robust problem. Key implementation features: logarithmic calculations numerical stability, adaptive numerical integration using Simpson's rule fallback trapezoidal rule, multiple random starting points avoid local minima, decreasing weights higher-order moments (1.0, 0.8, 0.6, 0.4, 0.2), automatic parameter constraint enforcement. Parameter Constraints: parameters constrained positive values. Additionally, family-specific constraints enforced: alpha beta (0.1, 50.0), gamma (0.1, 10.0) GKw-related families (0.1, 50.0) Beta, delta (0.01, 10.0), lambda (0.1, 20.0). function issue warnings empty input vectors, sample sizes less 10 (unreliable estimation), failure find valid parameter estimates (returns defaults).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/gkwgetstartvalues.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Distribution Parameters Using Method of Moments ‚Äî gkwgetstartvalues","text":"","code":"# \\donttest{ # Generate sample data from Beta distribution set.seed(123) x <- rbeta(100, shape1 = 2, shape2 = 3)  # Estimate Beta parameters params_beta <- gkwgetstartvalues(x, family = \"beta\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(params_beta) #> Error: object 'params_beta' not found  # Estimate Kumaraswamy parameters params_kw <- gkwgetstartvalues(x, family = \"kw\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(params_kw) #> Error: object 'params_kw' not found  # Estimate GKw parameters with more starting points params_gkw <- gkwgetstartvalues(x, family = \"gkw\", n_starts = 10) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(params_gkw) #> Error: object 'params_gkw' not found # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"Computes gradient vector (vector first partial derivatives) negative log-likelihood function standard Beta distribution, using parameterization common generalized distribution families. distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1. gradient useful optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"","code":"grbeta(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"par numeric vector length 2 containing distribution parameters order: gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"Returns numeric vector length 2 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\gamma, -\\partial \\ell/\\partial \\delta)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"function calculates gradient negative log-likelihood Beta distribution parameters shape1 = gamma (\\(\\gamma\\)) shape2 = delta + 1 (\\(\\delta+1\\)). components gradient vector (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) : $$ -\\frac{\\partial \\ell}{\\partial \\gamma} = n[\\psi(\\gamma) - \\psi(\\gamma+\\delta+1)] - \\sum_{=1}^{n}\\ln(x_i) $$ $$ -\\frac{\\partial \\ell}{\\partial \\delta} = n[\\psi(\\delta+1) - \\psi(\\gamma+\\delta+1)] - \\sum_{=1}^{n}\\ln(1-x_i) $$ \\(\\psi(\\cdot)\\) digamma function (digamma). formulas represent derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond relevant components general GKw gradient (grgkw) evaluated \\(\\alpha=1, \\beta=1, \\lambda=1\\). Note parameterization: standard Beta shape parameters \\(\\gamma\\) \\(\\delta+1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, (Note: Specific gradient formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî grbeta","text":"","code":"# \\donttest{ ## Example 1: Basic Gradient Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(gamma = 2.0, delta = 3.0) data <- rbeta_(n, gamma = true_params[1], delta = true_params[2]) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate gradient at true parameters grad_true <- grbeta(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Gradient at true parameters:\\n\") #> Gradient at true parameters: print(grad_true) #> Error: object 'grad_true' not found cat(\"Norm:\", sqrt(sum(grad_true^2)), \"\\n\") #> Error: object 'grad_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5),   c(2.0, 3.0),   c(2.5, 3.5) )  grad_norms <- apply(test_params, 1, function(p) {   g <- grbeta(p, data)   sqrt(sum(g^2)) }) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  results <- data.frame(   Gamma = test_params[, 1],   Delta = test_params[, 2],   Grad_Norm = grad_norms ) #> Error: object 'grad_norms' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Gradient in Optimization  # Optimization with analytical gradient fit_with_grad <- optim(   par = c(1.5, 2.5),   fn = llbeta,   gr = grbeta,   data = data,   method = \"L-BFGS-B\",   lower = c(0.01, 0.01),   upper = c(100, 100),   hessian = TRUE,   control = list(trace = 0) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5), fn = llbeta, gr = grbeta, data = data,     method = \"L-BFGS-B\", lower = c(0.01, 0.01), upper = c(100,         100), hessian = TRUE, control = list(trace = 0)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization without gradient fit_no_grad <- optim(   par = c(1.5, 2.5),   fn = llbeta,   data = data,   method = \"L-BFGS-B\",   lower = c(0.01, 0.01),   upper = c(100, 100),   hessian = TRUE,   control = list(trace = 0) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(1.5, 2.5)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  comparison <- data.frame(   Method = c(\"With Gradient\", \"Without Gradient\"),   Gamma = c(fit_with_grad$par[1], fit_no_grad$par[1]),   Delta = c(fit_with_grad$par[2], fit_no_grad$par[2]),   NegLogLik = c(fit_with_grad$value, fit_no_grad$value),   Iterations = c(fit_with_grad$counts[1], fit_no_grad$counts[1]) ) #> Error: object 'fit_with_grad' not found print(comparison, digits = 4, row.names = FALSE) #> Error: object 'comparison' not found   ## Example 3: Verifying Gradient at MLE  mle <- fit_with_grad$par #> Error: object 'fit_with_grad' not found names(mle) <- c(\"gamma\", \"delta\") #> Error: object 'mle' not found  # At MLE, gradient should be approximately zero gradient_at_mle <- grbeta(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nGradient at MLE:\\n\") #>  #> Gradient at MLE: print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute component:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found cat(\"Gradient norm:\", sqrt(sum(gradient_at_mle^2)), \"\\n\") #> Error: object 'gradient_at_mle' not found   ## Example 4: Numerical vs Analytical Gradient  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare at MLE grad_analytical <- grbeta(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grad_numerical <- numerical_gradient(llbeta, mle, data) #> Error: object 'mle' not found  comparison_grad <- data.frame(   Parameter = c(\"gamma\", \"delta\"),   Analytical = grad_analytical,   Numerical = grad_numerical,   Abs_Diff = abs(grad_analytical - grad_numerical),   Rel_Error = abs(grad_analytical - grad_numerical) /               (abs(grad_analytical) + 1e-10) ) #> Error: object 'grad_analytical' not found print(comparison_grad, digits = 8) #> Error: object 'comparison_grad' not found   ## Example 5: Score Test Statistic  # Score test for H0: theta = theta0 theta0 <- c(1.8, 2.8) score_theta0 <- -grbeta(par = theta0, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fisher information at theta0 fisher_info <- hsbeta(par = theta0, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Score test statistic score_stat <- t(score_theta0) %*% solve(fisher_info) %*% score_theta0 #> Error: object 'score_theta0' not found p_value <- pchisq(score_stat, df = 2, lower.tail = FALSE) #> Error: object 'score_stat' not found  cat(\"\\nScore Test:\\n\") #>  #> Score Test: cat(\"H0: gamma=1.8, delta=2.8\\n\") #> H0: gamma=1.8, delta=2.8 cat(\"Test statistic:\", score_stat, \"\\n\") #> Error: object 'score_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 6: Confidence Ellipse (Gamma vs Delta)  # Observed information obs_info <- hsbeta(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt vcov_full <- solve(obs_info) #> Error: object 'obs_info' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_full) #> Error: object 'vcov_full' not found ellipse <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_full)) #> Error: object 'vcov_full' not found ci_gamma <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_delta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot  plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(delta),      main = \"95% Confidence Region (Gamma vs Delta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf  #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_gamma, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma' not found abline(h = ci_delta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"Computes gradient vector (vector first partial derivatives) negative log-likelihood function Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\lambda = 1\\). gradient typically used optimization algorithms maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"","code":"grbkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"par numeric vector length 4 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"Returns numeric vector length 4 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\alpha, -\\partial \\ell/\\partial \\beta, -\\partial \\ell/\\partial \\gamma, -\\partial \\ell/\\partial \\delta)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"components gradient vector negative log-likelihood (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) BKw (\\(\\lambda=1\\)) model : $$ -\\frac{\\partial \\ell}{\\partial \\alpha} = -\\frac{n}{\\alpha} - \\sum_{=1}^{n}\\ln(x_i) + \\sum_{=1}^{n}\\left[x_i^{\\alpha} \\ln(x_i) \\left(\\frac{\\beta(\\delta+1)-1}{v_i} - \\frac{(\\gamma-1) \\beta v_i^{\\beta-1}}{w_i}\\right)\\right] $$ $$ -\\frac{\\partial \\ell}{\\partial \\beta} = -\\frac{n}{\\beta} - (\\delta+1)\\sum_{=1}^{n}\\ln(v_i) + \\sum_{=1}^{n}\\left[\\frac{(\\gamma-1) v_i^{\\beta} \\ln(v_i)}{w_i}\\right] $$ $$ -\\frac{\\partial \\ell}{\\partial \\gamma} = n[\\psi(\\gamma) - \\psi(\\gamma+\\delta+1)] - \\sum_{=1}^{n}\\ln(w_i) $$ $$ -\\frac{\\partial \\ell}{\\partial \\delta} = n[\\psi(\\delta+1) - \\psi(\\gamma+\\delta+1)] - \\beta\\sum_{=1}^{n}\\ln(v_i) $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(\\psi(\\cdot)\\) digamma function (digamma). formulas represent derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond general GKw gradient (grgkw) components \\(\\alpha, \\beta, \\gamma, \\delta\\) evaluated \\(\\lambda=1\\). Note component \\(\\lambda\\) omitted. Numerical stability maintained careful implementation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. (Note: Specific gradient formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the BKw Distribution ‚Äî grbkw","text":"","code":"# \\donttest{ ## Example 1: Basic Gradient Evaluation # Generate sample data set.seed(2203) n <- 1000 true_params <- c(alpha = 2.0, beta = 1.5, gamma = 1.5, delta = 0.5) data <- rbkw(n, alpha = true_params[1], beta = true_params[2],              gamma = true_params[3], delta = true_params[4]) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate gradient at true parameters grad_true <- grbkw(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Gradient at true parameters:\\n\") #> Gradient at true parameters: print(grad_true) #> Error: object 'grad_true' not found cat(\"Norm:\", sqrt(sum(grad_true^2)), \"\\n\") #> Error: object 'grad_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 1.0, 1.0, 0.3),   c(2.0, 1.5, 1.5, 0.5),   c(2.5, 2.0, 2.0, 0.7) )  grad_norms <- apply(test_params, 1, function(p) {   g <- grbkw(p, data)   sqrt(sum(g^2)) }) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Gamma = test_params[, 3],   Delta = test_params[, 4],   Grad_Norm = grad_norms ) #> Error: object 'grad_norms' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Gradient in Optimization  # Optimization with analytical gradient fit_with_grad <- optim(   par = c(1.8, 1.2, 1.1, 0.3),   fn = llbkw,   gr = grbkw,   data = data,   method = \"Nelder-Mead\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.8, 1.2, 1.1, 0.3), fn = llbkw, gr = grbkw, data = data,     method = \"Nelder-Mead\", hessian = TRUE, control = list(trace = 0)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization without gradient fit_no_grad <- optim(   par = c(1.8, 1.2, 1.1, 0.3),   fn = llbkw,   data = data,   method = \"Nelder-Mead\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(1.8, 1.2, 1.1, 0.3)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  comparison <- data.frame(   Method = c(\"With Gradient\", \"Without Gradient\"),   Alpha = c(fit_with_grad$par[1], fit_no_grad$par[1]),   Beta = c(fit_with_grad$par[2], fit_no_grad$par[2]),   Gamma = c(fit_with_grad$par[3], fit_no_grad$par[3]),   Delta = c(fit_with_grad$par[4], fit_no_grad$par[4]),   NegLogLik = c(fit_with_grad$value, fit_no_grad$value),   Iterations = c(fit_with_grad$counts[1], fit_no_grad$counts[1]) ) #> Error: object 'fit_with_grad' not found print(comparison, digits = 4, row.names = FALSE) #> Error: object 'comparison' not found   ## Example 3: Verifying Gradient at MLE  mle <- fit_with_grad$par #> Error: object 'fit_with_grad' not found names(mle) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\") #> Error: object 'mle' not found  # At MLE, gradient should be approximately zero gradient_at_mle <- grbkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nGradient at MLE:\\n\") #>  #> Gradient at MLE: print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute component:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found cat(\"Gradient norm:\", sqrt(sum(gradient_at_mle^2)), \"\\n\") #> Error: object 'gradient_at_mle' not found   ## Example 4: Numerical vs Analytical Gradient  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare at MLE grad_analytical <- grbkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grad_numerical <- numerical_gradient(llbkw, mle, data) #> Error: object 'mle' not found  comparison_grad <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"gamma\", \"delta\"),   Analytical = grad_analytical,   Numerical = grad_numerical,   Abs_Diff = abs(grad_analytical - grad_numerical),   Rel_Error = abs(grad_analytical - grad_numerical) /               (abs(grad_analytical) + 1e-10) ) #> Error: object 'grad_analytical' not found print(comparison_grad, digits = 8) #> Error: object 'comparison_grad' not found   ## Example 5: Score Test Statistic  # Score test for H0: theta = theta0 theta0 <- c(1.8, 1.3, 1.2, 0.4) score_theta0 <- -grbkw(par = theta0, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fisher information at theta0 fisher_info <- hsbkw(par = theta0, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Score test statistic score_stat <- t(score_theta0) %*% solve(fisher_info) %*% score_theta0 #> Error: object 'score_theta0' not found p_value <- pchisq(score_stat, df = 4, lower.tail = FALSE) #> Error: object 'score_stat' not found  cat(\"\\nScore Test:\\n\") #>  #> Score Test: cat(\"H0: alpha=1.8, beta=1.3, gamma=1.2, delta=0.4\\n\") #> H0: alpha=1.8, beta=1.3, gamma=1.2, delta=0.4 cat(\"Test statistic:\", score_stat, \"\\n\") #> Error: object 'score_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 6: Confidence Ellipses (Selected pairs)  # Observed information obs_info <- hsbkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt vcov_full <- solve(obs_info) #> Error: object 'obs_info' not found  # Create confidence ellipses theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  # Alpha vs Beta ellipse vcov_ab <- vcov_full[1:2, 1:2] #> Error: object 'vcov_full' not found eig_decomp_ab <- eigen(vcov_ab) #> Error: object 'vcov_ab' not found ellipse_ab <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_ab[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp_ab$vectors %*% diag(sqrt(eig_decomp_ab$values)) %*% v) } #> Error: object 'mle' not found  # Alpha vs Gamma ellipse vcov_ag <- vcov_full[c(1, 3), c(1, 3)] #> Error: object 'vcov_full' not found eig_decomp_ag <- eigen(vcov_ag) #> Error: object 'vcov_ag' not found ellipse_ag <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_ag[i, ] <- mle[c(1, 3)] + sqrt(chi2_val) *     (eig_decomp_ag$vectors %*% diag(sqrt(eig_decomp_ag$values)) %*% v) } #> Error: object 'mle' not found  # Beta vs Delta ellipse vcov_bd <- vcov_full[c(2, 4), c(2, 4)] #> Error: object 'vcov_full' not found eig_decomp_bd <- eigen(vcov_bd) #> Error: object 'vcov_bd' not found ellipse_bd <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_bd[i, ] <- mle[c(2, 4)] + sqrt(chi2_val) *     (eig_decomp_bd$vectors %*% diag(sqrt(eig_decomp_bd$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_ab <- sqrt(diag(vcov_ab)) #> Error: object 'vcov_ab' not found ci_alpha_ab <- mle[1] + c(-1, 1) * 1.96 * se_ab[1] #> Error: object 'mle' not found ci_beta_ab <- mle[2] + c(-1, 1) * 1.96 * se_ab[2] #> Error: object 'mle' not found  se_ag <- sqrt(diag(vcov_ag)) #> Error: object 'vcov_ag' not found ci_alpha_ag <- mle[1] + c(-1, 1) * 1.96 * se_ag[1] #> Error: object 'mle' not found ci_gamma_ag <- mle[3] + c(-1, 1) * 1.96 * se_ag[2] #> Error: object 'mle' not found  se_bd <- sqrt(diag(vcov_bd)) #> Error: object 'vcov_bd' not found ci_beta_bd <- mle[2] + c(-1, 1) * 1.96 * se_bd[1] #> Error: object 'mle' not found ci_delta_bd <- mle[4] + c(-1, 1) * 1.96 * se_bd[2] #> Error: object 'mle' not found  # Plot selected ellipses  # Alpha vs Beta plot(ellipse_ab[, 1], ellipse_ab[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"Alpha vs Beta\", las = 1, xlim = range(ellipse_ab[, 1], ci_alpha_ab),      ylim = range(ellipse_ab[, 2], ci_beta_ab)) #> Error: object 'ci_alpha_ab' not found abline(v = ci_alpha_ab, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha_ab' not found abline(h = ci_beta_ab, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta_ab' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Alpha vs Gamma plot(ellipse_ag[, 1], ellipse_ag[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(gamma),      main = \"Alpha vs Gamma\", las = 1, xlim = range(ellipse_ag[, 1], ci_alpha_ag),      ylim = range(ellipse_ag[, 2], ci_gamma_ag)) #> Error: object 'ci_alpha_ag' not found abline(v = ci_alpha_ag, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha_ag' not found abline(h = ci_gamma_ag, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma_ag' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Beta vs Delta plot(ellipse_bd[, 1], ellipse_bd[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = expression(delta),      main = \"Beta vs Delta\", las = 1, xlim = range(ellipse_bd[, 1], ci_beta_bd),      ylim = range(ellipse_bd[, 2], ci_delta_bd)) #> Error: object 'ci_beta_bd' not found abline(v = ci_beta_bd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta_bd' not found abline(h = ci_delta_bd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_bd' not found points(mle[2], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"Computes gradient vector (vector first partial derivatives) negative log-likelihood function Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\) \\(\\delta = 0\\). gradient useful optimization.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"","code":"grekw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"par numeric vector length 3 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"Returns numeric vector length 3 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\alpha, -\\partial \\ell/\\partial \\beta, -\\partial \\ell/\\partial \\lambda)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"components gradient vector negative log-likelihood (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) EKw (\\(\\gamma=1, \\delta=0\\)) model : $$ -\\frac{\\partial \\ell}{\\partial \\alpha} = -\\frac{n}{\\alpha} - \\sum_{=1}^{n}\\ln(x_i) + \\sum_{=1}^{n}\\left[x_i^{\\alpha} \\ln(x_i) \\left(\\frac{\\beta-1}{v_i} - \\frac{(\\lambda-1) \\beta v_i^{\\beta-1}}{w_i}\\right)\\right] $$ $$ -\\frac{\\partial \\ell}{\\partial \\beta} = -\\frac{n}{\\beta} - \\sum_{=1}^{n}\\ln(v_i) + \\sum_{=1}^{n}\\left[\\frac{(\\lambda-1) v_i^{\\beta} \\ln(v_i)}{w_i}\\right] $$ $$ -\\frac{\\partial \\ell}{\\partial \\lambda} = -\\frac{n}{\\lambda} - \\sum_{=1}^{n}\\ln(w_i) $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) formulas represent derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond relevant components general GKw gradient (grgkw) evaluated \\(\\gamma=1, \\delta=0\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. (Note: Specific gradient formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the EKw Distribution ‚Äî grekw","text":"","code":"# \\donttest{ ## Example 1: Basic Gradient Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5, lambda = 2.0) data <- rekw(n, alpha = true_params[1], beta = true_params[2],              lambda = true_params[3]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate gradient at true parameters grad_true <- grekw(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Gradient at true parameters:\\n\") #> Gradient at true parameters: print(grad_true) #> Error: object 'grad_true' not found cat(\"Norm:\", sqrt(sum(grad_true^2)), \"\\n\") #> Error: object 'grad_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(2.0, 3.0, 1.5),   c(2.5, 3.5, 2.0),   c(3.0, 4.0, 2.5) )  grad_norms <- apply(test_params, 1, function(p) {   g <- grekw(p, data)   sqrt(sum(g^2)) }) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Lambda = test_params[, 3],   Grad_Norm = grad_norms ) #> Error: object 'grad_norms' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Gradient in Optimization  # Optimization with analytical gradient fit_with_grad <- optim(   par = c(2, 3, 1.5),   fn = llekw,   gr = grekw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(2, 3, 1.5), fn = llekw, gr = grekw, data = data,     method = \"BFGS\", hessian = TRUE, control = list(trace = 0)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization without gradient fit_no_grad <- optim(   par = c(2, 3, 1.5),   fn = llekw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(2, 3, 1.5)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  comparison <- data.frame(   Method = c(\"With Gradient\", \"Without Gradient\"),   Alpha = c(fit_with_grad$par[1], fit_no_grad$par[1]),   Beta = c(fit_with_grad$par[2], fit_no_grad$par[2]),   Lambda = c(fit_with_grad$par[3], fit_no_grad$par[3]),   NegLogLik = c(fit_with_grad$value, fit_no_grad$value),   Iterations = c(fit_with_grad$counts[1], fit_no_grad$counts[1]) ) #> Error: object 'fit_with_grad' not found print(comparison, digits = 4, row.names = FALSE) #> Error: object 'comparison' not found   ## Example 3: Verifying Gradient at MLE  mle <- fit_with_grad$par #> Error: object 'fit_with_grad' not found names(mle) <- c(\"alpha\", \"beta\", \"lambda\") #> Error: object 'mle' not found  # At MLE, gradient should be approximately zero gradient_at_mle <- grekw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nGradient at MLE:\\n\") #>  #> Gradient at MLE: print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute component:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found cat(\"Gradient norm:\", sqrt(sum(gradient_at_mle^2)), \"\\n\") #> Error: object 'gradient_at_mle' not found   ## Example 4: Numerical vs Analytical Gradient  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare at MLE grad_analytical <- grekw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grad_numerical <- numerical_gradient(llekw, mle, data) #> Error: object 'mle' not found  comparison_grad <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"lambda\"),   Analytical = grad_analytical,   Numerical = grad_numerical,   Abs_Diff = abs(grad_analytical - grad_numerical),   Rel_Error = abs(grad_analytical - grad_numerical) /               (abs(grad_analytical) + 1e-10) ) #> Error: object 'grad_analytical' not found print(comparison_grad, digits = 8) #> Error: object 'comparison_grad' not found   ## Example 5: Score Test Statistic  # Score test for H0: theta = theta0 theta0 <- c(2.2, 3.2, 1.8) score_theta0 <- -grekw(par = theta0, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fisher information at theta0 fisher_info <- hsekw(par = theta0, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Score test statistic score_stat <- t(score_theta0) %*% solve(fisher_info) %*% score_theta0 #> Error: object 'score_theta0' not found p_value <- pchisq(score_stat, df = 3, lower.tail = FALSE) #> Error: object 'score_stat' not found  cat(\"\\nScore Test:\\n\") #>  #> Score Test: cat(\"H0: alpha=2.2, beta=3.2, lambda=1.8\\n\") #> H0: alpha=2.2, beta=3.2, lambda=1.8 cat(\"Test statistic:\", score_stat, \"\\n\") #> Error: object 'score_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 6: Confidence Ellipse (Alpha vs Beta)  # Observed information obs_info <- hsekw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt vcov_full <- solve(obs_info) #> Error: object 'obs_info' not found vcov_2d <- vcov_full[1:2, 1:2] #> Error: object 'vcov_full' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_alpha <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_beta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot  plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Region (Alpha vs Beta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf  #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha' not found abline(h = ci_beta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 7: Confidence Ellipse (Alpha vs Lambda)  # Extract 2x2 submatrix for alpha and lambda vcov_2d_al <- vcov_full[c(1, 3), c(1, 3)] #> Error: object 'vcov_full' not found  # Create confidence ellipse eig_decomp_al <- eigen(vcov_2d_al) #> Error: object 'vcov_2d_al' not found ellipse_al <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_al[i, ] <- mle[c(1, 3)] + sqrt(chi2_val) *     (eig_decomp_al$vectors %*% diag(sqrt(eig_decomp_al$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_al <- sqrt(diag(vcov_2d_al)) #> Error: object 'vcov_2d_al' not found ci_alpha_2 <- mle[1] + c(-1, 1) * 1.96 * se_2d_al[1] #> Error: object 'mle' not found ci_lambda <- mle[3] + c(-1, 1) * 1.96 * se_2d_al[2] #> Error: object 'mle' not found  # Plot  plot(ellipse_al[, 1], ellipse_al[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(lambda),      main = \"95% Confidence Region (Alpha vs Lambda)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha_2' not found abline(h = ci_lambda, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda' not found  points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 8: Confidence Ellipse (Beta vs Lambda)  # Extract 2x2 submatrix for beta and lambda vcov_2d_bl <- vcov_full[2:3, 2:3] #> Error: object 'vcov_full' not found  # Create confidence ellipse eig_decomp_bl <- eigen(vcov_2d_bl) #> Error: object 'vcov_2d_bl' not found ellipse_bl <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_bl[i, ] <- mle[2:3] + sqrt(chi2_val) *     (eig_decomp_bl$vectors %*% diag(sqrt(eig_decomp_bl$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_bl <- sqrt(diag(vcov_2d_bl)) #> Error: object 'vcov_2d_bl' not found ci_beta_2 <- mle[2] + c(-1, 1) * 1.96 * se_2d_bl[1] #> Error: object 'mle' not found ci_lambda_2 <- mle[3] + c(-1, 1) * 1.96 * se_2d_bl[2] #> Error: object 'mle' not found  # Plot  plot(ellipse_bl[, 1], ellipse_bl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = expression(lambda),      main = \"95% Confidence Region (Beta vs Lambda)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_beta_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta_2' not found abline(h = ci_lambda_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda_2' not found  points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"Computes gradient vector (vector partial derivatives) negative log-likelihood function five-parameter Generalized Kumaraswamy (GKw) distribution. provides analytical gradient, often used efficient optimization via maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"","code":"grgkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"par numeric vector length 5 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"Returns numeric vector length 5 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\alpha, -\\partial \\ell/\\partial \\beta, -\\partial \\ell/\\partial \\gamma, -\\partial \\ell/\\partial \\delta, -\\partial \\ell/\\partial \\lambda)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"components gradient vector negative log-likelihood (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) : $$ -\\frac{\\partial \\ell}{\\partial \\alpha} = -\\frac{n}{\\alpha} - \\sum_{=1}^{n}\\ln(x_i) + \\sum_{=1}^{n}\\left[x_i^{\\alpha} \\ln(x_i) \\left(\\frac{\\beta-1}{v_i} - \\frac{(\\gamma\\lambda-1) \\beta v_i^{\\beta-1}}{w_i} + \\frac{\\delta \\lambda \\beta v_i^{\\beta-1} w_i^{\\lambda-1}}{z_i}\\right)\\right] $$ $$ -\\frac{\\partial \\ell}{\\partial \\beta} = -\\frac{n}{\\beta} - \\sum_{=1}^{n}\\ln(v_i) + \\sum_{=1}^{n}\\left[v_i^{\\beta} \\ln(v_i) \\left(\\frac{\\gamma\\lambda-1}{w_i} - \\frac{\\delta \\lambda w_i^{\\lambda-1}}{z_i}\\right)\\right] $$ $$ -\\frac{\\partial \\ell}{\\partial \\gamma} = n[\\psi(\\gamma) - \\psi(\\gamma+\\delta+1)] - \\lambda\\sum_{=1}^{n}\\ln(w_i) $$ $$ -\\frac{\\partial \\ell}{\\partial \\delta} = n[\\psi(\\delta+1) - \\psi(\\gamma+\\delta+1)] - \\sum_{=1}^{n}\\ln(z_i) $$ $$ -\\frac{\\partial \\ell}{\\partial \\lambda} = -\\frac{n}{\\lambda} - \\gamma\\sum_{=1}^{n}\\ln(w_i) + \\delta\\sum_{=1}^{n}\\frac{w_i^{\\lambda}\\ln(w_i)}{z_i} $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(z_i = 1 - w_i^{\\lambda} = 1 - [1-(1-x_i^{\\alpha})^{\\beta}]^{\\lambda}\\) \\(\\psi(\\cdot)\\) digamma function (digamma). Numerical stability ensured careful implementation, including checks valid inputs handling intermediate calculations involving potentially small large numbers, often leveraging Armadillo C++ library efficiency.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the GKw Distribution ‚Äî grgkw","text":"","code":"# \\donttest{ ## Example 1: Basic Gradient Evaluation   # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.0, beta = 3.0, gamma = 1.5, delta = 2.0, lambda = 1.8) data <- rgkw(n, alpha = true_params[1], beta = true_params[2],              gamma = true_params[3], delta = true_params[4],              lambda = true_params[5]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate gradient at true parameters grad_true <- grgkw(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Gradient at true parameters:\\n\") #> Gradient at true parameters: print(grad_true) #> Error: object 'grad_true' not found cat(\"Norm:\", sqrt(sum(grad_true^2)), \"\\n\") #> Error: object 'grad_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5, 1.2, 1.5, 1.5),   c(2.0, 3.0, 1.5, 2.0, 1.8),   c(2.5, 3.5, 1.8, 2.5, 2.0) )  grad_norms <- apply(test_params, 1, function(p) {   g <- grgkw(p, data)   sqrt(sum(g^2)) }) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Gamma = test_params[, 3],   Delta = test_params[, 4],   Lambda = test_params[, 5],   Grad_Norm = grad_norms ) #> Error: object 'grad_norms' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Gradient in Optimization  # Optimization with analytical gradient fit_with_grad <- optim(   par = c(1.5, 2.5, 1.2, 1.5, 1.5),   fn = llgkw,   gr = grgkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0, maxit = 1000) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5, 1.2, 1.5, 1.5), fn = llgkw, gr = grgkw,     data = data, method = \"BFGS\", hessian = TRUE, control = list(trace = 0,         maxit = 1000)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization without gradient fit_no_grad <- optim(   par = c(1.5, 2.5, 1.2, 1.5, 1.5),   fn = llgkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0, maxit = 1000) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(1.5, 2.5, 1.2, 1.5, 1.5)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  comparison <- data.frame(   Method = c(\"With Gradient\", \"Without Gradient\"),   Alpha = c(fit_with_grad$par[1], fit_no_grad$par[1]),   Beta = c(fit_with_grad$par[2], fit_no_grad$par[2]),   Gamma = c(fit_with_grad$par[3], fit_no_grad$par[3]),   Delta = c(fit_with_grad$par[4], fit_no_grad$par[4]),   Lambda = c(fit_with_grad$par[5], fit_no_grad$par[5]),   NegLogLik = c(fit_with_grad$value, fit_no_grad$value),   Iterations = c(fit_with_grad$counts[1], fit_no_grad$counts[1]) ) #> Error: object 'fit_with_grad' not found print(comparison, digits = 4, row.names = FALSE) #> Error: object 'comparison' not found   ## Example 3: Verifying Gradient at MLE  mle <- fit_with_grad$par #> Error: object 'fit_with_grad' not found names(mle) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\") #> Error: object 'mle' not found  # At MLE, gradient should be approximately zero gradient_at_mle <- grgkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nGradient at MLE:\\n\") #>  #> Gradient at MLE: print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute component:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found cat(\"Gradient norm:\", sqrt(sum(gradient_at_mle^2)), \"\\n\") #> Error: object 'gradient_at_mle' not found   ## Example 4: Numerical vs Analytical Gradient  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare at MLE grad_analytical <- grgkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grad_numerical <- numerical_gradient(llgkw, mle, data) #> Error: object 'mle' not found  comparison_grad <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\"),   Analytical = grad_analytical,   Numerical = grad_numerical,   Abs_Diff = abs(grad_analytical - grad_numerical),   Rel_Error = abs(grad_analytical - grad_numerical) /               (abs(grad_analytical) + 1e-10) ) #> Error: object 'grad_analytical' not found print(comparison_grad, digits = 8) #> Error: object 'comparison_grad' not found   ## Example 5: Score Test Statistic  # Score test for H0: theta = theta0 theta0 <- c(1.8, 2.8, 1.3, 1.8, 1.6) score_theta0 <- grgkw(par = theta0, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fisher information at theta0 fisher_info <- hsgkw(par = theta0, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Score test statistic score_stat <- t(score_theta0) %*% solve(fisher_info) %*% score_theta0 #> Error: object 'score_theta0' not found p_value <- pchisq(score_stat, df = 5, lower.tail = FALSE) #> Error: object 'score_stat' not found  cat(\"\\nScore Test:\\n\") #>  #> Score Test: cat(\"H0: alpha=1.8, beta=2.8, gamma=1.3, delta=1.8, lambda=1.6\\n\") #> H0: alpha=1.8, beta=2.8, gamma=1.3, delta=1.8, lambda=1.6 cat(\"Test statistic:\", score_stat, \"\\n\") #> Error: object 'score_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 6: Confidence Ellipse (Alpha vs Beta)  # Observed information obs_info <- hsgkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt vcov_full <- solve(obs_info) #> Error: object 'obs_info' not found vcov_2d <- vcov_full[1:2, 1:2] #> Error: object 'vcov_full' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = round(n/4)) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = round(n/4), ncol = 2) for (i in 1:round(n/4)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_alpha <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_beta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Region (Alpha vs Beta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf  #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha' not found abline(h = ci_beta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 7: Confidence Ellipse (Gamma vs Delta)  # Extract 2x2 submatrix for gamma and delta vcov_2d_gd <- vcov_full[3:4, 3:4] #> Error: object 'vcov_full' not found  # Create confidence ellipse eig_decomp_gd <- eigen(vcov_2d_gd) #> Error: object 'vcov_2d_gd' not found ellipse_gd <- matrix(NA, nrow = round(n/4), ncol = 2) for (i in 1:round(n/4)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_gd[i, ] <- mle[3:4] + sqrt(chi2_val) *     (eig_decomp_gd$vectors %*% diag(sqrt(eig_decomp_gd$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_gd <- sqrt(diag(vcov_2d_gd)) #> Error: object 'vcov_2d_gd' not found ci_gamma <- mle[3] + c(-1, 1) * 1.96 * se_2d_gd[1] #> Error: object 'mle' not found ci_delta <- mle[4] + c(-1, 1) * 1.96 * se_2d_gd[2] #> Error: object 'mle' not found  # Plot plot(ellipse_gd[, 1], ellipse_gd[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(delta),      main = \"95% Confidence Region (Gamma vs Delta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_gamma, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma' not found abline(h = ci_delta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta' not found  points(mle[3], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[3], true_params[4], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"Computes gradient vector (vector first partial derivatives) negative log-likelihood function Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\). gradient typically used optimization algorithms maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"","code":"grkkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"par numeric vector length 4 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"Returns numeric vector length 4 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\alpha, -\\partial \\ell/\\partial \\beta, -\\partial \\ell/\\partial \\delta, -\\partial \\ell/\\partial \\lambda)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"components gradient vector negative log-likelihood (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) kkw (\\(\\gamma=1\\)) model : $$ -\\frac{\\partial \\ell}{\\partial \\alpha} = -\\frac{n}{\\alpha} - \\sum_{=1}^{n}\\ln(x_i) + (\\beta-1)\\sum_{=1}^{n}\\frac{x_i^{\\alpha}\\ln(x_i)}{v_i} - (\\lambda-1)\\sum_{=1}^{n}\\frac{\\beta v_i^{\\beta-1} x_i^{\\alpha}\\ln(x_i)}{w_i} + \\delta\\sum_{=1}^{n}\\frac{\\lambda w_i^{\\lambda-1} \\beta v_i^{\\beta-1} x_i^{\\alpha}\\ln(x_i)}{z_i} $$ $$ -\\frac{\\partial \\ell}{\\partial \\beta} = -\\frac{n}{\\beta} - \\sum_{=1}^{n}\\ln(v_i) + (\\lambda-1)\\sum_{=1}^{n}\\frac{v_i^{\\beta}\\ln(v_i)}{w_i} - \\delta\\sum_{=1}^{n}\\frac{\\lambda w_i^{\\lambda-1} v_i^{\\beta}\\ln(v_i)}{z_i} $$ $$ -\\frac{\\partial \\ell}{\\partial \\delta} = -\\frac{n}{\\delta+1} - \\sum_{=1}^{n}\\ln(z_i) $$ $$ -\\frac{\\partial \\ell}{\\partial \\lambda} = -\\frac{n}{\\lambda} - \\sum_{=1}^{n}\\ln(w_i) + \\delta\\sum_{=1}^{n}\\frac{w_i^{\\lambda}\\ln(w_i)}{z_i} $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(z_i = 1 - w_i^{\\lambda} = 1 - [1-(1-x_i^{\\alpha})^{\\beta}]^{\\lambda}\\) formulas represent derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond general GKw gradient (grgkw) components \\(\\alpha, \\beta, \\delta, \\lambda\\) evaluated \\(\\gamma=1\\). Note component \\(\\gamma\\) omitted. Numerical stability maintained careful implementation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the kkw Distribution ‚Äî grkkw","text":"","code":"# \\donttest{ ## Example 1: Basic Gradient Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.0, beta = 3.0, delta = 1.5, lambda = 2.0) data <- rkkw(n, alpha = true_params[1], beta = true_params[2],              delta = true_params[3], lambda = true_params[4]) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate gradient at true parameters grad_true <- grkkw(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Gradient at true parameters:\\n\") #> Gradient at true parameters: print(grad_true) #> Error: object 'grad_true' not found cat(\"Norm:\", sqrt(sum(grad_true^2)), \"\\n\") #> Error: object 'grad_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5, 1.0, 1.5),   c(2.0, 3.0, 1.5, 2.0),   c(2.5, 3.5, 2.0, 2.5) )  grad_norms <- apply(test_params, 1, function(p) {   g <- grkkw(p, data)   sqrt(sum(g^2)) }) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Delta = test_params[, 3],   Lambda = test_params[, 4],   Grad_Norm = grad_norms ) #> Error: object 'grad_norms' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Gradient in Optimization  # Optimization with analytical gradient fit_with_grad <- optim(   par = c(1.5, 2.5, 1.0, 1.5),   fn = llkkw,   gr = grkkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5, 1, 1.5), fn = llkkw, gr = grkkw, data = data,     method = \"BFGS\", hessian = TRUE, control = list(trace = 0)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization without gradient fit_no_grad <- optim(   par = c(1.5, 2.5, 1.0, 1.5),   fn = llkkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(1.5, 2.5, 1, 1.5)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  comparison <- data.frame(   Method = c(\"With Gradient\", \"Without Gradient\"),   Alpha = c(fit_with_grad$par[1], fit_no_grad$par[1]),   Beta = c(fit_with_grad$par[2], fit_no_grad$par[2]),   Delta = c(fit_with_grad$par[3], fit_no_grad$par[3]),   Lambda = c(fit_with_grad$par[4], fit_no_grad$par[4]),   NegLogLik = c(fit_with_grad$value, fit_no_grad$value),   Iterations = c(fit_with_grad$counts[1], fit_no_grad$counts[1]) ) #> Error: object 'fit_with_grad' not found print(comparison, digits = 4, row.names = FALSE) #> Error: object 'comparison' not found   ## Example 3: Verifying Gradient at MLE  mle <- fit_with_grad$par #> Error: object 'fit_with_grad' not found names(mle) <- c(\"alpha\", \"beta\", \"delta\", \"lambda\") #> Error: object 'mle' not found  # At MLE, gradient should be approximately zero gradient_at_mle <- grkkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nGradient at MLE:\\n\") #>  #> Gradient at MLE: print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute component:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found cat(\"Gradient norm:\", sqrt(sum(gradient_at_mle^2)), \"\\n\") #> Error: object 'gradient_at_mle' not found   ## Example 4: Numerical vs Analytical Gradient  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare at MLE grad_analytical <- grkkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grad_numerical <- numerical_gradient(llkkw, mle, data) #> Error: object 'mle' not found  comparison_grad <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"delta\", \"lambda\"),   Analytical = grad_analytical,   Numerical = grad_numerical,   Abs_Diff = abs(grad_analytical - grad_numerical),   Rel_Error = abs(grad_analytical - grad_numerical) /               (abs(grad_analytical) + 1e-10) ) #> Error: object 'grad_analytical' not found print(comparison_grad, digits = 8) #> Error: object 'comparison_grad' not found   ## Example 5: Score Test Statistic  # Score test for H0: theta = theta0 theta0 <- c(1.8, 2.8, 1.3, 1.8) score_theta0 <- -grkkw(par = theta0, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fisher information at theta0 fisher_info <- hskkw(par = theta0, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Score test statistic score_stat <- t(score_theta0) %*% solve(fisher_info) %*% score_theta0 #> Error: object 'score_theta0' not found p_value <- pchisq(score_stat, df = 4, lower.tail = FALSE) #> Error: object 'score_stat' not found  cat(\"\\nScore Test:\\n\") #>  #> Score Test: cat(\"H0: alpha=1.8, beta=2.8, delta=1.3, lambda=1.8\\n\") #> H0: alpha=1.8, beta=2.8, delta=1.3, lambda=1.8 cat(\"Test statistic:\", score_stat, \"\\n\") #> Error: object 'score_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 6: Confidence Ellipse with Gradient Information  # For visualization, use first two parameters (alpha, beta) # Observed information obs_info <- hskkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt vcov_full <- solve(obs_info) #> Error: object 'obs_info' not found vcov_2d <- vcov_full[1:2, 1:2] #> Error: object 'vcov_full' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_alpha <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_beta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Region (Alpha vs Beta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf  #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha' not found abline(h = ci_beta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\") # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"Computes gradient vector (vector first partial derivatives) negative log-likelihood function two-parameter Kumaraswamy (Kw) distribution parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)). provides analytical gradient often used efficient optimization via maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"","code":"grkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"par numeric vector length 2 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"Returns numeric vector length 2 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\alpha, -\\partial \\ell/\\partial \\beta)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"components gradient vector negative log-likelihood (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) Kw model : $$ -\\frac{\\partial \\ell}{\\partial \\alpha} = -\\frac{n}{\\alpha} - \\sum_{=1}^{n}\\ln(x_i) + (\\beta-1)\\sum_{=1}^{n}\\frac{x_i^{\\alpha}\\ln(x_i)}{v_i} $$ $$ -\\frac{\\partial \\ell}{\\partial \\beta} = -\\frac{n}{\\beta} - \\sum_{=1}^{n}\\ln(v_i) $$ \\(v_i = 1 - x_i^{\\alpha}\\). formulas represent derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond relevant components general GKw gradient (grgkw) evaluated \\(\\gamma=1, \\delta=0, \\lambda=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81. (Note: Specific gradient formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the Kumaraswamy (Kw) Distribution ‚Äî grkw","text":"","code":"# \\donttest{ ## Example 1: Basic Gradient Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5) data <- rkw(n, alpha = true_params[1], beta = true_params[2]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate gradient at true parameters grad_true <- grkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Gradient at true parameters:\\n\") #> Gradient at true parameters: print(grad_true) #> Error: object 'grad_true' not found cat(\"Norm:\", sqrt(sum(grad_true^2)), \"\\n\") #> Error: object 'grad_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5),   c(2.0, 3.0),   c(2.5, 3.5),   c(3.0, 4.0) )  grad_norms <- apply(test_params, 1, function(p) {   g <- grkw(p, data)   sqrt(sum(g^2)) }) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Grad_Norm = grad_norms ) #> Error: object 'grad_norms' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Gradient in Optimization  # Optimization with analytical gradient fit_with_grad <- optim(   par = c(2, 2),   fn = llkw,   gr = grkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(2, 2), fn = llkw, gr = grkw, data = data, method = \"BFGS\",     hessian = TRUE, control = list(trace = 0)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization without gradient fit_no_grad <- optim(   par = c(2, 2),   fn = llkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(trace = 0) ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(2, 2)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  comparison <- data.frame(   Method = c(\"With Gradient\", \"Without Gradient\"),   Alpha = c(fit_with_grad$par[1], fit_no_grad$par[1]),   Beta = c(fit_with_grad$par[2], fit_no_grad$par[2]),   NegLogLik = c(fit_with_grad$value, fit_no_grad$value),   Iterations = c(fit_with_grad$counts[1], fit_no_grad$counts[1]) ) #> Error: object 'fit_with_grad' not found print(comparison, digits = 4, row.names = FALSE) #> Error: object 'comparison' not found   ## Example 3: Verifying Gradient at MLE  mle <- fit_with_grad$par #> Error: object 'fit_with_grad' not found names(mle) <- c(\"alpha\", \"beta\") #> Error: object 'mle' not found  # At MLE, gradient should be approximately zero gradient_at_mle <- grkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nGradient at MLE:\\n\") #>  #> Gradient at MLE: print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute component:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found cat(\"Gradient norm:\", sqrt(sum(gradient_at_mle^2)), \"\\n\") #> Error: object 'gradient_at_mle' not found   ## Example 4: Numerical vs Analytical Gradient  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare at several points test_points <- rbind(   c(1.5, 2.5),   c(2.0, 3.0),   mle,   c(3.0, 4.0) ) #> Error: object 'mle' not found  cat(\"\\nNumerical vs Analytical Gradient Comparison:\\n\") #>  #> Numerical vs Analytical Gradient Comparison: for (i in 1:nrow(test_points)) {   grad_analytical <- grkw(par = test_points[i, ], data = data)   grad_numerical <- numerical_gradient(llkw, test_points[i, ], data)      cat(\"\\nPoint\", i, \": alpha =\", test_points[i, 1],        \", beta =\", test_points[i, 2], \"\\n\")      comparison <- data.frame(     Parameter = c(\"alpha\", \"beta\"),     Analytical = grad_analytical,     Numerical = grad_numerical,     Abs_Diff = abs(grad_analytical - grad_numerical),     Rel_Error = abs(grad_analytical - grad_numerical) /                  (abs(grad_analytical) + 1e-10)   )   print(comparison, digits = 8) } #> Error: object 'test_points' not found   ## Example 5: Gradient Path Visualization  # Create grid alpha_grid <- seq(mle[1] - 1, mle[1] + 1, length.out = 20) #> Error: object 'mle' not found beta_grid <- seq(mle[2] - 1, mle[2] + 1, length.out = 20) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found  # Compute gradient vectors grad_alpha <- matrix(NA, nrow = length(alpha_grid), ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found grad_beta <- matrix(NA, nrow = length(alpha_grid), ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   for (j in seq_along(beta_grid)) {     g <- grkw(c(alpha_grid[i], beta_grid[j]), data)     grad_alpha[i, j] <- -g[1]  # Negative for gradient ascent     grad_beta[i, j] <- -g[2]   } } #> Error: object 'alpha_grid' not found  # Plot gradient field  plot(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5,      xlim = range(alpha_grid), ylim = range(beta_grid),      xlab = expression(alpha), ylab = expression(beta),      main = \"Gradient Vector Field\", las = 1) #> Error: object 'mle' not found  # Subsample for clearer visualization step <- 2 for (i in seq(1, length(alpha_grid), by = step)) {   for (j in seq(1, length(beta_grid), by = step)) {     arrows(alpha_grid[i], beta_grid[j],            alpha_grid[i] + 0.05 * grad_alpha[i, j],            beta_grid[j] + 0.05 * grad_beta[i, j],            length = 0.05, col = \"#2E4057\", lwd = 1)   } } #> Error: object 'alpha_grid' not found  points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet legend(\"topright\",        legend = c(\"MLE\", \"True\"),        col = c(\"#8B0000\", \"#006400\"),        pch = c(19, 17), bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: Score Test Statistic  # Score test for H0: theta = theta0 theta0 <- c(2, 3) score_theta0 <- -grkw(par = theta0, data = data)  # Score is negative gradient #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Fisher information at theta0 (using Hessian) fisher_info <- hskw(par = theta0, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Score test statistic score_stat <- t(score_theta0) %*% solve(fisher_info) %*% score_theta0 #> Error: object 'score_theta0' not found p_value <- pchisq(score_stat, df = 2, lower.tail = FALSE) #> Error: object 'score_stat' not found  cat(\"\\nScore Test:\\n\") #>  #> Score Test: cat(\"H0: alpha = 2, beta = 3\\n\") #> H0: alpha = 2, beta = 3 cat(\"Score vector:\", score_theta0, \"\\n\") #> Error: object 'score_theta0' not found cat(\"Test statistic:\", score_stat, \"\\n\") #> Error: object 'score_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"Computes gradient vector (vector first partial derivatives) negative log-likelihood function McDonald (Mc) distribution (also known Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\) \\(\\beta = 1\\). gradient useful optimization.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"","code":"grmc(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"par numeric vector length 3 containing distribution parameters order: gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"Returns numeric vector length 3 containing partial derivatives negative log-likelihood function \\(-\\ell(\\theta | \\mathbf{x})\\) respect parameter: \\((-\\partial \\ell/\\partial \\gamma, -\\partial \\ell/\\partial \\delta, -\\partial \\ell/\\partial \\lambda)\\). Returns vector NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"components gradient vector negative log-likelihood (\\(-\\nabla \\ell(\\theta | \\mathbf{x})\\)) Mc (\\(\\alpha=1, \\beta=1\\)) model : $$ -\\frac{\\partial \\ell}{\\partial \\gamma} = n[\\psi(\\gamma+\\delta+1) - \\psi(\\gamma)] - \\lambda\\sum_{=1}^{n}\\ln(x_i) $$ $$ -\\frac{\\partial \\ell}{\\partial \\delta} = n[\\psi(\\gamma+\\delta+1) - \\psi(\\delta+1)] - \\sum_{=1}^{n}\\ln(1-x_i^{\\lambda}) $$ $$ -\\frac{\\partial \\ell}{\\partial \\lambda} = -\\frac{n}{\\lambda} - \\gamma\\sum_{=1}^{n}\\ln(x_i) + \\delta\\sum_{=1}^{n}\\frac{x_i^{\\lambda}\\ln(x_i)}{1-x_i^{\\lambda}} $$ \\(\\psi(\\cdot)\\) digamma function (digamma). formulas represent derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond relevant components general GKw gradient (grgkw) evaluated \\(\\alpha=1, \\beta=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, (Note: Specific gradient formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/grmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî grmc","text":"","code":"# \\donttest{ ## Example 1: Basic Examples  # Generate sample data with more stable parameters set.seed(123) n <- 1000 true_params <- c(gamma = 2.0, delta = 2.5, lambda = 1.5) data <- rmc(n, gamma = true_params[1], delta = true_params[2],             lambda = true_params[3]) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hsmc(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(1.5, 2.0, 1.0),   fn = llmc,   gr = grmc,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2, 1), fn = llmc, gr = grmc, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"gamma\", \"delta\", \"lambda\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hsmc(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"gamma\", \"delta\", \"lambda\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"gamma\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 2.0, 1.0),   c(2.0, 2.5, 1.5),   mle,   c(2.5, 3.0, 2.0) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Gamma = numeric(),   Delta = numeric(),   Lambda = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hsmc(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Gamma = test_params[i, 1],     Delta = test_params[i, 2],     Lambda = test_params[i, 3],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Gamma        Delta        Lambda       Determinant  Trace        #> [6] Min_Eigenval Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (All pairs side by side)  # Create grids around MLE with wider range (¬±1.5) gamma_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 25) #> Error: object 'mle' not found delta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 25) #> Error: object 'mle' not found lambda_grid <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = 25) #> Error: object 'mle' not found  gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found lambda_grid <- lambda_grid[lambda_grid > 0] #> Error: object 'lambda_grid' not found  # Compute curvature measures for all pairs determinant_surface_gd <- matrix(NA, nrow = length(gamma_grid), ncol = length(delta_grid)) #> Error: object 'gamma_grid' not found trace_surface_gd <- matrix(NA, nrow = length(gamma_grid), ncol = length(delta_grid)) #> Error: object 'gamma_grid' not found  determinant_surface_gl <- matrix(NA, nrow = length(gamma_grid), ncol = length(lambda_grid)) #> Error: object 'gamma_grid' not found trace_surface_gl <- matrix(NA, nrow = length(gamma_grid), ncol = length(lambda_grid)) #> Error: object 'gamma_grid' not found  determinant_surface_dl <- matrix(NA, nrow = length(delta_grid), ncol = length(lambda_grid)) #> Error: object 'delta_grid' not found trace_surface_dl <- matrix(NA, nrow = length(delta_grid), ncol = length(lambda_grid)) #> Error: object 'delta_grid' not found  # Gamma vs Delta for (i in seq_along(gamma_grid)) {   for (j in seq_along(delta_grid)) {     H <- hsmc(c(gamma_grid[i], delta_grid[j], mle[3]), data)     determinant_surface_gd[i, j] <- det(H)     trace_surface_gd[i, j] <- sum(diag(H))   } } #> Error: object 'gamma_grid' not found  # Gamma vs Lambda for (i in seq_along(gamma_grid)) {   for (j in seq_along(lambda_grid)) {     H <- hsmc(c(gamma_grid[i], mle[2], lambda_grid[j]), data)     determinant_surface_gl[i, j] <- det(H)     trace_surface_gl[i, j] <- sum(diag(H))   } } #> Error: object 'gamma_grid' not found  # Delta vs Lambda for (i in seq_along(delta_grid)) {   for (j in seq_along(lambda_grid)) {     H <- hsmc(c(mle[1], delta_grid[i], lambda_grid[j]), data)     determinant_surface_dl[i, j] <- det(H)     trace_surface_dl[i, j] <- sum(diag(H))   } } #> Error: object 'delta_grid' not found  # Plot   # Determinant plots contour(gamma_grid, delta_grid, determinant_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"Determinant: Gamma vs Delta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(gamma_grid, lambda_grid, determinant_surface_gl,         xlab = expression(gamma), ylab = expression(lambda),         main = \"Determinant: Gamma vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(delta_grid, lambda_grid, determinant_surface_dl,         xlab = expression(delta), ylab = expression(lambda),         main = \"Determinant: Delta vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'delta_grid' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Trace plots contour(gamma_grid, delta_grid, trace_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"Trace: Gamma vs Delta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(gamma_grid, lambda_grid, trace_surface_gl,         xlab = expression(gamma), ylab = expression(lambda),         main = \"Trace: Gamma vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(delta_grid, lambda_grid, trace_surface_dl,         xlab = expression(delta), ylab = expression(lambda),         main = \"Trace: Delta vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'delta_grid' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\"),        col = c(\"#8B0000\", \"#006400\"),        pch = c(19, 17),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet   ## Example 6: Confidence Ellipses (All pairs side by side)  # Extract all 2x2 submatrices vcov_gd <- vcov_matrix[1:2, 1:2] #> Error: object 'vcov_matrix' not found vcov_gl <- vcov_matrix[c(1, 3), c(1, 3)] #> Error: object 'vcov_matrix' not found vcov_dl <- vcov_matrix[2:3, 2:3] #> Error: object 'vcov_matrix' not found  # Create confidence ellipses theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  # Gamma vs Delta ellipse eig_decomp_gd <- eigen(vcov_gd) #> Error: object 'vcov_gd' not found ellipse_gd <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_gd[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp_gd$vectors %*% diag(sqrt(eig_decomp_gd$values)) %*% v) } #> Error: object 'mle' not found  # Gamma vs Lambda ellipse eig_decomp_gl <- eigen(vcov_gl) #> Error: object 'vcov_gl' not found ellipse_gl <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_gl[i, ] <- mle[c(1, 3)] + sqrt(chi2_val) *     (eig_decomp_gl$vectors %*% diag(sqrt(eig_decomp_gl$values)) %*% v) } #> Error: object 'mle' not found  # Delta vs Lambda ellipse eig_decomp_dl <- eigen(vcov_dl) #> Error: object 'vcov_dl' not found ellipse_dl <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_dl[i, ] <- mle[2:3] + sqrt(chi2_val) *     (eig_decomp_dl$vectors %*% diag(sqrt(eig_decomp_dl$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_gd <- sqrt(diag(vcov_gd)) #> Error: object 'vcov_gd' not found ci_gamma_gd <- mle[1] + c(-1, 1) * 1.96 * se_gd[1] #> Error: object 'mle' not found ci_delta_gd <- mle[2] + c(-1, 1) * 1.96 * se_gd[2] #> Error: object 'mle' not found  se_gl <- sqrt(diag(vcov_gl)) #> Error: object 'vcov_gl' not found ci_gamma_gl <- mle[1] + c(-1, 1) * 1.96 * se_gl[1] #> Error: object 'mle' not found ci_lambda_gl <- mle[3] + c(-1, 1) * 1.96 * se_gl[2] #> Error: object 'mle' not found  se_dl <- sqrt(diag(vcov_dl)) #> Error: object 'vcov_dl' not found ci_delta_dl <- mle[2] + c(-1, 1) * 1.96 * se_dl[1] #> Error: object 'mle' not found ci_lambda_dl <- mle[3] + c(-1, 1) * 1.96 * se_dl[2] #> Error: object 'mle' not found  # Plot   # Gamma vs Delta plot(ellipse_gd[, 1], ellipse_gd[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(delta),      main = \"Gamma vs Delta\", las = 1, xlim = range(ellipse_gd[, 1], ci_gamma_gd),      ylim = range(ellipse_gd[, 2], ci_delta_gd)) #> Error: object 'ci_gamma_gd' not found abline(v = ci_gamma_gd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma_gd' not found abline(h = ci_delta_gd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_gd' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Gamma vs Lambda plot(ellipse_gl[, 1], ellipse_gl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(lambda),      main = \"Gamma vs Lambda\", las = 1, xlim = range(ellipse_gl[, 1], ci_gamma_gl),      ylim = range(ellipse_gl[, 2], ci_lambda_gl)) #> Error: object 'ci_gamma_gl' not found abline(v = ci_gamma_gl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma_gl' not found abline(h = ci_lambda_gl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda_gl' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Delta vs Lambda plot(ellipse_dl[, 1], ellipse_dl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = expression(lambda),      main = \"Delta vs Lambda\", las = 1, xlim = range(ellipse_dl[, 1], ci_delta_dl),      ylim = range(ellipse_dl[, 2], ci_lambda_dl)) #> Error: object 'ci_delta_dl' not found abline(v = ci_delta_dl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_dl' not found abline(h = ci_lambda_dl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda_dl' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"Computes analytic 2x2 Hessian matrix (matrix second partial derivatives) negative log-likelihood function standard Beta distribution, using parameterization common generalized distribution families. distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1. Hessian useful estimating standard errors optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"","code":"hsbeta(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"par numeric vector length 2 containing distribution parameters order: gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"Returns 2x2 numeric matrix representing Hessian matrix negative log-likelihood function, \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\), \\(\\theta = (\\gamma, \\delta)\\). Returns 2x2 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"function calculates analytic second partial derivatives negative log-likelihood function (\\(-\\ell(\\theta|\\mathbf{x})\\)) Beta distribution parameters shape1 = gamma (\\(\\gamma\\)) shape2 = delta + 1 (\\(\\delta+1\\)). components Hessian matrix (\\(-\\mathbf{H}(\\theta)\\)) : $$ -\\frac{\\partial^2 \\ell}{\\partial \\gamma^2} = n[\\psi'(\\gamma) - \\psi'(\\gamma+\\delta+1)] $$ $$ -\\frac{\\partial^2 \\ell}{\\partial \\gamma \\partial \\delta} = -n\\psi'(\\gamma+\\delta+1) $$ $$ -\\frac{\\partial^2 \\ell}{\\partial \\delta^2} = n[\\psi'(\\delta+1) - \\psi'(\\gamma+\\delta+1)] $$ \\(\\psi'(\\cdot)\\) trigamma function (trigamma). formulas represent second derivatives \\(-\\ell(\\theta)\\), consistent minimizing negative log-likelihood. correspond relevant 2x2 submatrix general GKw Hessian (hsgkw) evaluated \\(\\alpha=1, \\beta=1, \\lambda=1\\). Note parameterization difference standard Beta distribution (shape2 = delta + 1). returned matrix symmetric.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, (Note: Specific Hessian formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî hsbeta","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(gamma = 2.0, delta = 3.0) data <- rbeta_(n, gamma = true_params[1], delta = true_params[2]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hsbeta(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(1.5, 2.5),   fn = llbeta,   gr = grbeta,   data = data,   method = \"L-BFGS-B\",   lower = c(0.01, 0.01),   upper = c(100, 100),   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5), fn = llbeta, gr = grbeta, data = data,     method = \"L-BFGS-B\", lower = c(0.01, 0.01), upper = c(100,         100), hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"gamma\", \"delta\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hsbeta(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"gamma\", \"delta\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"gamma\", \"delta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(sprintf(\"\\nMLE corresponds approx to Beta(%.2f, %.2f)\\n\",     mle[1], mle[2] + 1)) #> Error: object 'mle' not found cat(\"True corresponds to Beta(%.2f, %.2f)\\n\",     true_params[1], true_params[2] + 1) #> True corresponds to Beta(%.2f, %.2f) #>  2 4   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 2.5),   c(2.0, 3.0),   mle,   c(2.5, 3.5) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Gamma = numeric(),   Delta = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hsbeta(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Gamma = test_params[i, 1],     Delta = test_params[i, 2],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Gamma        Delta        Determinant  Trace        Min_Eigenval #> [6] Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (Gamma vs Delta)  # Create grid around MLE gamma_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 25) #> Error: object 'mle' not found delta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 25) #> Error: object 'mle' not found gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found  # Compute curvature measures determinant_surface <- matrix(NA, nrow = length(gamma_grid),                                ncol = length(delta_grid)) #> Error: object 'gamma_grid' not found trace_surface <- matrix(NA, nrow = length(gamma_grid),                          ncol = length(delta_grid)) #> Error: object 'gamma_grid' not found  for (i in seq_along(gamma_grid)) {   for (j in seq_along(delta_grid)) {     H <- hsbeta(c(gamma_grid[i], delta_grid[j]), data)     determinant_surface[i, j] <- det(H)     trace_surface[i, j] <- sum(diag(H))   } } #> Error: object 'gamma_grid' not found  # Plot  contour(gamma_grid, delta_grid, determinant_surface,         xlab = expression(gamma), ylab = expression(delta),         main = \"Hessian Determinant\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(gamma_grid, delta_grid, trace_surface,         xlab = expression(gamma), ylab = expression(delta),         main = \"Hessian Trace\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: Confidence Ellipse (Gamma vs Delta)  # Extract 2x2 submatrix (full matrix in this case) vcov_2d <- vcov_matrix #> Error: object 'vcov_matrix' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_gamma <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_delta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot  plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(delta),      main = \"95% Confidence Ellipse (Gamma vs Delta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_gamma, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma' not found abline(h = ci_delta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"Computes analytic 4x4 Hessian matrix (matrix second partial derivatives) negative log-likelihood function Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\lambda = 1\\). Hessian useful estimating standard errors optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"","code":"hsbkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"par numeric vector length 4 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"Returns 4x4 numeric matrix representing Hessian matrix negative log-likelihood function, \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\), \\(\\theta = (\\alpha, \\beta, \\gamma, \\delta)\\). Returns 4x4 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"function calculates analytic second partial derivatives negative log-likelihood function based BKw log-likelihood (\\(\\lambda=1\\) case GKw, see llbkw): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\alpha) + \\ln(\\beta) - \\ln B(\\gamma, \\delta+1)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta(\\delta+1)-1)\\ln(v_i) + (\\gamma-1)\\ln(w_i)] $$ \\(\\theta = (\\alpha, \\beta, \\gamma, \\delta)\\), \\(B(,b)\\) Beta function (beta), intermediate terms : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) Hessian matrix returned contains elements \\(- \\frac{\\partial^2 \\ell(\\theta | \\mathbf{x})}{\\partial \\theta_i \\partial \\theta_j}\\) \\(\\theta_i, \\theta_j \\\\{\\alpha, \\beta, \\gamma, \\delta\\}\\). Key properties returned matrix: Dimensions: 4x4. Symmetry: matrix symmetric. Ordering: Rows columns correspond parameters order \\(\\alpha, \\beta, \\gamma, \\delta\\). Content: Analytic second derivatives negative log-likelihood. corresponds relevant 4x4 submatrix 5x5 GKw Hessian (hsgkw) evaluated \\(\\lambda=1\\). exact analytical formulas implemented directly.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. (Note: Specific Hessian formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the BKw Distribution ‚Äî hsbkw","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation # Generate sample data set.seed(2203) n <- 1000 true_params <- c(alpha = 2.0, beta = 1.5, gamma = 1.5, delta = 0.5) data <- rbkw(n, alpha = true_params[1], beta = true_params[2],              gamma = true_params[3], delta = true_params[4]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hsbkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(1.8, 1.2, 1.1, 0.3),   fn = llbkw,   gr = grbkw,   data = data,   method = \"Nelder-Mead\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.8, 1.2, 1.1, 0.3), fn = llbkw, gr = grbkw, data = data,     method = \"Nelder-Mead\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hsbkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"gamma\", \"delta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 1.0, 1.0, 0.3),   c(2.0, 1.5, 1.5, 0.5),   mle,   c(2.5, 2.0, 2.0, 0.7) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Alpha = numeric(),   Beta = numeric(),   Gamma = numeric(),   Delta = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hsbkw(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Alpha = test_params[i, 1],     Beta = test_params[i, 2],     Gamma = test_params[i, 3],     Delta = test_params[i, 4],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Alpha        Beta         Gamma        Delta        Determinant  #> [6] Trace        Min_Eigenval Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (Selected pairs)  # Create grids around MLE with wider range (¬±1.5) alpha_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 25) #> Error: object 'mle' not found beta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 25) #> Error: object 'mle' not found gamma_grid <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = 25) #> Error: object 'mle' not found delta_grid <- seq(mle[4] - 1.5, mle[4] + 1.5, length.out = 25) #> Error: object 'mle' not found  alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found  # Compute curvature measures for selected pairs determinant_surface_ab <- matrix(NA, nrow = length(alpha_grid), ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found trace_surface_ab <- matrix(NA, nrow = length(alpha_grid), ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found  determinant_surface_ag <- matrix(NA, nrow = length(alpha_grid), ncol = length(gamma_grid)) #> Error: object 'alpha_grid' not found trace_surface_ag <- matrix(NA, nrow = length(alpha_grid), ncol = length(gamma_grid)) #> Error: object 'alpha_grid' not found  determinant_surface_bd <- matrix(NA, nrow = length(beta_grid), ncol = length(delta_grid)) #> Error: object 'beta_grid' not found trace_surface_bd <- matrix(NA, nrow = length(beta_grid), ncol = length(delta_grid)) #> Error: object 'beta_grid' not found  # Alpha vs Beta for (i in seq_along(alpha_grid)) {   for (j in seq_along(beta_grid)) {     H <- hsbkw(c(alpha_grid[i], beta_grid[j], mle[3], mle[4]), data)     determinant_surface_ab[i, j] <- det(H)     trace_surface_ab[i, j] <- sum(diag(H))   } } #> Error: object 'alpha_grid' not found  # Alpha vs Gamma for (i in seq_along(alpha_grid)) {   for (j in seq_along(gamma_grid)) {     H <- hsbkw(c(alpha_grid[i], mle[2], gamma_grid[j], mle[4]), data)     determinant_surface_ag[i, j] <- det(H)     trace_surface_ag[i, j] <- sum(diag(H))   } } #> Error: object 'alpha_grid' not found  # Beta vs Delta for (i in seq_along(beta_grid)) {   for (j in seq_along(delta_grid)) {     H <- hsbkw(c(mle[1], beta_grid[i], mle[3], delta_grid[j]), data)     determinant_surface_bd[i, j] <- det(H)     trace_surface_bd[i, j] <- sum(diag(H))   } } #> Error: object 'beta_grid' not found  # Plot selected curvature surfaces  # Determinant plots contour(alpha_grid, beta_grid, determinant_surface_ab,         xlab = expression(alpha), ylab = expression(beta),         main = \"Determinant: Alpha vs Beta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(alpha_grid, gamma_grid, determinant_surface_ag,         xlab = expression(alpha), ylab = expression(gamma),         main = \"Determinant: Alpha vs Gamma\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(beta_grid, delta_grid, determinant_surface_bd,         xlab = expression(beta), ylab = expression(delta),         main = \"Determinant: Beta vs Delta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'beta_grid' not found points(mle[2], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Trace plots contour(alpha_grid, beta_grid, trace_surface_ab,         xlab = expression(alpha), ylab = expression(beta),         main = \"Trace: Alpha vs Beta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(alpha_grid, gamma_grid, trace_surface_ag,         xlab = expression(alpha), ylab = expression(gamma),         main = \"Trace: Alpha vs Gamma\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(beta_grid, delta_grid, trace_surface_bd,         xlab = expression(beta), ylab = expression(delta),         main = \"Trace: Beta vs Delta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'beta_grid' not found points(mle[2], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\"),        col = c(\"#8B0000\", \"#006400\"),        pch = c(19, 17),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet   ## Example 6: Confidence Ellipses (Selected pairs)  # Extract selected 2x2 submatrices vcov_ab <- vcov_matrix[1:2, 1:2] #> Error: object 'vcov_matrix' not found vcov_ag <- vcov_matrix[c(1, 3), c(1, 3)] #> Error: object 'vcov_matrix' not found vcov_bd <- vcov_matrix[c(2, 4), c(2, 4)] #> Error: object 'vcov_matrix' not found  # Create confidence ellipses theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  # Alpha vs Beta ellipse eig_decomp_ab <- eigen(vcov_ab) #> Error: object 'vcov_ab' not found ellipse_ab <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_ab[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp_ab$vectors %*% diag(sqrt(eig_decomp_ab$values)) %*% v) } #> Error: object 'mle' not found  # Alpha vs Gamma ellipse eig_decomp_ag <- eigen(vcov_ag) #> Error: object 'vcov_ag' not found ellipse_ag <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_ag[i, ] <- mle[c(1, 3)] + sqrt(chi2_val) *     (eig_decomp_ag$vectors %*% diag(sqrt(eig_decomp_ag$values)) %*% v) } #> Error: object 'mle' not found  # Beta vs Delta ellipse eig_decomp_bd <- eigen(vcov_bd) #> Error: object 'vcov_bd' not found ellipse_bd <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_bd[i, ] <- mle[c(2, 4)] + sqrt(chi2_val) *     (eig_decomp_bd$vectors %*% diag(sqrt(eig_decomp_bd$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_ab <- sqrt(diag(vcov_ab)) #> Error: object 'vcov_ab' not found ci_alpha_ab <- mle[1] + c(-1, 1) * 1.96 * se_ab[1] #> Error: object 'mle' not found ci_beta_ab <- mle[2] + c(-1, 1) * 1.96 * se_ab[2] #> Error: object 'mle' not found  se_ag <- sqrt(diag(vcov_ag)) #> Error: object 'vcov_ag' not found ci_alpha_ag <- mle[1] + c(-1, 1) * 1.96 * se_ag[1] #> Error: object 'mle' not found ci_gamma_ag <- mle[3] + c(-1, 1) * 1.96 * se_ag[2] #> Error: object 'mle' not found  se_bd <- sqrt(diag(vcov_bd)) #> Error: object 'vcov_bd' not found ci_beta_bd <- mle[2] + c(-1, 1) * 1.96 * se_bd[1] #> Error: object 'mle' not found ci_delta_bd <- mle[4] + c(-1, 1) * 1.96 * se_bd[2] #> Error: object 'mle' not found  # Plot selected ellipses side by side  # Alpha vs Beta plot(ellipse_ab[, 1], ellipse_ab[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"Alpha vs Beta\", las = 1, xlim = range(ellipse_ab[, 1], ci_alpha_ab),      ylim = range(ellipse_ab[, 2], ci_beta_ab)) #> Error: object 'ci_alpha_ab' not found abline(v = ci_alpha_ab, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha_ab' not found abline(h = ci_beta_ab, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta_ab' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Alpha vs Gamma plot(ellipse_ag[, 1], ellipse_ag[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(gamma),      main = \"Alpha vs Gamma\", las = 1, xlim = range(ellipse_ag[, 1], ci_alpha_ag),      ylim = range(ellipse_ag[, 2], ci_gamma_ag)) #> Error: object 'ci_alpha_ag' not found abline(v = ci_alpha_ag, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha_ag' not found abline(h = ci_gamma_ag, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma_ag' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Beta vs Delta plot(ellipse_bd[, 1], ellipse_bd[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = expression(delta),      main = \"Beta vs Delta\", las = 1, xlim = range(ellipse_bd[, 1], ci_beta_bd),      ylim = range(ellipse_bd[, 2], ci_delta_bd)) #> Error: object 'ci_beta_bd' not found abline(v = ci_beta_bd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta_bd' not found abline(h = ci_delta_bd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_bd' not found points(mle[2], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"Computes analytic 3x3 Hessian matrix (matrix second partial derivatives) negative log-likelihood function Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\) \\(\\delta = 0\\). Hessian useful estimating standard errors optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"","code":"hsekw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"par numeric vector length 3 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"Returns 3x3 numeric matrix representing Hessian matrix negative log-likelihood function, \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\), \\(\\theta = (\\alpha, \\beta, \\lambda)\\). Returns 3x3 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"function calculates analytic second partial derivatives negative log-likelihood function based EKw log-likelihood (\\(\\gamma=1, \\delta=0\\) case GKw, see llekw): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\lambda) + \\ln(\\alpha) + \\ln(\\beta)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta-1)\\ln(v_i) + (\\lambda-1)\\ln(w_i)] $$ \\(\\theta = (\\alpha, \\beta, \\lambda)\\) intermediate terms : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) Hessian matrix returned contains elements \\(- \\frac{\\partial^2 \\ell(\\theta | \\mathbf{x})}{\\partial \\theta_i \\partial \\theta_j}\\) \\(\\theta_i, \\theta_j \\\\{\\alpha, \\beta, \\lambda\\}\\). Key properties returned matrix: Dimensions: 3x3. Symmetry: matrix symmetric. Ordering: Rows columns correspond parameters order \\(\\alpha, \\beta, \\lambda\\). Content: Analytic second derivatives negative log-likelihood. corresponds relevant 3x3 submatrix 5x5 GKw Hessian (hsgkw) evaluated \\(\\gamma=1, \\delta=0\\). exact analytical formulas implemented directly.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. (Note: Specific Hessian formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the EKw Distribution ‚Äî hsekw","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5, lambda = 2.0) data <- rekw(n, alpha = true_params[1], beta = true_params[2],              lambda = true_params[3]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hsekw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(2, 3, 1.5),   fn = llekw,   gr = grekw,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(2, 3, 1.5), fn = llekw, gr = grekw, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"lambda\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hsekw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"alpha\", \"beta\", \"lambda\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(2.0, 3.0, 1.5),   c(2.5, 3.5, 2.0),   mle,   c(3.0, 4.0, 2.5) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Alpha = numeric(),   Beta = numeric(),   Lambda = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hsekw(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Alpha = test_params[i, 1],     Beta = test_params[i, 2],     Lambda = test_params[i, 3],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Alpha        Beta         Lambda       Determinant  Trace        #> [6] Min_Eigenval Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (Alpha vs Beta)  # Create grid around MLE alpha_grid <- seq(mle[1] - 0.5, mle[1] + 0.5, length.out = 25) #> Error: object 'mle' not found beta_grid <- seq(mle[2] - 0.5, mle[2] + 0.5, length.out = 25) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found  # Compute curvature measures determinant_surface <- matrix(NA, nrow = length(alpha_grid),                                ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found trace_surface <- matrix(NA, nrow = length(alpha_grid),                          ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   for (j in seq_along(beta_grid)) {     H <- hsekw(c(alpha_grid[i], beta_grid[j], mle[3]), data)     determinant_surface[i, j] <- det(H)     trace_surface[i, j] <- sum(diag(H))   } } #> Error: object 'alpha_grid' not found  # Plot  contour(alpha_grid, beta_grid, determinant_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Determinant\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(alpha_grid, beta_grid, trace_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Trace\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 6: Confidence Ellipse (Alpha vs Beta)  # Extract 2x2 submatrix for alpha and beta vcov_2d <- vcov_matrix[1:2, 1:2] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_alpha <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_beta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot  plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Ellipse (Alpha vs Beta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha' not found abline(h = ci_beta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 7: Confidence Ellipse (Alpha vs Lambda)  # Extract 2x2 submatrix for alpha and lambda vcov_2d_al <- vcov_matrix[c(1, 3), c(1, 3)] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse eig_decomp_al <- eigen(vcov_2d_al) #> Error: object 'vcov_2d_al' not found ellipse_al <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_al[i, ] <- mle[c(1, 3)] + sqrt(chi2_val) *     (eig_decomp_al$vectors %*% diag(sqrt(eig_decomp_al$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_al <- sqrt(diag(vcov_2d_al)) #> Error: object 'vcov_2d_al' not found ci_alpha_2 <- mle[1] + c(-1, 1) * 1.96 * se_2d_al[1] #> Error: object 'mle' not found ci_lambda <- mle[3] + c(-1, 1) * 1.96 * se_2d_al[2] #> Error: object 'mle' not found  # Plot  plot(ellipse_al[, 1], ellipse_al[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(lambda),      main = \"95% Confidence Ellipse (Alpha vs Lambda)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha_2' not found abline(h = ci_lambda, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda' not found  points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 8: Confidence Ellipse (Beta vs Lambda)  # Extract 2x2 submatrix for beta and lambda vcov_2d_bl <- vcov_matrix[2:3, 2:3] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse eig_decomp_bl <- eigen(vcov_2d_bl) #> Error: object 'vcov_2d_bl' not found ellipse_bl <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_bl[i, ] <- mle[2:3] + sqrt(chi2_val) *     (eig_decomp_bl$vectors %*% diag(sqrt(eig_decomp_bl$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_bl <- sqrt(diag(vcov_2d_bl)) #> Error: object 'vcov_2d_bl' not found ci_beta_2 <- mle[2] + c(-1, 1) * 1.96 * se_2d_bl[1] #> Error: object 'mle' not found ci_lambda_2 <- mle[3] + c(-1, 1) * 1.96 * se_2d_bl[2] #> Error: object 'mle' not found  # Plot  plot(ellipse_bl[, 1], ellipse_bl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = expression(lambda),      main = \"95% Confidence Ellipse (Beta vs Lambda)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_beta_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta_2' not found abline(h = ci_lambda_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda_2' not found  points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"Computes analytic Hessian matrix (matrix second partial derivatives) negative log-likelihood function five-parameter Generalized Kumaraswamy (GKw) distribution. typically used estimate standard errors maximum likelihood estimates optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"","code":"hsgkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"par numeric vector length 5 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"Returns 5x5 numeric matrix representing Hessian matrix negative log-likelihood function, .e., matrix second partial derivatives \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\). Returns 5x5 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"function calculates analytic second partial derivatives negative log-likelihood function based GKw PDF (see dgkw). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) given : $$ \\ell(\\theta) = n \\ln(\\lambda\\alpha\\beta) - n \\ln B(\\gamma, \\delta+1) + \\sum_{=1}^{n} [(\\alpha-1) \\ln(x_i) + (\\beta-1) \\ln(v_i) + (\\gamma\\lambda - 1) \\ln(w_i) + \\delta \\ln(z_i)] $$ \\(\\theta = (\\alpha, \\beta, \\gamma, \\delta, \\lambda)\\), \\(B(,b)\\) Beta function (beta), intermediate terms : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(z_i = 1 - w_i^{\\lambda} = 1 - [1-(1-x_i^{\\alpha})^{\\beta}]^{\\lambda}\\) Hessian matrix returned contains elements \\(- \\frac{\\partial^2 \\ell(\\theta | \\mathbf{x})}{\\partial \\theta_i \\partial \\theta_j}\\). Key properties returned matrix: Dimensions: 5x5. Symmetry: matrix symmetric. Ordering: Rows columns correspond parameters order \\(\\alpha, \\beta, \\gamma, \\delta, \\lambda\\). Content: Analytic second derivatives negative log-likelihood. exact analytical formulas second derivatives implemented directly (often derived using symbolic differentiation) accuracy efficiency, typically using C++.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the GKw Distribution ‚Äî hsgkw","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation  # Generate sample data set.seed(2323) n <- 1000 true_params <- c(alpha = 1.5, beta = 2.0, gamma = 0.8, delta = 1.2, lambda = 0.5) data <- rgkw(n, alpha = true_params[1], beta = true_params[2],              gamma = true_params[3], delta = true_params[4],              lambda = true_params[5]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hsgkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(1.2, 2.0, 0.5, 1.5, 0.2),   fn = llgkw,   gr = grgkw,   data = data,   method = \"Nelder-Mead\",   hessian = TRUE,   control = list(     maxit = 2000,     factr = 1e-15,     pgtol = 1e-15,     trace = FALSE     ) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.2, 2, 0.5, 1.5, 0.2), fn = llgkw, gr = grgkw,     data = data, method = \"Nelder-Mead\", hessian = TRUE, control = list(maxit = 2000,         factr = 1e-15, pgtol = 1e-15, trace = FALSE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hsgkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 2.5, 1.2, 1.5, 1.5),   c(2.0, 3.0, 1.5, 2.0, 1.8),   mle,   c(2.5, 3.5, 1.8, 2.5, 2.0) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Alpha = numeric(),   Beta = numeric(),   Gamma = numeric(),   Delta = numeric(),   Lambda = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hsgkw(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Alpha = test_params[i, 1],     Beta = test_params[i, 2],     Gamma = test_params[i, 3],     Delta = test_params[i, 4],     Lambda = test_params[i, 5],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #>  [1] Alpha        Beta         Gamma        Delta        Lambda       #>  [6] Determinant  Trace        Min_Eigenval Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (Alpha vs Beta)  xd <- 2 # Create grid around MLE alpha_grid <- seq(mle[1] - xd, mle[1] + xd, length.out = round(n/4)) #> Error: object 'mle' not found beta_grid <- seq(mle[2] - xd, mle[2] + xd, length.out = round(n/4)) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found  # Compute curvature measures determinant_surface <- matrix(NA, nrow = length(alpha_grid),                                ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found trace_surface <- matrix(NA, nrow = length(alpha_grid),                          ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   for (j in seq_along(beta_grid)) {     H <- hsgkw(c(alpha_grid[i], beta_grid[j], mle[3], mle[4], mle[5]), data)     determinant_surface[i, j] <- det(H)     trace_surface[i, j] <- sum(diag(H))   } } #> Error: object 'alpha_grid' not found  # Plot  contour(alpha_grid, beta_grid, determinant_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Determinant\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(alpha_grid, beta_grid, trace_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Trace\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: Confidence Ellipse (Alpha vs Beta)  # Extract 2x2 submatrix for alpha and beta vcov_2d <- vcov_matrix[1:2, 1:2] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = round(n/4)) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = round(n/4), ncol = 2) for (i in 1:round(n/4)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_alpha <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_beta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Ellipse (Alpha vs Beta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha' not found abline(h = ci_beta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 7: Confidence Ellipse (Gamma vs Delta)  # Extract 2x2 submatrix for gamma and delta vcov_2d_gd <- vcov_matrix[3:4, 3:4] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse eig_decomp_gd <- eigen(vcov_2d_gd) #> Error: object 'vcov_2d_gd' not found ellipse_gd <- matrix(NA, nrow = round(n/4), ncol = 2) for (i in 1:round(n/4)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_gd[i, ] <- mle[3:4] + sqrt(chi2_val) *     (eig_decomp_gd$vectors %*% diag(sqrt(eig_decomp_gd$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_gd <- sqrt(diag(vcov_2d_gd)) #> Error: object 'vcov_2d_gd' not found ci_gamma <- mle[3] + c(-1, 1) * 1.96 * se_2d_gd[1] #> Error: object 'mle' not found ci_delta <- mle[4] + c(-1, 1) * 1.96 * se_2d_gd[2] #> Error: object 'mle' not found  # Plot plot(ellipse_gd[, 1], ellipse_gd[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(delta),      main = \"95% Confidence Ellipse (Gamma vs Delta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_gamma, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma' not found abline(h = ci_delta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta' not found  points(mle[3], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[3], true_params[4], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 8: Confidence Ellipse (Delta vs Lambda)  # Extract 2x2 submatrix for delta and lambda vcov_2d_dl <- vcov_matrix[4:5, 4:5] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse eig_decomp_dl <- eigen(vcov_2d_dl) #> Error: object 'vcov_2d_dl' not found ellipse_dl <- matrix(NA, nrow = round(n/4), ncol = 2) for (i in 1:round(n/4)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_dl[i, ] <- mle[4:5] + sqrt(chi2_val) *     (eig_decomp_dl$vectors %*% diag(sqrt(eig_decomp_dl$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_dl <- sqrt(diag(vcov_2d_dl)) #> Error: object 'vcov_2d_dl' not found ci_delta_2 <- mle[4] + c(-1, 1) * 1.96 * se_2d_dl[1] #> Error: object 'mle' not found ci_lambda <- mle[5] + c(-1, 1) * 1.96 * se_2d_dl[2] #> Error: object 'mle' not found  # Plot plot(ellipse_dl[, 1], ellipse_dl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = expression(lambda),      main = \"95% Confidence Ellipse (Delta vs Lambda)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_delta_2, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_2' not found abline(h = ci_lambda, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda' not found  points(mle[4], mle[5], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[4], true_params[5], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"Computes analytic 4x4 Hessian matrix (matrix second partial derivatives) negative log-likelihood function Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\). Hessian useful estimating standard errors optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"","code":"hskkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"par numeric vector length 4 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"Returns 4x4 numeric matrix representing Hessian matrix negative log-likelihood function, \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\), \\(\\theta = (\\alpha, \\beta, \\delta, \\lambda)\\). Returns 4x4 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"function calculates analytic second partial derivatives negative log-likelihood function based kkw log-likelihood (\\(\\gamma=1\\) case GKw, see llkkw): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\delta+1) + \\ln(\\lambda) + \\ln(\\alpha) + \\ln(\\beta)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta-1)\\ln(v_i) + (\\lambda-1)\\ln(w_i) + \\delta\\ln(z_i)] $$ \\(\\theta = (\\alpha, \\beta, \\delta, \\lambda)\\) intermediate terms : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(z_i = 1 - w_i^{\\lambda} = 1 - [1-(1-x_i^{\\alpha})^{\\beta}]^{\\lambda}\\) Hessian matrix returned contains elements \\(- \\frac{\\partial^2 \\ell(\\theta | \\mathbf{x})}{\\partial \\theta_i \\partial \\theta_j}\\) \\(\\theta_i, \\theta_j \\\\{\\alpha, \\beta, \\delta, \\lambda\\}\\). Key properties returned matrix: Dimensions: 4x4. Symmetry: matrix symmetric. Ordering: Rows columns correspond parameters order \\(\\alpha, \\beta, \\delta, \\lambda\\). Content: Analytic second derivatives negative log-likelihood. corresponds relevant submatrix 5x5 GKw Hessian (hsgkw) evaluated \\(\\gamma=1\\). exact analytical formulas implemented directly.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the kkw Distribution ‚Äî hskkw","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.0, beta = 3.0, delta = 1.5, lambda = 2.0) data <- rkkw(n, alpha = true_params[1], beta = true_params[2],              delta = true_params[3], lambda = true_params[4]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hskkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(1.5, 2.5, 1.0, 1.5),   fn = llkkw,   gr = grkkw,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5, 1, 1.5), fn = llkkw, gr = grkkw, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"delta\", \"lambda\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hskkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"alpha\", \"beta\", \"delta\", \"lambda\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 2.5, 1.0, 1.5),   c(2.0, 3.0, 1.5, 2.0),   mle,   c(2.5, 3.5, 2.0, 2.5) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Alpha = numeric(),   Beta = numeric(),   Delta = numeric(),   Lambda = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hskkw(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Alpha = test_params[i, 1],     Beta = test_params[i, 2],     Delta = test_params[i, 3],     Lambda = test_params[i, 4],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Alpha        Beta         Delta        Lambda       Determinant  #> [6] Trace        Min_Eigenval Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (Alpha vs Beta)  # Create grid around MLE alpha_grid <- seq(mle[1] - 1, mle[1] + 1, length.out = round(n/4)) #> Error: object 'mle' not found beta_grid <- seq(mle[2] - 1, mle[2] + 1, length.out = round(n/4)) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found  # Compute curvature measures determinant_surface <- matrix(NA, nrow = length(alpha_grid),                                ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found trace_surface <- matrix(NA, nrow = length(alpha_grid),                          ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   for (j in seq_along(beta_grid)) {     H <- hskkw(c(alpha_grid[i], beta_grid[j], mle[3], mle[4]), data)     determinant_surface[i, j] <- det(H)     trace_surface[i, j] <- sum(diag(H))   } } #> Error: object 'alpha_grid' not found  # Plot  contour(alpha_grid, beta_grid, determinant_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Determinant\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(alpha_grid, beta_grid, trace_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Trace\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 6: Confidence Ellipse (Alpha vs Beta)  # Extract 2x2 submatrix for alpha and beta vcov_2d <- vcov_matrix[1:2, 1:2] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse theta <- seq(0, 2 * pi, length.out = round(n/2)) chi2_val <- qchisq(0.95, df = 2)  eig_decomp <- eigen(vcov_2d) #> Error: object 'vcov_2d' not found ellipse <- matrix(NA, nrow = round(n/2), ncol = 2) for (i in 1:round(n/2)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d <- sqrt(diag(vcov_2d)) #> Error: object 'vcov_2d' not found ci_alpha <- mle[1] + c(-1, 1) * 1.96 * se_2d[1] #> Error: object 'mle' not found ci_beta <- mle[2] + c(-1, 1) * 1.96 * se_2d[2] #> Error: object 'mle' not found  # Plot plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Ellipse (Alpha vs Beta)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_alpha, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_alpha' not found abline(h = ci_beta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_beta' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")   ## Example 7: Confidence Ellipse (Delta vs Lambda)  # Extract 2x2 submatrix for delta and lambda vcov_2d_dl <- vcov_matrix[3:4, 3:4] #> Error: object 'vcov_matrix' not found  # Create confidence ellipse eig_decomp_dl <- eigen(vcov_2d_dl) #> Error: object 'vcov_2d_dl' not found ellipse_dl <- matrix(NA, nrow = round(n/2), ncol = 2) for (i in 1:round(n/2)) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_dl[i, ] <- mle[3:4] + sqrt(chi2_val) *     (eig_decomp_dl$vectors %*% diag(sqrt(eig_decomp_dl$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_2d_dl <- sqrt(diag(vcov_2d_dl)) #> Error: object 'vcov_2d_dl' not found ci_delta <- mle[3] + c(-1, 1) * 1.96 * se_2d_dl[1] #> Error: object 'mle' not found ci_lambda <- mle[4] + c(-1, 1) * 1.96 * se_2d_dl[2] #> Error: object 'mle' not found  # Plot plot(ellipse_dl[, 1], ellipse_dl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = expression(lambda),      main = \"95% Confidence Ellipse (Delta vs Lambda)\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values  # Add marginal CIs abline(v = ci_delta, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta' not found abline(h = ci_lambda, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda' not found  points(mle[3], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[3], true_params[4], pch = 17, col = \"#006400\", cex = 1.5)  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"Computes analytic 2x2 Hessian matrix (matrix second partial derivatives) negative log-likelihood function two-parameter Kumaraswamy (Kw) distribution parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)). Hessian useful estimating standard errors optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"","code":"hskw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"par numeric vector length 2 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"Returns 2x2 numeric matrix representing Hessian matrix negative log-likelihood function, \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\), \\(\\theta = (\\alpha, \\beta)\\). Returns 2x2 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"function calculates analytic second partial derivatives negative log-likelihood function (\\(-\\ell(\\theta|\\mathbf{x})\\)). components negative second derivatives log-likelihood \\(\\ell\\) (derived PDF dkw). Let \\(v_i = 1 - x_i^{\\alpha}\\). second derivatives positive log-likelihood (\\(\\ell\\)) : $$ \\frac{\\partial^2 \\ell}{\\partial \\alpha^2} = -\\frac{n}{\\alpha^2} - (\\beta-1)\\sum_{=1}^{n}\\frac{x_i^{\\alpha}(\\ln(x_i))^2}{v_i^2} $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\alpha \\partial \\beta} = - \\sum_{=1}^{n}\\frac{x_i^{\\alpha}\\ln(x_i)}{v_i} $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\beta^2} = -\\frac{n}{\\beta^2} $$ function returns Hessian matrix containing negative values. Key properties returned matrix: Dimensions: 2x2. Symmetry: matrix symmetric. Ordering: Rows columns correspond parameters order \\(\\alpha, \\beta\\). Content: Analytic second derivatives negative log-likelihood. corresponds relevant 2x2 submatrix 5x5 GKw Hessian (hsgkw) evaluated \\(\\gamma=1, \\delta=0, \\lambda=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81. (Note: Specific Hessian formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hskw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the Kw Distribution ‚Äî hskw","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5) data <- rkw(n, alpha = true_params[1], beta = true_params[2]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hskw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found  ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(2, 2),   fn = llkw,   gr = grkw,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(2, 2), fn = llkw, gr = grkw, data = data, method = \"BFGS\",     hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hskw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix (negative Hessian for neg-loglik) obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"alpha\", \"beta\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"alpha\", \"beta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 2.5),   c(2.0, 3.0),   mle,   c(3.0, 4.0) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Alpha = numeric(),   Beta = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hskw(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Alpha = test_params[i, 1],     Beta = test_params[i, 2],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Alpha        Beta         Determinant  Trace        Min_Eigenval #> [6] Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)  ## Example 5: Curvature Visualization  # Create grid around MLE alpha_grid <- seq(mle[1] - 0.5, mle[1] + 0.5, length.out = 30) #> Error: object 'mle' not found beta_grid <- seq(mle[2] - 0.5, mle[2] + 0.5, length.out = 30) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found  # Compute curvature measures determinant_surface <- matrix(NA, nrow = length(alpha_grid),                                ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found trace_surface <- matrix(NA, nrow = length(alpha_grid),                          ncol = length(beta_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   for (j in seq_along(beta_grid)) {     H <- hskw(c(alpha_grid[i], beta_grid[j]), data)     determinant_surface[i, j] <- det(H)     trace_surface[i, j] <- sum(diag(H))   } } #> Error: object 'alpha_grid' not found  # Plot  contour(alpha_grid, beta_grid, determinant_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Determinant\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(alpha_grid, beta_grid, trace_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"Hessian Trace\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'alpha_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 6: Fisher Information and Asymptotic Efficiency  # Observed information (at MLE) obs_fisher <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Asymptotic covariance matrix asymp_cov <- solve(obs_fisher) #> Error: object 'obs_fisher' not found  cat(\"\\nAsymptotic Standard Errors:\\n\") #>  #> Asymptotic Standard Errors: cat(\"SE(alpha):\", sqrt(asymp_cov[1, 1]), \"\\n\") #> Error: object 'asymp_cov' not found cat(\"SE(beta):\", sqrt(asymp_cov[2, 2]), \"\\n\") #> Error: object 'asymp_cov' not found  # Cram√©r-Rao Lower Bound cat(\"\\nCram√©r-Rao Lower Bounds:\\n\") #>  #> Cram√©r-Rao Lower Bounds: cat(\"CRLB(alpha):\", sqrt(asymp_cov[1, 1]), \"\\n\") #> Error: object 'asymp_cov' not found cat(\"CRLB(beta):\", sqrt(asymp_cov[2, 2]), \"\\n\") #> Error: object 'asymp_cov' not found  # Efficiency ellipse (95% confidence region) theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  # Eigendecomposition eig_decomp <- eigen(asymp_cov) #> Error: object 'asymp_cov' not found  # Ellipse points ellipse <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse[i, ] <- mle + sqrt(chi2_val) *     (eig_decomp$vectors %*% diag(sqrt(eig_decomp$values)) %*% v) } #> Error: object 'mle' not found  # Plot confidence ellipse  plot(ellipse[, 1], ellipse[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = expression(beta),      main = \"95% Confidence Ellipse\", las = 1) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Error in plot.window(...): need finite 'xlim' values points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\"),        pch = c(19, 17, NA), lty = c(NA, NA, 1),        lwd = c(NA, NA, 2), bty = \"n\") grid(col = \"gray90\")  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"Computes analytic 3x3 Hessian matrix (matrix second partial derivatives) negative log-likelihood function McDonald (Mc) distribution (also known Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\) \\(\\beta = 1\\). Hessian useful estimating standard errors optimization algorithms.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"","code":"hsmc(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"par numeric vector length 3 containing distribution parameters order: gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"Returns 3x3 numeric matrix representing Hessian matrix negative log-likelihood function, \\(-\\partial^2 \\ell / (\\partial \\theta_i \\partial \\theta_j)\\), \\(\\theta = (\\gamma, \\delta, \\lambda)\\). Returns 3x3 matrix populated NaN parameter values invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"function calculates analytic second partial derivatives negative log-likelihood function (\\(-\\ell(\\theta|\\mathbf{x})\\)). components based second derivatives log-likelihood \\(\\ell\\) (derived PDF dmc). Note: formulas represent second derivatives positive log-likelihood (\\(\\ell\\)). function returns negative values. Users verify formulas independently using critical applications. $$ \\frac{\\partial^2 \\ell}{\\partial \\gamma^2} = -n[\\psi'(\\gamma) - \\psi'(\\gamma+\\delta+1)] $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\gamma \\partial \\delta} = -n\\psi'(\\gamma+\\delta+1) $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\gamma \\partial \\lambda} = \\sum_{=1}^{n}\\ln(x_i) $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\delta^2} = -n[\\psi'(\\delta+1) - \\psi'(\\gamma+\\delta+1)] $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\delta \\partial \\lambda} = -\\sum_{=1}^{n}\\frac{x_i^{\\lambda}\\ln(x_i)}{1-x_i^{\\lambda}} $$ $$ \\frac{\\partial^2 \\ell}{\\partial \\lambda^2} = -\\frac{n}{\\lambda^2} - \\delta\\sum_{=1}^{n}\\frac{x_i^{\\lambda}[\\ln(x_i)]^2}{(1-x_i^{\\lambda})^2} $$ \\(\\psi'(\\cdot)\\) trigamma function (trigamma). (Note: formula \\(\\partial^2 \\ell / \\partial \\lambda^2\\) provided source comment different potentially related expected information matrix; formula shown derived gradient provided earlier. Verification recommended.) returned matrix symmetric, rows/columns corresponding \\(\\gamma, \\delta, \\lambda\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, (Note: Specific Hessian formulas might derived sourced additional references).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/hsmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hessian Matrix of the Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî hsmc","text":"","code":"# \\donttest{ ## Example 1: Basic Hessian Evaluation  # Generate sample data with more stable parameters set.seed(123) n <- 1000 true_params <- c(gamma = 2.0, delta = 2.5, lambda = 1.5) data <- rmc(n, gamma = true_params[1], delta = true_params[2],             lambda = true_params[3]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate Hessian at true parameters hess_true <- hsmc(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Hessian matrix at true parameters:\\n\") #> Hessian matrix at true parameters: print(hess_true, digits = 4) #> Error: object 'hess_true' not found  # Check symmetry cat(\"\\nSymmetry check (max |H - H^T|):\",     max(abs(hess_true - t(hess_true))), \"\\n\") #> Error: object 'hess_true' not found   ## Example 2: Hessian Properties at MLE  # Fit model fit <- optim(   par = c(1.5, 2.0, 1.0),   fn = llmc,   gr = grmc,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2, 1), fn = llmc, gr = grmc, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"gamma\", \"delta\", \"lambda\") #> Error: object 'mle' not found  # Hessian at MLE hessian_at_mle <- hsmc(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"\\nHessian at MLE:\\n\") #>  #> Hessian at MLE: print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Compare with optim's numerical Hessian cat(\"\\nComparison with optim Hessian:\\n\") #>  #> Comparison with optim Hessian: cat(\"Max absolute difference:\",     max(abs(hessian_at_mle - fit$hessian)), \"\\n\") #> Error: object 'hessian_at_mle' not found  # Eigenvalue analysis eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found cat(\"\\nEigenvalues:\\n\") #>  #> Eigenvalues: print(eigenvals) #> Error: object 'eigenvals' not found  cat(\"\\nPositive definite:\", all(eigenvals > 0), \"\\n\") #> Error: object 'eigenvals' not found cat(\"Condition number:\", max(eigenvals) / min(eigenvals), \"\\n\") #> Error: object 'eigenvals' not found   ## Example 3: Standard Errors and Confidence Intervals  # Observed information matrix obs_info <- hessian_at_mle #> Error: object 'hessian_at_mle' not found  # Variance-covariance matrix vcov_matrix <- solve(obs_info) #> Error: object 'obs_info' not found cat(\"\\nVariance-Covariance Matrix:\\n\") #>  #> Variance-Covariance Matrix: print(vcov_matrix, digits = 6) #> Error: object 'vcov_matrix' not found  # Standard errors se <- sqrt(diag(vcov_matrix)) #> Error: object 'vcov_matrix' not found names(se) <- c(\"gamma\", \"delta\", \"lambda\") #> Error: object 'se' not found  # Correlation matrix corr_matrix <- cov2cor(vcov_matrix) #> Error: object 'vcov_matrix' not found cat(\"\\nCorrelation Matrix:\\n\") #>  #> Correlation Matrix: print(corr_matrix, digits = 4) #> Error: object 'corr_matrix' not found  # Confidence intervals z_crit <- qnorm(0.975) results <- data.frame(   Parameter = c(\"gamma\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - z_crit * se,   CI_Upper = mle + z_crit * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 4: Determinant and Trace Analysis  # Compute at different points test_params <- rbind(   c(1.5, 2.0, 1.0),   c(2.0, 2.5, 1.5),   mle,   c(2.5, 3.0, 2.0) ) #> Error: object 'mle' not found  hess_properties <- data.frame(   Gamma = numeric(),   Delta = numeric(),   Lambda = numeric(),   Determinant = numeric(),   Trace = numeric(),   Min_Eigenval = numeric(),   Max_Eigenval = numeric(),   Cond_Number = numeric(),   stringsAsFactors = FALSE )  for (i in 1:nrow(test_params)) {   H <- hsmc(par = test_params[i, ], data = data)   eigs <- eigen(H, only.values = TRUE)$values    hess_properties <- rbind(hess_properties, data.frame(     Gamma = test_params[i, 1],     Delta = test_params[i, 2],     Lambda = test_params[i, 3],     Determinant = det(H),     Trace = sum(diag(H)),     Min_Eigenval = min(eigs),     Max_Eigenval = max(eigs),     Cond_Number = max(eigs) / min(eigs)   )) } #> Error: object 'test_params' not found  cat(\"\\nHessian Properties at Different Points:\\n\") #>  #> Hessian Properties at Different Points: print(hess_properties, digits = 4, row.names = FALSE) #> [1] Gamma        Delta        Lambda       Determinant  Trace        #> [6] Min_Eigenval Max_Eigenval Cond_Number  #> <0 rows> (or 0-length row.names)   ## Example 5: Curvature Visualization (All pairs side by side)  # Create grids around MLE with wider range (¬±1.5) gamma_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 25) #> Error: object 'mle' not found delta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 25) #> Error: object 'mle' not found lambda_grid <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = 25) #> Error: object 'mle' not found  gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found lambda_grid <- lambda_grid[lambda_grid > 0] #> Error: object 'lambda_grid' not found  # Compute curvature measures for all pairs determinant_surface_gd <- matrix(NA, nrow = length(gamma_grid), ncol = length(delta_grid)) #> Error: object 'gamma_grid' not found trace_surface_gd <- matrix(NA, nrow = length(gamma_grid), ncol = length(delta_grid)) #> Error: object 'gamma_grid' not found  determinant_surface_gl <- matrix(NA, nrow = length(gamma_grid), ncol = length(lambda_grid)) #> Error: object 'gamma_grid' not found trace_surface_gl <- matrix(NA, nrow = length(gamma_grid), ncol = length(lambda_grid)) #> Error: object 'gamma_grid' not found  determinant_surface_dl <- matrix(NA, nrow = length(delta_grid), ncol = length(lambda_grid)) #> Error: object 'delta_grid' not found trace_surface_dl <- matrix(NA, nrow = length(delta_grid), ncol = length(lambda_grid)) #> Error: object 'delta_grid' not found  # Gamma vs Delta for (i in seq_along(gamma_grid)) {   for (j in seq_along(delta_grid)) {     H <- hsmc(c(gamma_grid[i], delta_grid[j], mle[3]), data)     determinant_surface_gd[i, j] <- det(H)     trace_surface_gd[i, j] <- sum(diag(H))   } } #> Error: object 'gamma_grid' not found  # Gamma vs Lambda for (i in seq_along(gamma_grid)) {   for (j in seq_along(lambda_grid)) {     H <- hsmc(c(gamma_grid[i], mle[2], lambda_grid[j]), data)     determinant_surface_gl[i, j] <- det(H)     trace_surface_gl[i, j] <- sum(diag(H))   } } #> Error: object 'gamma_grid' not found  # Delta vs Lambda for (i in seq_along(delta_grid)) {   for (j in seq_along(lambda_grid)) {     H <- hsmc(c(mle[1], delta_grid[i], lambda_grid[j]), data)     determinant_surface_dl[i, j] <- det(H)     trace_surface_dl[i, j] <- sum(diag(H))   } } #> Error: object 'delta_grid' not found  # Plot   # Determinant plots contour(gamma_grid, delta_grid, determinant_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"Determinant: Gamma vs Delta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(gamma_grid, lambda_grid, determinant_surface_gl,         xlab = expression(gamma), ylab = expression(lambda),         main = \"Determinant: Gamma vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(delta_grid, lambda_grid, determinant_surface_dl,         xlab = expression(delta), ylab = expression(lambda),         main = \"Determinant: Delta vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'delta_grid' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Trace plots contour(gamma_grid, delta_grid, trace_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"Trace: Gamma vs Delta\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(gamma_grid, lambda_grid, trace_surface_gl,         xlab = expression(gamma), ylab = expression(lambda),         main = \"Trace: Gamma vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'gamma_grid' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  contour(delta_grid, lambda_grid, trace_surface_dl,         xlab = expression(delta), ylab = expression(lambda),         main = \"Trace: Delta vs Lambda\", las = 1,         col = \"#2E4057\", lwd = 1.5, nlevels = 15) #> Error: object 'delta_grid' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\"),        col = c(\"#8B0000\", \"#006400\"),        pch = c(19, 17),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  ## Example 6: Confidence Ellipses (All pairs side by side)  # Extract all 2x2 submatrices vcov_gd <- vcov_matrix[1:2, 1:2] #> Error: object 'vcov_matrix' not found vcov_gl <- vcov_matrix[c(1, 3), c(1, 3)] #> Error: object 'vcov_matrix' not found vcov_dl <- vcov_matrix[2:3, 2:3] #> Error: object 'vcov_matrix' not found  # Create confidence ellipses theta <- seq(0, 2 * pi, length.out = 100) chi2_val <- qchisq(0.95, df = 2)  # Gamma vs Delta ellipse eig_decomp_gd <- eigen(vcov_gd) #> Error: object 'vcov_gd' not found ellipse_gd <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_gd[i, ] <- mle[1:2] + sqrt(chi2_val) *     (eig_decomp_gd$vectors %*% diag(sqrt(eig_decomp_gd$values)) %*% v) } #> Error: object 'mle' not found  # Gamma vs Lambda ellipse eig_decomp_gl <- eigen(vcov_gl) #> Error: object 'vcov_gl' not found ellipse_gl <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_gl[i, ] <- mle[c(1, 3)] + sqrt(chi2_val) *     (eig_decomp_gl$vectors %*% diag(sqrt(eig_decomp_gl$values)) %*% v) } #> Error: object 'mle' not found  # Delta vs Lambda ellipse eig_decomp_dl <- eigen(vcov_dl) #> Error: object 'vcov_dl' not found ellipse_dl <- matrix(NA, nrow = 100, ncol = 2) for (i in 1:100) {   v <- c(cos(theta[i]), sin(theta[i]))   ellipse_dl[i, ] <- mle[2:3] + sqrt(chi2_val) *     (eig_decomp_dl$vectors %*% diag(sqrt(eig_decomp_dl$values)) %*% v) } #> Error: object 'mle' not found  # Marginal confidence intervals se_gd <- sqrt(diag(vcov_gd)) #> Error: object 'vcov_gd' not found ci_gamma_gd <- mle[1] + c(-1, 1) * 1.96 * se_gd[1] #> Error: object 'mle' not found ci_delta_gd <- mle[2] + c(-1, 1) * 1.96 * se_gd[2] #> Error: object 'mle' not found  se_gl <- sqrt(diag(vcov_gl)) #> Error: object 'vcov_gl' not found ci_gamma_gl <- mle[1] + c(-1, 1) * 1.96 * se_gl[1] #> Error: object 'mle' not found ci_lambda_gl <- mle[3] + c(-1, 1) * 1.96 * se_gl[2] #> Error: object 'mle' not found  se_dl <- sqrt(diag(vcov_dl)) #> Error: object 'vcov_dl' not found ci_delta_dl <- mle[2] + c(-1, 1) * 1.96 * se_dl[1] #> Error: object 'mle' not found ci_lambda_dl <- mle[3] + c(-1, 1) * 1.96 * se_dl[2] #> Error: object 'mle' not found  # Plot  # Gamma vs Delta plot(ellipse_gd[, 1], ellipse_gd[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(delta),      main = \"Gamma vs Delta\", las = 1, xlim = range(ellipse_gd[, 1], ci_gamma_gd),      ylim = range(ellipse_gd[, 2], ci_delta_gd)) #> Error: object 'ci_gamma_gd' not found abline(v = ci_gamma_gd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma_gd' not found abline(h = ci_delta_gd, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_gd' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Gamma vs Lambda plot(ellipse_gl[, 1], ellipse_gl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = expression(lambda),      main = \"Gamma vs Lambda\", las = 1, xlim = range(ellipse_gl[, 1], ci_gamma_gl),      ylim = range(ellipse_gl[, 2], ci_lambda_gl)) #> Error: object 'ci_gamma_gl' not found abline(v = ci_gamma_gl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_gamma_gl' not found abline(h = ci_lambda_gl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda_gl' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Delta vs Lambda plot(ellipse_dl[, 1], ellipse_dl[, 2], type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = expression(lambda),      main = \"Delta vs Lambda\", las = 1, xlim = range(ellipse_dl[, 1], ci_delta_dl),      ylim = range(ellipse_dl[, 2], ci_lambda_dl)) #> Error: object 'ci_delta_dl' not found abline(v = ci_delta_dl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_delta_dl' not found abline(h = ci_lambda_dl, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'ci_lambda_dl' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\", \"Marginal 95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\", \"#808080\"),        pch = c(19, 17, NA, NA),        lty = c(NA, NA, 1, 3),        lwd = c(NA, NA, 2, 1.5),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"Computes negative log-likelihood function standard Beta distribution, using parameterization common generalized distribution families. distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1. function suitable maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"","code":"llbeta(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"par numeric vector length 2 containing distribution parameters order: gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns Inf parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"function calculates negative log-likelihood Beta distribution parameters shape1 = gamma (\\(\\gamma\\)) shape2 = delta + 1 (\\(\\delta+1\\)). probability density function (PDF) : $$ f(x | \\gamma, \\delta) = \\frac{x^{\\gamma-1} (1-x)^{\\delta}}{B(\\gamma, \\delta+1)} $$ \\(0 < x < 1\\), \\(B(,b)\\) Beta function (beta). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) \\(\\sum_{=1}^n \\ln f(x_i | \\theta)\\): $$ \\ell(\\theta | \\mathbf{x}) = \\sum_{=1}^{n} [(\\gamma-1)\\ln(x_i) + \\delta\\ln(1-x_i)] - n \\ln B(\\gamma, \\delta+1) $$ \\(\\theta = (\\gamma, \\delta)\\). function computes returns negative log-likelihood, \\(-\\ell(\\theta|\\mathbf{x})\\), suitable minimization using optimization routines like optim. equivalent negative log-likelihood GKw distribution (llgkw) evaluated \\(\\alpha=1, \\beta=1, \\lambda=1\\), also negative log-likelihood McDonald distribution (llmc) evaluated \\(\\lambda=1\\). term \\(\\ln B(\\gamma, \\delta+1)\\) typically computed using log-gamma functions (lgamma) numerical stability.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation,","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî llbeta","text":"","code":"# \\donttest{ ## Example 1: Basic Log-Likelihood Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(gamma = 2.0, delta = 3.0) data <- rbeta_(n, gamma = true_params[1], delta = true_params[2]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate negative log-likelihood at true parameters nll_true <- llbeta(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Negative log-likelihood at true parameters:\", nll_true, \"\\n\") #> Error: object 'nll_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5),   c(2.0, 3.0),   c(2.5, 3.5) )  nll_values <- apply(test_params, 1, function(p) llbeta(p, data)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt results <- data.frame(   Gamma = test_params[, 1],   Delta = test_params[, 2],   NegLogLik = nll_values ) #> Error: object 'nll_values' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Maximum Likelihood Estimation  # Optimization using L-BFGS-B with bounds fit <- optim(   par = c(1.5, 2.5),   fn = llbeta,   gr = grbeta,   data = data,   method = \"L-BFGS-B\",   lower = c(0.01, 0.01),   upper = c(100, 100),   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5), fn = llbeta, gr = grbeta, data = data,     method = \"L-BFGS-B\", lower = c(0.01, 0.01), upper = c(100,         100), hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"gamma\", \"delta\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  results <- data.frame(   Parameter = c(\"gamma\", \"delta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(sprintf(\"\\nMLE corresponds approx to Beta(%.2f, %.2f)\\n\",     mle[1], mle[2] + 1)) #> Error: object 'mle' not found cat(\"True corresponds to Beta(%.2f, %.2f)\\n\",     true_params[1], true_params[2] + 1) #> True corresponds to Beta(%.2f, %.2f) #>  2 4  cat(\"\\nNegative log-likelihood at MLE:\", fit$value, \"\\n\") #> Error: object 'fit' not found cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> Error: object 'fit' not found cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> Error: object 'fit' not found   ## Example 3: Comparing Optimization Methods  methods <- c(\"BFGS\", \"L-BFGS-B\", \"Nelder-Mead\", \"CG\") start_params <- c(1.5, 2.5)  comparison <- data.frame(   Method = character(),   Gamma = numeric(),   Delta = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method %in% c(\"BFGS\", \"CG\")) {     fit_temp <- optim(       par = start_params,       fn = llbeta,       gr = grbeta,       data = data,       method = method     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llbeta,       gr = grbeta,       data = data,       method = method,       lower = c(0.01, 0.01),       upper = c(100, 100)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llbeta,       data = data,       method = method     )   }    comparison <- rbind(comparison, data.frame(     Method = method,     Gamma = fit_temp$par[1],     Delta = fit_temp$par[2],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llbeta, gr = grbeta, data = data,     method = method): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Gamma       Delta       NegLogLik   Convergence #> <0 rows> (or 0-length row.names)   ## Example 4: Likelihood Ratio Test  # Test H0: delta = 3 vs H1: delta free loglik_full <- -fit$value #> Error: object 'fit' not found  restricted_ll <- function(params_restricted, data, delta_fixed) {   llbeta(par = c(params_restricted[1], delta_fixed), data = data) }  fit_restricted <- optim(   par = mle[1],   fn = restricted_ll,   data = data,   delta_fixed = 3,   method = \"BFGS\" ) #> Error: object 'mle' not found  loglik_restricted <- -fit_restricted$value #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 5: Univariate Profile Likelihoods  # Profile for gamma gamma_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 50) #> Error: object 'mle' not found gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found profile_ll_gamma <- numeric(length(gamma_grid)) #> Error: object 'gamma_grid' not found  for (i in seq_along(gamma_grid)) {   profile_fit <- optim(     par = mle[2],     fn = function(p) llbeta(c(gamma_grid[i], p), data),     method = \"BFGS\"   )   profile_ll_gamma[i] <- -profile_fit$value } #> Error: object 'gamma_grid' not found  # Profile for delta delta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 50) #> Error: object 'mle' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found profile_ll_delta <- numeric(length(delta_grid)) #> Error: object 'delta_grid' not found  for (i in seq_along(delta_grid)) {   profile_fit <- optim(     par = mle[1],     fn = function(p) llbeta(c(p, delta_grid[i]), data),     method = \"BFGS\"   )   profile_ll_delta[i] <- -profile_fit$value } #> Error: object 'delta_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_gamma) - chi_crit / 2 #> Error: object 'profile_ll_gamma' not found  # Plot   plot(gamma_grid, profile_ll_gamma, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", gamma)), las = 1) #> Error: object 'gamma_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(delta_grid, profile_ll_delta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", delta)), las = 1) #> Error: object 'delta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: 2D Log-Likelihood Surface (Gamma vs Delta)  # Create 2D grid with wider range (¬±1.5) gamma_2d <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found delta_2d <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found gamma_2d <- gamma_2d[gamma_2d > 0] #> Error: object 'gamma_2d' not found delta_2d <- delta_2d[delta_2d > 0] #> Error: object 'delta_2d' not found  # Compute log-likelihood surface ll_surface_gd <- matrix(NA, nrow = length(gamma_2d), ncol = length(delta_2d)) #> Error: object 'gamma_2d' not found  for (i in seq_along(gamma_2d)) {   for (j in seq_along(delta_2d)) {     ll_surface_gd[i, j] <- -llbeta(c(gamma_2d[i], delta_2d[j]), data)   } } #> Error: object 'gamma_2d' not found  # Confidence region levels max_ll_gd <- max(ll_surface_gd, na.rm = TRUE) #> Error: object 'll_surface_gd' not found levels_90_gd <- max_ll_gd - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_gd' not found levels_95_gd <- max_ll_gd - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_gd' not found levels_99_gd <- max_ll_gd - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_gd' not found  # Plot contour  contour(gamma_2d, delta_2d, ll_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"2D Log-Likelihood: Gamma vs Delta\",         levels = seq(min(ll_surface_gd, na.rm = TRUE), max_ll_gd, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'gamma_2d' not found  contour(gamma_2d, delta_2d, ll_surface_gd,         levels = c(levels_90_gd, levels_95_gd, levels_99_gd),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'gamma_2d' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"Computes negative log-likelihood function Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), given vector observations. distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\lambda = 1\\). function typically used maximum likelihood estimation via numerical optimization.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"","code":"llbkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"par numeric vector length 4 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns Inf parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"Beta-Kumaraswamy (BKw) distribution GKw distribution (dgkw) \\(\\lambda=1\\). probability density function (PDF) : $$ f(x | \\theta) = \\frac{\\alpha \\beta}{B(\\gamma, \\delta+1)} x^{\\alpha - 1} \\bigl(1 - x^\\alpha\\bigr)^{\\beta(\\delta+1) - 1} \\bigl[1 - \\bigl(1 - x^\\alpha\\bigr)^\\beta\\bigr]^{\\gamma - 1} $$ \\(0 < x < 1\\), \\(\\theta = (\\alpha, \\beta, \\gamma, \\delta)\\), \\(B(,b)\\) Beta function (beta). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) \\(\\sum_{=1}^n \\ln f(x_i | \\theta)\\): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\alpha) + \\ln(\\beta) - \\ln B(\\gamma, \\delta+1)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta(\\delta+1)-1)\\ln(v_i) + (\\gamma-1)\\ln(w_i)] $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) function computes returns negative log-likelihood, \\(-\\ell(\\theta|\\mathbf{x})\\), suitable minimization using optimization routines like optim. Numerical stability maintained similarly llgkw.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood for Beta-Kumaraswamy (BKw) Distribution ‚Äî llbkw","text":"","code":"# \\donttest{ ## Example 1: Basic Log-Likelihood Evaluation # Generate sample data set.seed(2203) n <- 1000 true_params <- c(alpha = 2.0, beta = 1.5, gamma = 1.5, delta = 0.5) data <- rbkw(n, alpha = true_params[1], beta = true_params[2],              gamma = true_params[3], delta = true_params[4]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate negative log-likelihood at true parameters nll_true <- llbkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Negative log-likelihood at true parameters:\", nll_true, \"\\n\") #> Error: object 'nll_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 1.0, 1.0, 0.3),   c(2.0, 1.5, 1.5, 0.5),   c(2.5, 2.0, 2.0, 0.7) )  nll_values <- apply(test_params, 1, function(p) llbkw(p, data)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Gamma = test_params[, 3],   Delta = test_params[, 4],   NegLogLik = nll_values ) #> Error: object 'nll_values' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Maximum Likelihood Estimation  # Optimization using BFGS with no analytical gradient fit <- optim(   par = c(0.5, 1, 1.1, 0.3),   fn = llbkw,   # gr = grbkw,   data = data,   method = \"BFGS\",   control = list(maxit = 2000),   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in (function (par) fn(par, ...))(c(0.5, 1, 1.1, 0.3)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"gamma\", \"delta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(\"\\nNegative log-likelihood at MLE:\", fit$value, \"\\n\") #> Error: object 'fit' not found cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> Error: object 'fit' not found cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> Error: object 'fit' not found   ## Example 3: Comparing Optimization Methods  methods <- c(\"BFGS\", \"L-BFGS-B\", \"Nelder-Mead\", \"CG\") start_params <- c(1.8, 1.2, 1.1, 0.3)  comparison <- data.frame(   Method = character(),   Alpha = numeric(),   Beta = numeric(),   Gamma = numeric(),   Delta = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method %in% c(\"BFGS\", \"CG\")) {     fit_temp <- optim(       par = start_params,       fn = llbkw,       gr = grbkw,       data = data,       method = method     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llbkw,       gr = grbkw,       data = data,       method = method,       lower = c(0.01, 0.01, 0.01, 0.01),       upper = c(100, 100, 100, 100)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llbkw,       data = data,       method = method     )   }    comparison <- rbind(comparison, data.frame(     Method = method,     Alpha = fit_temp$par[1],     Beta = fit_temp$par[2],     Gamma = fit_temp$par[3],     Delta = fit_temp$par[4],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llbkw, gr = grbkw, data = data,     method = method): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Alpha       Beta        Gamma       Delta       NegLogLik   #> [7] Convergence #> <0 rows> (or 0-length row.names)   ## Example 4: Likelihood Ratio Test  # Test H0: delta = 0.5 vs H1: delta free loglik_full <- -fit$value #> Error: object 'fit' not found  restricted_ll <- function(params_restricted, data, delta_fixed) {   llbkw(par = c(params_restricted[1], params_restricted[2],                 params_restricted[3], delta_fixed), data = data) }  fit_restricted <- optim(   par = mle[1:3],   fn = restricted_ll,   data = data,   delta_fixed = 0.5,   method = \"Nelder-Mead\" ) #> Error: object 'mle' not found  loglik_restricted <- -fit_restricted$value #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 5: Univariate Profile Likelihoods  # Profile for alpha alpha_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 50) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found profile_ll_alpha <- numeric(length(alpha_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   profile_fit <- optim(     par = mle[-1],     fn = function(p) llbkw(c(alpha_grid[i], p), data),     method = \"Nelder-Mead\"   )   profile_ll_alpha[i] <- -profile_fit$value } #> Error: object 'alpha_grid' not found  # Profile for beta beta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 50) #> Error: object 'mle' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found profile_ll_beta <- numeric(length(beta_grid)) #> Error: object 'beta_grid' not found  for (i in seq_along(beta_grid)) {   profile_fit <- optim(     par = c(mle[1], mle[3], mle[4]),     fn = function(p) llbkw(c(mle[1], beta_grid[i], p[1], p[2]), data),     method = \"Nelder-Mead\"   )   profile_ll_beta[i] <- -profile_fit$value } #> Error: object 'beta_grid' not found  # Profile for gamma gamma_grid <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = 50) #> Error: object 'mle' not found gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found profile_ll_gamma <- numeric(length(gamma_grid)) #> Error: object 'gamma_grid' not found  for (i in seq_along(gamma_grid)) {   profile_fit <- optim(     par = c(mle[1], mle[2], mle[4]),     fn = function(p) llbkw(c(p[1], mle[2], gamma_grid[i], p[2]), data),     method = \"Nelder-Mead\"   )   profile_ll_gamma[i] <- -profile_fit$value } #> Error: object 'gamma_grid' not found  # Profile for delta delta_grid <- seq(mle[4] - 1.5, mle[4] + 1.5, length.out = 50) #> Error: object 'mle' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found profile_ll_delta <- numeric(length(delta_grid)) #> Error: object 'delta_grid' not found  for (i in seq_along(delta_grid)) {   profile_fit <- optim(     par = mle[-4],     fn = function(p) llbkw(c(p[1], p[2], p[3], delta_grid[i]), data),     method = \"Nelder-Mead\"   )   profile_ll_delta[i] <- -profile_fit$value } #> Error: object 'delta_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_alpha) - chi_crit / 2 #> Error: object 'profile_ll_alpha' not found  # Plot all profiles  plot(alpha_grid, profile_ll_alpha, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", alpha)), las = 1) #> Error: object 'alpha_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(beta_grid, profile_ll_beta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", beta)), las = 1) #> Error: object 'beta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(gamma_grid, profile_ll_gamma, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", gamma)), las = 1) #> Error: object 'gamma_grid' not found abline(v = mle[3], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[3], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(delta_grid, profile_ll_delta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", delta)), las = 1) #> Error: object 'delta_grid' not found abline(v = mle[4], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[4], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: 2D Log-Likelihood Surfaces (Selected pairs)  # Create 2D grids with wider range (¬±1.5) alpha_2d <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found beta_2d <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found gamma_2d <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found delta_2d <- seq(mle[4] - 1.5, mle[4] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found  alpha_2d <- alpha_2d[alpha_2d > 0] #> Error: object 'alpha_2d' not found beta_2d <- beta_2d[beta_2d > 0] #> Error: object 'beta_2d' not found gamma_2d <- gamma_2d[gamma_2d > 0] #> Error: object 'gamma_2d' not found delta_2d <- delta_2d[delta_2d > 0] #> Error: object 'delta_2d' not found  # Compute selected log-likelihood surfaces ll_surface_ab <- matrix(NA, nrow = length(alpha_2d), ncol = length(beta_2d)) #> Error: object 'alpha_2d' not found ll_surface_ag <- matrix(NA, nrow = length(alpha_2d), ncol = length(gamma_2d)) #> Error: object 'alpha_2d' not found ll_surface_bd <- matrix(NA, nrow = length(beta_2d), ncol = length(delta_2d)) #> Error: object 'beta_2d' not found  # Alpha vs Beta for (i in seq_along(alpha_2d)) {   for (j in seq_along(beta_2d)) {     ll_surface_ab[i, j] <- -llbkw(c(alpha_2d[i], beta_2d[j], mle[3], mle[4]), data)   } } #> Error: object 'alpha_2d' not found  # Alpha vs Gamma for (i in seq_along(alpha_2d)) {   for (j in seq_along(gamma_2d)) {     ll_surface_ag[i, j] <- -llbkw(c(alpha_2d[i], mle[2], gamma_2d[j], mle[4]), data)   } } #> Error: object 'alpha_2d' not found  # Beta vs Delta for (i in seq_along(beta_2d)) {   for (j in seq_along(delta_2d)) {     ll_surface_bd[i, j] <- -llbkw(c(mle[1], beta_2d[i], mle[3], delta_2d[j]), data)   } } #> Error: object 'beta_2d' not found  # Confidence region levels max_ll_ab <- max(ll_surface_ab, na.rm = TRUE) #> Error: object 'll_surface_ab' not found max_ll_ag <- max(ll_surface_ag, na.rm = TRUE) #> Error: object 'll_surface_ag' not found max_ll_bd <- max(ll_surface_bd, na.rm = TRUE) #> Error: object 'll_surface_bd' not found  levels_95_ab <- max_ll_ab - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_ab' not found levels_95_ag <- max_ll_ag - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_ag' not found levels_95_bd <- max_ll_bd - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_bd' not found  # Plot selected surfaces   # Alpha vs Beta contour(alpha_2d, beta_2d, ll_surface_ab,         xlab = expression(alpha), ylab = expression(beta),         main = \"Alpha vs Beta\", las = 1,         levels = seq(min(ll_surface_ab, na.rm = TRUE), max_ll_ab, length.out = 20),         col = \"#2E4057\", lwd = 1) #> Error: object 'alpha_2d' not found contour(alpha_2d, beta_2d, ll_surface_ab,         levels = levels_95_ab, col = \"#FF6347\", lwd = 2.5, lty = 1, add = TRUE) #> Error: object 'alpha_2d' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Alpha vs Gamma contour(alpha_2d, gamma_2d, ll_surface_ag,         xlab = expression(alpha), ylab = expression(gamma),         main = \"Alpha vs Gamma\", las = 1,         levels = seq(min(ll_surface_ag, na.rm = TRUE), max_ll_ag, length.out = 20),         col = \"#2E4057\", lwd = 1) #> Error: object 'alpha_2d' not found contour(alpha_2d, gamma_2d, ll_surface_ag,         levels = levels_95_ag, col = \"#FF6347\", lwd = 2.5, lty = 1, add = TRUE) #> Error: object 'alpha_2d' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Beta vs Delta contour(beta_2d, delta_2d, ll_surface_bd,         xlab = expression(beta), ylab = expression(delta),         main = \"Beta vs Delta\", las = 1,         levels = seq(min(ll_surface_bd, na.rm = TRUE), max_ll_bd, length.out = 20),         col = \"#2E4057\", lwd = 1) #> Error: object 'beta_2d' not found contour(beta_2d, delta_2d, ll_surface_bd,         levels = levels_95_bd, col = \"#FF6347\", lwd = 2.5, lty = 1, add = TRUE) #> Error: object 'beta_2d' not found points(mle[2], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FF6347\"),        pch = c(19, 17, NA),        lty = c(NA, NA, 1),        lwd = c(NA, NA, 2.5),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"Computes negative log-likelihood function Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)), given vector observations. distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\) \\(\\delta = 0\\). function suitable maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"","code":"llekw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"par numeric vector length 3 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns Inf parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"Exponentiated Kumaraswamy (EKw) distribution GKw distribution (dekw) \\(\\gamma=1\\) \\(\\delta=0\\). probability density function (PDF) : $$ f(x | \\theta) = \\lambda \\alpha \\beta x^{\\alpha-1} (1 - x^\\alpha)^{\\beta-1} \\bigl[1 - (1 - x^\\alpha)^\\beta \\bigr]^{\\lambda - 1} $$ \\(0 < x < 1\\) \\(\\theta = (\\alpha, \\beta, \\lambda)\\). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) \\(\\sum_{=1}^n \\ln f(x_i | \\theta)\\): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\lambda) + \\ln(\\alpha) + \\ln(\\beta)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta-1)\\ln(v_i) + (\\lambda-1)\\ln(w_i)] $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) function computes returns negative log-likelihood, \\(-\\ell(\\theta|\\mathbf{x})\\), suitable minimization using optimization routines like optim. Numerical stability maintained similarly llgkw.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî llekw","text":"","code":"# \\donttest{ ## Example 1: Basic Log-Likelihood Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5, lambda = 2.0) data <- rekw(n, alpha = true_params[1], beta = true_params[2],              lambda = true_params[3]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate negative log-likelihood at true parameters nll_true <- llekw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Negative log-likelihood at true parameters:\", nll_true, \"\\n\") #> Error: object 'nll_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(2.0, 3.0, 1.5),   c(2.5, 3.5, 2.0),   c(3.0, 4.0, 2.5) )  nll_values <- apply(test_params, 1, function(p) llekw(p, data)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Lambda = test_params[, 3],   NegLogLik = nll_values ) #> Error: object 'nll_values' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Maximum Likelihood Estimation  # Optimization using BFGS with analytical gradient fit <- optim(   par = c(2, 3, 1.5),   fn = llekw,   gr = grekw,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(2, 3, 1.5), fn = llekw, gr = grekw, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"lambda\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(\"\\nNegative log-likelihood at MLE:\", fit$value, \"\\n\") #> Error: object 'fit' not found cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> Error: object 'fit' not found cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> Error: object 'fit' not found   ## Example 3: Comparing Optimization Methods  methods <- c(\"BFGS\", \"L-BFGS-B\", \"Nelder-Mead\", \"CG\") start_params <- c(2, 3, 1.5)  comparison <- data.frame(   Method = character(),   Alpha = numeric(),   Beta = numeric(),   Lambda = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method %in% c(\"BFGS\", \"CG\")) {     fit_temp <- optim(       par = start_params,       fn = llekw,       gr = grekw,       data = data,       method = method     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llekw,       gr = grekw,       data = data,       method = method,       lower = c(0.01, 0.01, 0.01),       upper = c(100, 100, 100)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llekw,       data = data,       method = method     )   }    comparison <- rbind(comparison, data.frame(     Method = method,     Alpha = fit_temp$par[1],     Beta = fit_temp$par[2],     Lambda = fit_temp$par[3],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llekw, gr = grekw, data = data,     method = method): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Alpha       Beta        Lambda      NegLogLik   Convergence #> <0 rows> (or 0-length row.names)   ## Example 4: Likelihood Ratio Test  # Test H0: lambda = 2 vs H1: lambda free loglik_full <- -fit$value #> Error: object 'fit' not found  restricted_ll <- function(params_restricted, data, lambda_fixed) {   llekw(par = c(params_restricted[1], params_restricted[2],                 lambda_fixed), data = data) }  fit_restricted <- optim(   par = c(mle[1], mle[2]),   fn = restricted_ll,   data = data,   lambda_fixed = 2,   method = \"BFGS\" ) #> Error: object 'mle' not found  loglik_restricted <- -fit_restricted$value #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 5: Univariate Profile Likelihoods  # Profile for alpha alpha_grid <- seq(mle[1] - 1, mle[1] + 1, length.out = 50) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found profile_ll_alpha <- numeric(length(alpha_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   profile_fit <- optim(     par = mle[-1],     fn = function(p) llekw(c(alpha_grid[i], p), data),     method = \"BFGS\"   )   profile_ll_alpha[i] <- -profile_fit$value } #> Error: object 'alpha_grid' not found  # Profile for beta beta_grid <- seq(mle[2] - 1, mle[2] + 1, length.out = 50) #> Error: object 'mle' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found profile_ll_beta <- numeric(length(beta_grid)) #> Error: object 'beta_grid' not found  for (i in seq_along(beta_grid)) {   profile_fit <- optim(     par = mle[-2],     fn = function(p) llekw(c(p[1], beta_grid[i], p[2]), data),     method = \"BFGS\"   )   profile_ll_beta[i] <- -profile_fit$value } #> Error: object 'beta_grid' not found  # Profile for lambda lambda_grid <- seq(mle[3] - 1, mle[3] + 1, length.out = 50) #> Error: object 'mle' not found lambda_grid <- lambda_grid[lambda_grid > 0] #> Error: object 'lambda_grid' not found profile_ll_lambda <- numeric(length(lambda_grid)) #> Error: object 'lambda_grid' not found  for (i in seq_along(lambda_grid)) {   profile_fit <- optim(     par = mle[-3],     fn = function(p) llekw(c(p[1], p[2], lambda_grid[i]), data),     method = \"BFGS\"   )   profile_ll_lambda[i] <- -profile_fit$value } #> Error: object 'lambda_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_alpha) - chi_crit / 2 #> Error: object 'profile_ll_alpha' not found  # Plot all profiles  plot(alpha_grid, profile_ll_alpha, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", alpha)), las = 1) #> Error: object 'alpha_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(beta_grid, profile_ll_beta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", beta)), las = 1) #> Error: object 'beta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(lambda_grid, profile_ll_lambda, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(lambda), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", lambda)), las = 1) #> Error: object 'lambda_grid' not found abline(v = mle[3], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[3], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: 2D Log-Likelihood Surface (Alpha vs Beta)  # Create 2D grid alpha_2d <- seq(mle[1] - 0.8, mle[1] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found beta_2d <- seq(mle[2] - 0.8, mle[2] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found alpha_2d <- alpha_2d[alpha_2d > 0] #> Error: object 'alpha_2d' not found beta_2d <- beta_2d[beta_2d > 0] #> Error: object 'beta_2d' not found  # Compute log-likelihood surface ll_surface_ab <- matrix(NA, nrow = length(alpha_2d), ncol = length(beta_2d)) #> Error: object 'alpha_2d' not found  for (i in seq_along(alpha_2d)) {   for (j in seq_along(beta_2d)) {     ll_surface_ab[i, j] <- -llekw(c(alpha_2d[i], beta_2d[j], mle[3]), data)   } } #> Error: object 'alpha_2d' not found  # Confidence region levels max_ll_ab <- max(ll_surface_ab, na.rm = TRUE) #> Error: object 'll_surface_ab' not found levels_90_ab <- max_ll_ab - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_ab' not found levels_95_ab <- max_ll_ab - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_ab' not found levels_99_ab <- max_ll_ab - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_ab' not found  # Plot contour contour(alpha_2d, beta_2d, ll_surface_ab,         xlab = expression(alpha), ylab = expression(beta),         main = \"2D Log-Likelihood: Alpha vs Beta\",         levels = seq(min(ll_surface_ab, na.rm = TRUE), max_ll_ab, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'alpha_2d' not found  contour(alpha_2d, beta_2d, ll_surface_ab,         levels = c(levels_90_ab, levels_95_ab, levels_99_ab),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'alpha_2d' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 7: 2D Log-Likelihood Surface (Alpha vs Lambda)  # Create 2D grid alpha_2d_2 <- seq(mle[1] - 0.8, mle[1] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found lambda_2d <- seq(mle[3] - 0.8, mle[3] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found alpha_2d_2 <- alpha_2d_2[alpha_2d_2 > 0] #> Error: object 'alpha_2d_2' not found lambda_2d <- lambda_2d[lambda_2d > 0] #> Error: object 'lambda_2d' not found  # Compute log-likelihood surface ll_surface_al <- matrix(NA, nrow = length(alpha_2d_2), ncol = length(lambda_2d)) #> Error: object 'alpha_2d_2' not found  for (i in seq_along(alpha_2d_2)) {   for (j in seq_along(lambda_2d)) {     ll_surface_al[i, j] <- -llekw(c(alpha_2d_2[i], mle[2], lambda_2d[j]), data)   } } #> Error: object 'alpha_2d_2' not found  # Confidence region levels max_ll_al <- max(ll_surface_al, na.rm = TRUE) #> Error: object 'll_surface_al' not found levels_90_al <- max_ll_al - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_al' not found levels_95_al <- max_ll_al - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_al' not found levels_99_al <- max_ll_al - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_al' not found  # Plot contour contour(alpha_2d_2, lambda_2d, ll_surface_al,         xlab = expression(alpha), ylab = expression(lambda),         main = \"2D Log-Likelihood: Alpha vs Lambda\",         levels = seq(min(ll_surface_al, na.rm = TRUE), max_ll_al, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'alpha_2d_2' not found  contour(alpha_2d_2, lambda_2d, ll_surface_al,         levels = c(levels_90_al, levels_95_al, levels_99_al),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'alpha_2d_2' not found  points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 8: 2D Log-Likelihood Surface (Beta vs Lambda)  # Create 2D grid beta_2d_2 <- seq(mle[2] - 0.8, mle[2] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found lambda_2d_2 <- seq(mle[3] - 0.8, mle[3] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found beta_2d_2 <- beta_2d_2[beta_2d_2 > 0] #> Error: object 'beta_2d_2' not found lambda_2d_2 <- lambda_2d_2[lambda_2d_2 > 0] #> Error: object 'lambda_2d_2' not found  # Compute log-likelihood surface ll_surface_bl <- matrix(NA, nrow = length(beta_2d_2), ncol = length(lambda_2d_2)) #> Error: object 'beta_2d_2' not found  for (i in seq_along(beta_2d_2)) {   for (j in seq_along(lambda_2d_2)) {     ll_surface_bl[i, j] <- -llekw(c(mle[1], beta_2d_2[i], lambda_2d_2[j]), data)   } } #> Error: object 'beta_2d_2' not found  # Confidence region levels max_ll_bl <- max(ll_surface_bl, na.rm = TRUE) #> Error: object 'll_surface_bl' not found levels_90_bl <- max_ll_bl - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_bl' not found levels_95_bl <- max_ll_bl - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_bl' not found levels_99_bl <- max_ll_bl - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_bl' not found  # Plot contour contour(beta_2d_2, lambda_2d_2, ll_surface_bl,         xlab = expression(beta), ylab = expression(lambda),         main = \"2D Log-Likelihood: Beta vs Lambda\",         levels = seq(min(ll_surface_bl, na.rm = TRUE), max_ll_bl, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'beta_2d_2' not found  contour(beta_2d_2, lambda_2d_2, ll_surface_bl,         levels = c(levels_90_bl, levels_95_bl, levels_99_bl),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'beta_2d_2' not found  points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"Computes negative log-likelihood function five-parameter Generalized Kumaraswamy (GKw) distribution given vector observations. function designed use optimization routines (e.g., maximum likelihood estimation).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"","code":"llgkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"par numeric vector length 5 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns large positive value (e.g., Inf) parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"probability density function (PDF) GKw distribution given dgkw. log-likelihood function \\(\\ell(\\theta)\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) : $$ \\ell(\\theta | \\mathbf{x}) = n\\ln(\\lambda\\alpha\\beta) - n\\ln B(\\gamma,\\delta+1) +   \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta-1)\\ln(v_i) + (\\gamma\\lambda-1)\\ln(w_i) + \\delta\\ln(z_i)] $$ \\(\\theta = (\\alpha, \\beta, \\gamma, \\delta, \\lambda)\\), \\(B(,b)\\) Beta function (beta), : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(z_i = 1 - w_i^{\\lambda} = 1 - [1-(1-x_i^{\\alpha})^{\\beta}]^{\\lambda}\\) function computes \\(-\\ell(\\theta|\\mathbf{x})\\). Numerical stability prioritized using: lbeta function log-Beta term. Log-transformations intermediate terms (\\(v_i, w_i, z_i\\)) use log1p appropriate handle values close 0 1 accurately. Checks invalid parameters data.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood for the Generalized Kumaraswamy Distribution ‚Äî llgkw","text":"","code":"# \\donttest{ ## Example 1: Basic Log-Likelihood Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.0, beta = 3.0, gamma = 1.5, delta = 2.0, lambda = 1.8) data <- rgkw(n, alpha = true_params[1], beta = true_params[2],              gamma = true_params[3], delta = true_params[4],              lambda = true_params[5]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate negative log-likelihood at true parameters nll_true <- llgkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Negative log-likelihood at true parameters:\", nll_true, \"\\n\") #> Error: object 'nll_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5, 1.2, 1.5, 1.5),   c(2.0, 3.0, 1.5, 2.0, 1.8),   c(2.5, 3.5, 1.8, 2.5, 2.0) )  nll_values <- apply(test_params, 1, function(p) llgkw(p, data)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Gamma = test_params[, 3],   Delta = test_params[, 4],   Lambda = test_params[, 5],   NegLogLik = nll_values ) #> Error: object 'nll_values' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Maximum Likelihood Estimation  # Optimization using BFGS with analytical gradient fit <- optim(   par = c(1.5, 2.5, 1.2, 1.5, 1.5),   fn = llgkw,   gr = grgkw,   data = data,   method = \"BFGS\",   hessian = TRUE,   control = list(maxit = 1000) ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5, 1.2, 1.5, 1.5), fn = llgkw, gr = grgkw,     data = data, method = \"BFGS\", hessian = TRUE, control = list(maxit = 1000)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(\"\\nNegative log-likelihood at MLE:\", fit$value, \"\\n\") #> Error: object 'fit' not found cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> Error: object 'fit' not found cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> Error: object 'fit' not found   ## Example 3: Comparing Optimization Methods  methods <- c(\"BFGS\", \"Nelder-Mead\") start_params <- c(1.5, 2.5, 1.2, 1.5, 1.5)  comparison <- data.frame(   Method = character(),   Alpha = numeric(),   Beta = numeric(),   Gamma = numeric(),   Delta = numeric(),   Lambda = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method == \"BFGS\") {     fit_temp <- optim(       par = start_params,       fn = llgkw,       gr = grgkw,       data = data,       method = method,       control = list(maxit = 1000)     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llgkw,       gr = grgkw,       data = data,       method = method,       lower = rep(0.001, 5),       upper = rep(20, 5),       control = list(maxit = 1000)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llgkw,       data = data,       method = method,       control = list(maxit = 1000)     )   }    comparison <- rbind(comparison, data.frame(     Method = method,     Alpha = fit_temp$par[1],     Beta = fit_temp$par[2],     Gamma = fit_temp$par[3],     Delta = fit_temp$par[4],     Lambda = fit_temp$par[5],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llgkw, gr = grgkw, data = data,     method = method, control = list(maxit = 1000)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Alpha       Beta        Gamma       Delta       Lambda      #> [7] NegLogLik   Convergence #> <0 rows> (or 0-length row.names)   ## Example 4: Likelihood Ratio Test  # Test H0: gamma = 1.5 vs H1: gamma free loglik_full <- -fit$value #> Error: object 'fit' not found  restricted_ll <- function(params_restricted, data, gamma_fixed) {   llgkw(par = c(params_restricted[1], params_restricted[2],                 gamma_fixed, params_restricted[3], params_restricted[4]),         data = data) }  fit_restricted <- optim(   par = c(mle[1], mle[2], mle[4], mle[5]),   fn = restricted_ll,   data = data,   gamma_fixed = 1.5,   method = \"Nelder-Mead\",   control = list(maxit = 1000) ) #> Error: object 'mle' not found  loglik_restricted <- -fit_restricted$value #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 5: Univariate Profile Likelihoods  # Profile for alpha xd <- 1 alpha_grid <- seq(mle[1] - xd, mle[1] + xd, length.out = 35) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found profile_ll_alpha <- numeric(length(alpha_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   profile_fit <- optim(     par = mle[-1],     fn = function(p) llgkw(c(alpha_grid[i], p), data),     method = \"Nelder-Mead\",     control = list(maxit = 500)   )   profile_ll_alpha[i] <- -profile_fit$value } #> Error: object 'alpha_grid' not found  # Profile for beta beta_grid <- seq(mle[2] - xd, mle[2] + xd, length.out = 35) #> Error: object 'mle' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found profile_ll_beta <- numeric(length(beta_grid)) #> Error: object 'beta_grid' not found  for (i in seq_along(beta_grid)) {   profile_fit <- optim(     par = mle[-2],     fn = function(p) llgkw(c(p[1], beta_grid[i], p[2], p[3], p[4]), data),     method = \"Nelder-Mead\",     control = list(maxit = 500)   )   profile_ll_beta[i] <- -profile_fit$value } #> Error: object 'beta_grid' not found  # Profile for gamma gamma_grid <- seq(mle[3] - xd, mle[3] + xd, length.out = 35) #> Error: object 'mle' not found gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found profile_ll_gamma <- numeric(length(gamma_grid)) #> Error: object 'gamma_grid' not found  for (i in seq_along(gamma_grid)) {   profile_fit <- optim(     par = mle[-3],     fn = function(p) llgkw(c(p[1], p[2], gamma_grid[i], p[3], p[4]), data),     method = \"Nelder-Mead\",     control = list(maxit = 500)   )   profile_ll_gamma[i] <- -profile_fit$value } #> Error: object 'gamma_grid' not found  # Profile for delta delta_grid <- seq(mle[4] - xd, mle[4] + xd, length.out = 35) #> Error: object 'mle' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found profile_ll_delta <- numeric(length(delta_grid)) #> Error: object 'delta_grid' not found  for (i in seq_along(delta_grid)) {   profile_fit <- optim(     par = mle[-4],     fn = function(p) llgkw(c(p[1], p[2], p[3], delta_grid[i], p[4]), data),     method = \"Nelder-Mead\",     control = list(maxit = 500)   )   profile_ll_delta[i] <- -profile_fit$value } #> Error: object 'delta_grid' not found  # Profile for lambda lambda_grid <- seq(mle[5] - xd, mle[5] + xd, length.out = 35) #> Error: object 'mle' not found lambda_grid <- lambda_grid[lambda_grid > 0] #> Error: object 'lambda_grid' not found profile_ll_lambda <- numeric(length(lambda_grid)) #> Error: object 'lambda_grid' not found  for (i in seq_along(lambda_grid)) {   profile_fit <- optim(     par = mle[-5],     fn = function(p) llgkw(c(p[1], p[2], p[3], p[4], lambda_grid[i]), data),     method = \"Nelder-Mead\",     control = list(maxit = 500)   )   profile_ll_lambda[i] <- -profile_fit$value } #> Error: object 'lambda_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_alpha) - chi_crit / 2 #> Error: object 'profile_ll_alpha' not found  # Plot all profiles  plot(alpha_grid, profile_ll_alpha, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", alpha)), las = 1) #> Error: object 'alpha_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.6) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(beta_grid, profile_ll_beta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", beta)), las = 1) #> Error: object 'beta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.6) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(gamma_grid, profile_ll_gamma, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", gamma)), las = 1) #> Error: object 'gamma_grid' not found abline(v = mle[3], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[3], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.6) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(delta_grid, profile_ll_delta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", delta)), las = 1) #> Error: object 'delta_grid' not found abline(v = mle[4], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[4], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.6) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(lambda_grid, profile_ll_lambda, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(lambda), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", lambda)), las = 1) #> Error: object 'lambda_grid' not found abline(v = mle[5], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[5], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.6) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 6: 2D Log-Likelihood Surface (Alpha vs Beta) # Plot all profiles  # Create 2D grid alpha_2d <- seq(mle[1] - xd, mle[1] + xd, length.out = round(n/4)) #> Error: object 'mle' not found beta_2d <- seq(mle[2] - xd, mle[2] + xd, length.out = round(n/4)) #> Error: object 'mle' not found alpha_2d <- alpha_2d[alpha_2d > 0] #> Error: object 'alpha_2d' not found beta_2d <- beta_2d[beta_2d > 0] #> Error: object 'beta_2d' not found  # Compute log-likelihood surface ll_surface_ab <- matrix(NA, nrow = length(alpha_2d), ncol = length(beta_2d)) #> Error: object 'alpha_2d' not found  for (i in seq_along(alpha_2d)) {   for (j in seq_along(beta_2d)) {     ll_surface_ab[i, j] <- llgkw(c(alpha_2d[i], beta_2d[j],                                      mle[3], mle[4], mle[5]), data)   } } #> Error: object 'alpha_2d' not found  # Confidence region levels max_ll_ab <- max(ll_surface_ab, na.rm = TRUE) #> Error: object 'll_surface_ab' not found levels_90_ab <- max_ll_ab - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_ab' not found levels_95_ab <- max_ll_ab - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_ab' not found levels_99_ab <- max_ll_ab - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_ab' not found  # Plot contour contour(alpha_2d, beta_2d, ll_surface_ab,         xlab = expression(alpha), ylab = expression(beta),         main = \"2D Log-Likelihood: Alpha vs Beta\",         levels = seq(min(ll_surface_ab, na.rm = TRUE), max_ll_ab, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'alpha_2d' not found  contour(alpha_2d, beta_2d, ll_surface_ab,         levels = c(levels_90_ab, levels_95_ab, levels_99_ab),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'alpha_2d' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 7: 2D Log-Likelihood Surface (Gamma vs Delta)  # Create 2D grid gamma_2d <- seq(mle[3] - xd, mle[3] + xd, length.out = round(n/4)) #> Error: object 'mle' not found delta_2d <- seq(mle[4] - xd, mle[4] + xd, length.out = round(n/4)) #> Error: object 'mle' not found gamma_2d <- gamma_2d[gamma_2d > 0] #> Error: object 'gamma_2d' not found delta_2d <- delta_2d[delta_2d > 0] #> Error: object 'delta_2d' not found  # Compute log-likelihood surface ll_surface_gd <- matrix(NA, nrow = length(gamma_2d), ncol = length(delta_2d)) #> Error: object 'gamma_2d' not found  for (i in seq_along(gamma_2d)) {   for (j in seq_along(delta_2d)) {     ll_surface_gd[i, j] <- -llgkw(c(mle[1], mle[2], gamma_2d[i],                                      delta_2d[j], mle[5]), data)   } } #> Error: object 'gamma_2d' not found  # Confidence region levels max_ll_gd <- max(ll_surface_gd, na.rm = TRUE) #> Error: object 'll_surface_gd' not found levels_90_gd <- max_ll_gd - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_gd' not found levels_95_gd <- max_ll_gd - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_gd' not found levels_99_gd <- max_ll_gd - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_gd' not found  # Plot contour contour(gamma_2d, delta_2d, ll_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"2D Log-Likelihood: Gamma vs Delta\",         levels = seq(min(ll_surface_gd, na.rm = TRUE), max_ll_gd, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'gamma_2d' not found  contour(gamma_2d, delta_2d, ll_surface_gd,         levels = c(levels_90_gd, levels_95_gd, levels_99_gd),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'gamma_2d' not found  points(mle[3], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[3], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 8: 2D Log-Likelihood Surface (Delta vs Lambda)  # Create 2D grid delta_2d_2 <- seq(mle[4] - xd, mle[4] + xd, length.out = round(n/30)) #> Error: object 'mle' not found lambda_2d <- seq(mle[5] - xd, mle[5] + xd, length.out = round(n/30)) #> Error: object 'mle' not found delta_2d_2 <- delta_2d_2[delta_2d_2 > 0] #> Error: object 'delta_2d_2' not found lambda_2d <- lambda_2d[lambda_2d > 0] #> Error: object 'lambda_2d' not found  # Compute log-likelihood surface ll_surface_dl <- matrix(NA, nrow = length(delta_2d_2), ncol = length(lambda_2d)) #> Error: object 'delta_2d_2' not found  for (i in seq_along(delta_2d_2)) {   for (j in seq_along(lambda_2d)) {     ll_surface_dl[i, j] <- -llgkw(c(mle[1], mle[2], mle[3],                                      delta_2d_2[i], lambda_2d[j]), data)   } } #> Error: object 'delta_2d_2' not found  # Confidence region levels max_ll_dl <- max(ll_surface_dl, na.rm = TRUE) #> Error: object 'll_surface_dl' not found levels_90_dl <- max_ll_dl - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll_dl' not found levels_95_dl <- max_ll_dl - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_dl' not found levels_99_dl <- max_ll_dl - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll_dl' not found  # Plot contour contour(delta_2d_2, lambda_2d, ll_surface_dl,         xlab = expression(delta), ylab = expression(lambda),         main = \"2D Log-Likelihood: Delta vs Lambda\",         levels = seq(min(ll_surface_dl, na.rm = TRUE), max_ll_dl, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'delta_2d_2' not found  contour(delta_2d_2, lambda_2d, ll_surface_dl,         levels = c(levels_90_dl, levels_95_dl, levels_99_dl),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'delta_2d_2' not found  points(mle[4], mle[5], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[4], true_params[5], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"Computes negative log-likelihood function Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)), given vector observations. distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"","code":"llkkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"par numeric vector length 4 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns Inf parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"kkw distribution GKw distribution (dgkw) \\(\\gamma=1\\). probability density function (PDF) : $$ f(x | \\theta) = (\\delta + 1) \\lambda \\alpha \\beta x^{\\alpha - 1} (1 - x^\\alpha)^{\\beta - 1} \\bigl[1 - (1 - x^\\alpha)^\\beta\\bigr]^{\\lambda - 1} \\bigl\\{1 - \\bigl[1 - (1 - x^\\alpha)^\\beta\\bigr]^\\lambda\\bigr\\}^{\\delta} $$ \\(0 < x < 1\\) \\(\\theta = (\\alpha, \\beta, \\delta, \\lambda)\\). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) \\(\\sum_{=1}^n \\ln f(x_i | \\theta)\\): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\delta+1) + \\ln(\\lambda) + \\ln(\\alpha) + \\ln(\\beta)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta-1)\\ln(v_i) + (\\lambda-1)\\ln(w_i) + \\delta\\ln(z_i)] $$ : \\(v_i = 1 - x_i^{\\alpha}\\) \\(w_i = 1 - v_i^{\\beta} = 1 - (1-x_i^{\\alpha})^{\\beta}\\) \\(z_i = 1 - w_i^{\\lambda} = 1 - [1-(1-x_i^{\\alpha})^{\\beta}]^{\\lambda}\\) function computes returns negative log-likelihood, \\(-\\ell(\\theta|\\mathbf{x})\\), suitable minimization using optimization routines like optim. Numerical stability maintained similarly llgkw.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood for the kkw Distribution ‚Äî llkkw","text":"","code":"# \\donttest{ ## Example 1: Basic Log-Likelihood Evaluation  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.0, beta = 3.0, delta = 1.5, lambda = 2.0) data <- rkkw(n, alpha = true_params[1], beta = true_params[2],              delta = true_params[3], lambda = true_params[4]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate negative log-likelihood at true parameters nll_true <- llkkw(par = true_params, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Negative log-likelihood at true parameters:\", nll_true, \"\\n\") #> Error: object 'nll_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.5, 1.0, 1.5),   c(2.0, 3.0, 1.5, 2.0),   c(2.5, 3.5, 2.0, 2.5) )  nll_values <- apply(test_params, 1, function(p) llkkw(p, data)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt results <- data.frame(   Alpha = test_params[, 1],   Beta = test_params[, 2],   Delta = test_params[, 3],   Lambda = test_params[, 4],   NegLogLik = nll_values ) #> Error: object 'nll_values' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Maximum Likelihood Estimation  # Optimization using BFGS with analytical gradient fit <- optim(   par = c(1.5, 2.5, 1.0, 1.5),   fn = llkkw,   gr = grkkw,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2.5, 1, 1.5), fn = llkkw, gr = grkkw, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\", \"delta\", \"lambda\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  results <- data.frame(   Parameter = c(\"alpha\", \"beta\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(\"\\nNegative log-likelihood at MLE:\", fit$value, \"\\n\") #> Error: object 'fit' not found cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> Error: object 'fit' not found cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> Error: object 'fit' not found   ## Example 3: Comparing Optimization Methods  methods <- c(\"BFGS\", \"L-BFGS-B\", \"Nelder-Mead\", \"CG\") start_params <- c(1.5, 2.5, 1.0, 1.5)  comparison <- data.frame(   Method = character(),   Alpha = numeric(),   Beta = numeric(),   Delta = numeric(),   Lambda = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method %in% c(\"BFGS\", \"CG\")) {     fit_temp <- optim(       par = start_params,       fn = llkkw,       gr = grkkw,       data = data,       method = method     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llkkw,       gr = grkkw,       data = data,       method = method,       lower = c(0.01, 0.01, 0.01, 0.01),       upper = c(100, 100, 100, 100)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llkkw,       data = data,       method = method     )   }      comparison <- rbind(comparison, data.frame(     Method = method,     Alpha = fit_temp$par[1],     Beta = fit_temp$par[2],     Delta = fit_temp$par[3],     Lambda = fit_temp$par[4],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llkkw, gr = grkkw, data = data,     method = method): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Alpha       Beta        Delta       Lambda      NegLogLik   #> [7] Convergence #> <0 rows> (or 0-length row.names)   ## Example 4: Likelihood Ratio Test  # Test H0: delta = 1.5 vs H1: delta free loglik_full <- -fit$value #> Error: object 'fit' not found  restricted_ll <- function(params_restricted, data, delta_fixed) {   llkkw(par = c(params_restricted[1], params_restricted[2],                 delta_fixed, params_restricted[3]), data = data) }  fit_restricted <- optim(   par = c(mle[1], mle[2], mle[4]),   fn = restricted_ll,   data = data,   delta_fixed = 1.5,   method = \"BFGS\" ) #> Error: object 'mle' not found  loglik_restricted <- -fit_restricted$value #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 5: Univariate Profile Likelihoods  # Profile for alpha alpha_grid <- seq(mle[1] - 1, mle[1] + 1, length.out = 40) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found profile_ll_alpha <- numeric(length(alpha_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   profile_fit <- optim(     par = mle[-1],     fn = function(p) llkkw(c(alpha_grid[i], p), data),     method = \"Nelder-Mead\"   )   profile_ll_alpha[i] <- -profile_fit$value } #> Error: object 'alpha_grid' not found  # Profile for beta beta_grid <- seq(mle[2] - 1, mle[2] + 1, length.out = 40) #> Error: object 'mle' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found profile_ll_beta <- numeric(length(beta_grid)) #> Error: object 'beta_grid' not found  for (i in seq_along(beta_grid)) {   profile_fit <- optim(     par = mle[-2],     fn = function(p) llkkw(c(p[1], beta_grid[i], p[2], p[3]), data),     method = \"Nelder-Mead\"   )   profile_ll_beta[i] <- -profile_fit$value } #> Error: object 'beta_grid' not found  # Profile for delta delta_grid <- seq(mle[3] - 0.8, mle[3] + 0.8, length.out = 40) #> Error: object 'mle' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found profile_ll_delta <- numeric(length(delta_grid)) #> Error: object 'delta_grid' not found  for (i in seq_along(delta_grid)) {   profile_fit <- optim(     par = mle[-3],     fn = function(p) llkkw(c(p[1], p[2], delta_grid[i], p[3]), data),     method = \"Nelder-Mead\"   )   profile_ll_delta[i] <- -profile_fit$value } #> Error: object 'delta_grid' not found  # Profile for lambda lambda_grid <- seq(mle[4] - 1, mle[4] + 1, length.out = 40) #> Error: object 'mle' not found lambda_grid <- lambda_grid[lambda_grid > 0] #> Error: object 'lambda_grid' not found profile_ll_lambda <- numeric(length(lambda_grid)) #> Error: object 'lambda_grid' not found  for (i in seq_along(lambda_grid)) {   profile_fit <- optim(     par = mle[-4],     fn = function(p) llkkw(c(p[1], p[2], p[3], lambda_grid[i]), data),     method = \"Nelder-Mead\"   )   profile_ll_lambda[i] <- -profile_fit$value } #> Error: object 'lambda_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_alpha) - chi_crit / 2 #> Error: object 'profile_ll_alpha' not found  # Plot all profiles  plot(alpha_grid, profile_ll_alpha, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", alpha)), las = 1) #> Error: object 'alpha_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.7) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(beta_grid, profile_ll_beta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", beta)), las = 1) #> Error: object 'beta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.7) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(delta_grid, profile_ll_delta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", delta)), las = 1) #> Error: object 'delta_grid' not found abline(v = mle[3], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[3], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.7) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(lambda_grid, profile_ll_lambda, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(lambda), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", lambda)), las = 1) #> Error: object 'lambda_grid' not found abline(v = mle[4], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[4], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.7) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 6: 2D Log-Likelihood Surface (Alpha vs Beta)  # Create 2D grid alpha_2d <- seq(mle[1] - 0.8, mle[1] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found beta_2d <- seq(mle[2] - 0.8, mle[2] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found alpha_2d <- alpha_2d[alpha_2d > 0] #> Error: object 'alpha_2d' not found beta_2d <- beta_2d[beta_2d > 0] #> Error: object 'beta_2d' not found  # Compute log-likelihood surface ll_surface <- matrix(NA, nrow = length(alpha_2d), ncol = length(beta_2d)) #> Error: object 'alpha_2d' not found  for (i in seq_along(alpha_2d)) {   for (j in seq_along(beta_2d)) {     ll_surface[i, j] <- -llkkw(c(alpha_2d[i], beta_2d[j], mle[3], mle[4]), data)   } } #> Error: object 'alpha_2d' not found  # Confidence region levels max_ll <- max(ll_surface, na.rm = TRUE) #> Error: object 'll_surface' not found levels_90 <- max_ll - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll' not found levels_95 <- max_ll - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll' not found levels_99 <- max_ll - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll' not found  # Plot contour contour(alpha_2d, beta_2d, ll_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"2D Log-Likelihood: Alpha vs Beta\",         levels = seq(min(ll_surface, na.rm = TRUE), max_ll, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'alpha_2d' not found  contour(alpha_2d, beta_2d, ll_surface,         levels = c(levels_90, levels_95, levels_99),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'alpha_2d' not found  points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet   ## Example 7: 2D Log-Likelihood Surface (Delta vs Lambda)  # Create 2D grid delta_2d <- seq(mle[3] - 0.6, mle[3] + 0.6, length.out = round(n/25)) #> Error: object 'mle' not found lambda_2d <- seq(mle[4] - 0.8, mle[4] + 0.8, length.out = round(n/25)) #> Error: object 'mle' not found delta_2d <- delta_2d[delta_2d > 0] #> Error: object 'delta_2d' not found lambda_2d <- lambda_2d[lambda_2d > 0] #> Error: object 'lambda_2d' not found  # Compute log-likelihood surface ll_surface2 <- matrix(NA, nrow = length(delta_2d), ncol = length(lambda_2d)) #> Error: object 'delta_2d' not found  for (i in seq_along(delta_2d)) {   for (j in seq_along(lambda_2d)) {     ll_surface2[i, j] <- -llkkw(c(mle[1], mle[2], delta_2d[i], lambda_2d[j]), data)   } } #> Error: object 'delta_2d' not found  # Confidence region levels max_ll2 <- max(ll_surface2, na.rm = TRUE) #> Error: object 'll_surface2' not found levels2_90 <- max_ll2 - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll2' not found levels2_95 <- max_ll2 - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll2' not found levels2_99 <- max_ll2 - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll2' not found  # Plot contour contour(delta_2d, lambda_2d, ll_surface2,         xlab = expression(delta), ylab = expression(lambda),         main = \"2D Log-Likelihood: Delta vs Lambda\",         levels = seq(min(ll_surface2, na.rm = TRUE), max_ll2, length.out = 20),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'delta_2d' not found  contour(delta_2d, lambda_2d, ll_surface2,         levels = c(levels2_90, levels2_95, levels2_99),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'delta_2d' not found  points(mle[3], mle[4], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[3], true_params[4], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"Computes negative log-likelihood function two-parameter Kumaraswamy (Kw) distribution parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)), given vector observations. function suitable maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"","code":"llkw(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"par numeric vector length 2 containing distribution parameters order: alpha (\\(\\alpha > 0\\)), beta (\\(\\beta > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns Inf parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"Kumaraswamy (Kw) distribution's probability density function (PDF) (see dkw): $$ f(x | \\theta) = \\alpha \\beta x^{\\alpha-1} (1 - x^\\alpha)^{\\beta-1} $$ \\(0 < x < 1\\) \\(\\theta = (\\alpha, \\beta)\\). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) \\(\\sum_{=1}^n \\ln f(x_i | \\theta)\\): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\alpha) + \\ln(\\beta)] + \\sum_{=1}^{n} [(\\alpha-1)\\ln(x_i) + (\\beta-1)\\ln(v_i)] $$ \\(v_i = 1 - x_i^{\\alpha}\\). function computes returns negative log-likelihood, \\(-\\ell(\\theta|\\mathbf{x})\\), suitable minimization using optimization routines like optim. equivalent negative log-likelihood GKw distribution (llgkw) evaluated \\(\\gamma=1, \\delta=0, \\lambda=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood of the Kumaraswamy (Kw) Distribution ‚Äî llkw","text":"","code":"# \\donttest{ ## Example 1: Maximum Likelihood Estimation with Analytical Gradient  # Generate sample data set.seed(123) n <- 1000 true_params <- c(alpha = 2.5, beta = 3.5) data <- rkw(n, alpha = true_params[1], beta = true_params[2]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Optimization using BFGS with analytical gradient fit <- optim(   par = c(2, 2),   fn = llkw,   gr = grkw,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(2, 2), fn = llkw, gr = grkw, data = data, method = \"BFGS\",     hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Extract results mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"alpha\", \"beta\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found ci_lower <- mle - 1.96 * se #> Error: object 'mle' not found ci_upper <- mle + 1.96 * se #> Error: object 'mle' not found  # Summary table results <- data.frame(   Parameter = c(\"alpha\", \"beta\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = ci_lower,   CI_Upper = ci_upper ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  ## Example 2: Verifying Gradient at MLE  # At MLE, gradient should be approximately zero gradient_at_mle <- grkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(gradient_at_mle) #> Error: object 'gradient_at_mle' not found cat(\"Max absolute score:\", max(abs(gradient_at_mle)), \"\\n\") #> Error: object 'gradient_at_mle' not found  ## Example 3: Checking Hessian Properties  # Hessian at MLE hessian_at_mle <- hskw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(hessian_at_mle, digits = 4) #> Error: object 'hessian_at_mle' not found  # Check positive definiteness via eigenvalues eigenvals <- eigen(hessian_at_mle, only.values = TRUE)$values #> Error: object 'hessian_at_mle' not found print(eigenvals) #> Error: object 'eigenvals' not found all(eigenvals > 0) #> Error: object 'eigenvals' not found  # Condition number cond_number <- max(eigenvals) / min(eigenvals) #> Error: object 'eigenvals' not found cat(\"Condition number:\", format(cond_number, scientific = TRUE), \"\\n\") #> Error: object 'cond_number' not found  ## Example 4: Comparing Optimization Methods  methods <- c(\"BFGS\", \"L-BFGS-B\", \"Nelder-Mead\", \"CG\") start_params <- c(2, 2)  comparison <- data.frame(   Method = character(),   Alpha_Est = numeric(),   Beta_Est = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method %in% c(\"BFGS\", \"CG\")) {     fit_temp <- optim(       par = start_params,       fn = llkw,       gr = grkw,       data = data,       method = method     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llkw,       gr = grkw,       data = data,       method = method,       lower = c(0.01, 0.01),       upper = c(100, 100)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llkw,       data = data,       method = method     )   }      comparison <- rbind(comparison, data.frame(     Method = method,     Alpha_Est = fit_temp$par[1],     Beta_Est = fit_temp$par[2],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llkw, gr = grkw, data = data,     method = method): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Alpha_Est   Beta_Est    NegLogLik   Convergence #> <0 rows> (or 0-length row.names)  ## Example 5: Likelihood Ratio Test  # Test H0: beta = 3 vs H1: beta free loglik_full <- -fit$value #> Error: object 'fit' not found  # Restricted model: fix beta = 3 restricted_ll <- function(alpha, data, beta_fixed) {   llkw(par = c(alpha, beta_fixed), data = data) }  fit_restricted <- optimize(   f = restricted_ll,   interval = c(0.1, 10),   data = data,   beta_fixed = 3,   maximum = FALSE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in f(arg, ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  loglik_restricted <- -fit_restricted$objective #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found  ## Example 6: Univariate Profile Likelihoods  # Grid for alpha alpha_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 50) #> Error: object 'mle' not found alpha_grid <- alpha_grid[alpha_grid > 0] #> Error: object 'alpha_grid' not found profile_ll_alpha <- numeric(length(alpha_grid)) #> Error: object 'alpha_grid' not found  for (i in seq_along(alpha_grid)) {   profile_fit <- optimize(     f = function(beta) llkw(c(alpha_grid[i], beta), data),     interval = c(0.1, 10),     maximum = FALSE   )   profile_ll_alpha[i] <- -profile_fit$objective } #> Error: object 'alpha_grid' not found  # Grid for beta beta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 50) #> Error: object 'mle' not found beta_grid <- beta_grid[beta_grid > 0] #> Error: object 'beta_grid' not found profile_ll_beta <- numeric(length(beta_grid)) #> Error: object 'beta_grid' not found  for (i in seq_along(beta_grid)) {   profile_fit <- optimize(     f = function(alpha) llkw(c(alpha, beta_grid[i]), data),     interval = c(0.1, 10),     maximum = FALSE   )   profile_ll_beta[i] <- -profile_fit$objective } #> Error: object 'beta_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_alpha) - chi_crit / 2 #> Error: object 'profile_ll_alpha' not found  # Plot   # Profile for alpha plot(alpha_grid, profile_ll_alpha, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile Likelihood: \", alpha)), las = 1) #> Error: object 'alpha_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Profile for beta plot(beta_grid, profile_ll_beta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile Likelihood: \", beta)), las = 1) #> Error: object 'beta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 7: 2D Profile Likelihood Surface  # Create 2D grid alpha_2d <- seq(mle[1] - 1, mle[1] + 1, length.out = round(n/4)) #> Error: object 'mle' not found beta_2d <- seq(mle[2] - 1, mle[2] + 1, length.out = round(n/4)) #> Error: object 'mle' not found alpha_2d <- alpha_2d[alpha_2d > 0] #> Error: object 'alpha_2d' not found beta_2d <- beta_2d[beta_2d > 0] #> Error: object 'beta_2d' not found  # Compute log-likelihood surface ll_surface <- matrix(NA, nrow = length(alpha_2d), ncol = length(beta_2d)) #> Error: object 'alpha_2d' not found  for (i in seq_along(alpha_2d)) {   for (j in seq_along(beta_2d)) {     ll_surface[i, j] <- -llkw(c(alpha_2d[i], beta_2d[j]), data)   } } #> Error: object 'alpha_2d' not found  # Confidence region levels max_ll <- max(ll_surface, na.rm = TRUE) #> Error: object 'll_surface' not found levels_90 <- max_ll - qchisq(0.90, df = 2) / 2 #> Error: object 'max_ll' not found levels_95 <- max_ll - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll' not found levels_99 <- max_ll - qchisq(0.99, df = 2) / 2 #> Error: object 'max_ll' not found  # Plot contour contour(alpha_2d, beta_2d, ll_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"2D Profile Log-Likelihood\",         levels = seq(min(ll_surface, na.rm = TRUE), max_ll, length.out = round(n/4)),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'alpha_2d' not found  # Add confidence region contours contour(alpha_2d, beta_2d, ll_surface,         levels = c(levels_90, levels_95, levels_99),         col = c(\"#FFA07A\", \"#FF6347\", \"#8B0000\"),         lwd = c(2, 2.5, 3), lty = c(3, 2, 1),         add = TRUE, labcex = 0.8) #> Error: object 'alpha_2d' not found  # Mark points points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"90% CR\", \"95% CR\", \"99% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FFA07A\", \"#FF6347\", \"#8B0000\"),        pch = c(19, 17, NA, NA, NA),        lty = c(NA, NA, 3, 2, 1),        lwd = c(NA, NA, 2, 2.5, 3),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 8: Combined View - Profiles with 2D Surface  # Top left: Profile for alpha plot(alpha_grid, profile_ll_alpha, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(alpha), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", alpha)), las = 1) #> Error: object 'alpha_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3) #> Error: object 'threshold' not found grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Top right: Profile for beta plot(beta_grid, profile_ll_beta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(beta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", beta)), las = 1) #> Error: object 'beta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3) #> Error: object 'threshold' not found grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Bottom left: 2D contour contour(alpha_2d, beta_2d, ll_surface,         xlab = expression(alpha), ylab = expression(beta),         main = \"2D Log-Likelihood Surface\",         levels = seq(min(ll_surface, na.rm = TRUE), max_ll, length.out = 15),         col = \"#2E4057\", las = 1, lwd = 1) #> Error: object 'alpha_2d' not found contour(alpha_2d, beta_2d, ll_surface,         levels = c(levels_95),         col = \"#8B0000\", lwd = 2.5, add = TRUE) #> Error: object 'alpha_2d' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 9: Numerical Gradient Verification  # Manual finite difference gradient numerical_gradient <- function(f, x, data, h = 1e-7) {   grad <- numeric(length(x))   for (i in seq_along(x)) {     x_plus <- x_minus <- x     x_plus[i] <- x[i] + h     x_minus[i] <- x[i] - h     grad[i] <- (f(x_plus, data) - f(x_minus, data)) / (2 * h)   }   return(grad) }  # Compare grad_analytical <- grkw(par = mle, data = data) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt grad_numerical <- numerical_gradient(llkw, mle, data) #> Error: object 'mle' not found  comparison_grad <- data.frame(   Parameter = c(\"alpha\", \"beta\"),   Analytical = grad_analytical,   Numerical = grad_numerical,   Difference = abs(grad_analytical - grad_numerical) ) #> Error: object 'grad_analytical' not found print(comparison_grad, digits = 8) #> Error: object 'comparison_grad' not found  ## Example 10: Bootstrap Confidence Intervals  n_boot <- round(n/4) boot_estimates <- matrix(NA, nrow = n_boot, ncol = 2)  set.seed(456) for (b in 1:n_boot) {   boot_data <- rkw(n, alpha = mle[1], beta = mle[2])   boot_fit <- optim(     par = mle,     fn = llkw,     gr = grkw,     data = boot_data,     method = \"BFGS\",     control = list(maxit = 500)   )   if (boot_fit$convergence == 0) {     boot_estimates[b, ] <- boot_fit$par   } } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  boot_estimates <- boot_estimates[complete.cases(boot_estimates), ] boot_ci <- apply(boot_estimates, 2, quantile, probs = c(0.025, 0.975)) colnames(boot_ci) <- c(\"alpha\", \"beta\")  print(t(boot_ci), digits = 4) #>       2.5% 97.5% #> alpha   NA    NA #> beta    NA    NA  # Plot bootstrap distributions  hist(boot_estimates[, 1], breaks = 20, col = \"#87CEEB\", border = \"white\",      main = expression(paste(\"Bootstrap: \", hat(alpha))),      xlab = expression(hat(alpha)), las = 1) #> Error in hist.default(boot_estimates[, 1], breaks = 20, col = \"#87CEEB\",     border = \"white\", main = expression(paste(\"Bootstrap: \",         hat(alpha))), xlab = expression(hat(alpha)), las = 1): 'x' must be numeric abline(v = mle[1], col = \"#8B0000\", lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lwd = 2, lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(v = boot_ci[, 1], col = \"#2E4057\", lwd = 2, lty = 3) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\"),        lwd = 2, lty = c(1, 2, 3), bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  hist(boot_estimates[, 2], breaks = 20, col = \"#FFA07A\", border = \"white\",      main = expression(paste(\"Bootstrap: \", hat(beta))),      xlab = expression(hat(beta)), las = 1) #> Error in hist.default(boot_estimates[, 2], breaks = 20, col = \"#FFA07A\",     border = \"white\", main = expression(paste(\"Bootstrap: \",         hat(beta))), xlab = expression(hat(beta)), las = 1): 'x' must be numeric abline(v = mle[2], col = \"#8B0000\", lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lwd = 2, lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(v = boot_ci[, 2], col = \"#2E4057\", lwd = 2, lty = 3) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#2E4057\"),        lwd = 2, lty = c(1, 2, 3), bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"Computes negative log-likelihood function McDonald (Mc) distribution (also known Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)), given vector observations. distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\) \\(\\beta = 1\\). function suitable maximum likelihood estimation.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"","code":"llmc(par, data)"},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"par numeric vector length 3 containing distribution parameters order: gamma (\\(\\gamma > 0\\)), delta (\\(\\delta \\ge 0\\)), lambda (\\(\\lambda > 0\\)). data numeric vector observations. values must strictly 0 1 (exclusive).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"Returns single double value representing negative log-likelihood (\\(-\\ell(\\theta|\\mathbf{x})\\)). Returns Inf parameter values par invalid according constraints, value data interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"McDonald (Mc) distribution GKw distribution (dmc) \\(\\alpha=1\\) \\(\\beta=1\\). probability density function (PDF) : $$ f(x | \\theta) = \\frac{\\lambda}{B(\\gamma,\\delta+1)} x^{\\gamma \\lambda - 1} (1 - x^\\lambda)^\\delta $$ \\(0 < x < 1\\), \\(\\theta = (\\gamma, \\delta, \\lambda)\\), \\(B(,b)\\) Beta function (beta). log-likelihood function \\(\\ell(\\theta | \\mathbf{x})\\) sample \\(\\mathbf{x} = (x_1, \\dots, x_n)\\) \\(\\sum_{=1}^n \\ln f(x_i | \\theta)\\): $$ \\ell(\\theta | \\mathbf{x}) = n[\\ln(\\lambda) - \\ln B(\\gamma, \\delta+1)] + \\sum_{=1}^{n} [(\\gamma\\lambda - 1)\\ln(x_i) + \\delta\\ln(1 - x_i^\\lambda)] $$ function computes returns negative log-likelihood, \\(-\\ell(\\theta|\\mathbf{x})\\), suitable minimization using optimization routines like optim. Numerical stability maintained, including using log-gamma function (lgamma) Beta function term.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/llmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Log-Likelihood for the McDonald (Mc)/Beta Power Distribution ‚Äî llmc","text":"","code":"# \\donttest{ ## Example 1: Basic Log-Likelihood Evaluation  # Generate sample data with more stable parameters set.seed(123) n <- 1000 true_params <- c(gamma = 2.0, delta = 2.5, lambda = 1.5) data <- rmc(n, gamma = true_params[1], delta = true_params[2],             lambda = true_params[3]) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Evaluate negative log-likelihood at true parameters nll_true <- llmc(par = true_params, data = data) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt cat(\"Negative log-likelihood at true parameters:\", nll_true, \"\\n\") #> Error: object 'nll_true' not found  # Evaluate at different parameter values test_params <- rbind(   c(1.5, 2.0, 1.0),   c(2.0, 2.5, 1.5),   c(2.5, 3.0, 2.0) )  nll_values <- apply(test_params, 1, function(p) llmc(p, data)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in FUN(newX[, i], ...): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt results <- data.frame(   Gamma = test_params[, 1],   Delta = test_params[, 2],   Lambda = test_params[, 3],   NegLogLik = nll_values ) #> Error: object 'nll_values' not found print(results, digits = 4) #> Error: object 'results' not found   ## Example 2: Maximum Likelihood Estimation  # Optimization using BFGS with analytical gradient fit <- optim(   par = c(1.5, 2.0, 1.0),   fn = llmc,   gr = grmc,   data = data,   method = \"BFGS\",   hessian = TRUE ) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = c(1.5, 2, 1), fn = llmc, gr = grmc, data = data,     method = \"BFGS\", hessian = TRUE): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  mle <- fit$par #> Error: object 'fit' not found names(mle) <- c(\"gamma\", \"delta\", \"lambda\") #> Error: object 'mle' not found se <- sqrt(diag(solve(fit$hessian))) #> Error: object 'fit' not found  results <- data.frame(   Parameter = c(\"gamma\", \"delta\", \"lambda\"),   True = true_params,   MLE = mle,   SE = se,   CI_Lower = mle - 1.96 * se,   CI_Upper = mle + 1.96 * se ) #> Error: object 'mle' not found print(results, digits = 4) #> Error: object 'results' not found  cat(\"\\nNegative log-likelihood at MLE:\", fit$value, \"\\n\") #> Error: object 'fit' not found cat(\"AIC:\", 2 * fit$value + 2 * length(mle), \"\\n\") #> Error: object 'fit' not found cat(\"BIC:\", 2 * fit$value + length(mle) * log(n), \"\\n\") #> Error: object 'fit' not found   ## Example 3: Comparing Optimization Methods  methods <- c(\"BFGS\", \"L-BFGS-B\", \"Nelder-Mead\", \"CG\") start_params <- c(1.5, 2.0, 1.0)  comparison <- data.frame(   Method = character(),   Gamma = numeric(),   Delta = numeric(),   Lambda = numeric(),   NegLogLik = numeric(),   Convergence = integer(),   stringsAsFactors = FALSE )  for (method in methods) {   if (method %in% c(\"BFGS\", \"CG\")) {     fit_temp <- optim(       par = start_params,       fn = llmc,       gr = grmc,       data = data,       method = method     )   } else if (method == \"L-BFGS-B\") {     fit_temp <- optim(       par = start_params,       fn = llmc,       gr = grmc,       data = data,       method = method,       lower = c(0.01, 0.01, 0.01),       upper = c(100, 100, 100)     )   } else {     fit_temp <- optim(       par = start_params,       fn = llmc,       data = data,       method = method     )   }    comparison <- rbind(comparison, data.frame(     Method = method,     Gamma = fit_temp$par[1],     Delta = fit_temp$par[2],     Lambda = fit_temp$par[3],     NegLogLik = fit_temp$value,     Convergence = fit_temp$convergence,     stringsAsFactors = FALSE   )) } #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in optim(par = start_params, fn = llmc, gr = grmc, data = data,     method = method): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  print(comparison, digits = 4, row.names = FALSE) #> [1] Method      Gamma       Delta       Lambda      NegLogLik   Convergence #> <0 rows> (or 0-length row.names)   ## Example 4: Likelihood Ratio Test  # Test H0: lambda = 1.5 vs H1: lambda free loglik_full <- -fit$value #> Error: object 'fit' not found  restricted_ll <- function(params_restricted, data, lambda_fixed) {   llmc(par = c(params_restricted[1], params_restricted[2],                lambda_fixed), data = data) }  fit_restricted <- optim(   par = c(mle[1], mle[2]),   fn = restricted_ll,   data = data,   lambda_fixed = 1.5,   method = \"BFGS\" ) #> Error: object 'mle' not found  loglik_restricted <- -fit_restricted$value #> Error: object 'fit_restricted' not found lr_stat <- 2 * (loglik_full - loglik_restricted) #> Error: object 'loglik_full' not found p_value <- pchisq(lr_stat, df = 1, lower.tail = FALSE) #> Error: object 'lr_stat' not found  cat(\"LR Statistic:\", round(lr_stat, 4), \"\\n\") #> Error: object 'lr_stat' not found cat(\"P-value:\", format.pval(p_value, digits = 4), \"\\n\") #> Error: object 'p_value' not found   ## Example 5: Univariate Profile Likelihoods  # Profile for gamma gamma_grid <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = 50) #> Error: object 'mle' not found gamma_grid <- gamma_grid[gamma_grid > 0] #> Error: object 'gamma_grid' not found profile_ll_gamma <- numeric(length(gamma_grid)) #> Error: object 'gamma_grid' not found  for (i in seq_along(gamma_grid)) {   profile_fit <- optim(     par = mle[-1],     fn = function(p) llmc(c(gamma_grid[i], p), data),     method = \"BFGS\"   )   profile_ll_gamma[i] <- -profile_fit$value } #> Error: object 'gamma_grid' not found  # Profile for delta delta_grid <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = 50) #> Error: object 'mle' not found delta_grid <- delta_grid[delta_grid > 0] #> Error: object 'delta_grid' not found profile_ll_delta <- numeric(length(delta_grid)) #> Error: object 'delta_grid' not found  for (i in seq_along(delta_grid)) {   profile_fit <- optim(     par = mle[-2],     fn = function(p) llmc(c(p[1], delta_grid[i], p[2]), data),     method = \"BFGS\"   )   profile_ll_delta[i] <- -profile_fit$value } #> Error: object 'delta_grid' not found  # Profile for lambda lambda_grid <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = 50) #> Error: object 'mle' not found lambda_grid <- lambda_grid[lambda_grid > 0] #> Error: object 'lambda_grid' not found profile_ll_lambda <- numeric(length(lambda_grid)) #> Error: object 'lambda_grid' not found  for (i in seq_along(lambda_grid)) {   profile_fit <- optim(     par = mle[-3],     fn = function(p) llmc(c(p[1], p[2], lambda_grid[i]), data),     method = \"BFGS\"   )   profile_ll_lambda[i] <- -profile_fit$value } #> Error: object 'lambda_grid' not found  # 95% confidence threshold chi_crit <- qchisq(0.95, df = 1) threshold <- max(profile_ll_gamma) - chi_crit / 2 #> Error: object 'profile_ll_gamma' not found  # Plot all profiles  plot(gamma_grid, profile_ll_gamma, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(gamma), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", gamma)), las = 1) #> Error: object 'gamma_grid' not found abline(v = mle[1], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[1], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(delta_grid, profile_ll_delta, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(delta), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", delta)), las = 1) #> Error: object 'delta_grid' not found abline(v = mle[2], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[2], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  plot(lambda_grid, profile_ll_lambda, type = \"l\", lwd = 2, col = \"#2E4057\",      xlab = expression(lambda), ylab = \"Profile Log-Likelihood\",      main = expression(paste(\"Profile: \", lambda)), las = 1) #> Error: object 'lambda_grid' not found abline(v = mle[3], col = \"#8B0000\", lty = 2, lwd = 2) #> Error: object 'mle' not found abline(v = true_params[3], col = \"#006400\", lty = 2, lwd = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet abline(h = threshold, col = \"#808080\", lty = 3, lwd = 1.5) #> Error: object 'threshold' not found legend(\"topright\", legend = c(\"MLE\", \"True\", \"95% CI\"),        col = c(\"#8B0000\", \"#006400\", \"#808080\"),        lty = c(2, 2, 3), lwd = 2, bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  ## Example 6: 2D Log-Likelihood Surfaces (All pairs side by side)  # Create 2D grids with wider range (¬±1.5) gamma_2d <- seq(mle[1] - 1.5, mle[1] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found delta_2d <- seq(mle[2] - 1.5, mle[2] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found lambda_2d <- seq(mle[3] - 1.5, mle[3] + 1.5, length.out = round(n/25)) #> Error: object 'mle' not found  gamma_2d <- gamma_2d[gamma_2d > 0] #> Error: object 'gamma_2d' not found delta_2d <- delta_2d[delta_2d > 0] #> Error: object 'delta_2d' not found lambda_2d <- lambda_2d[lambda_2d > 0] #> Error: object 'lambda_2d' not found  # Compute all log-likelihood surfaces ll_surface_gd <- matrix(NA, nrow = length(gamma_2d), ncol = length(delta_2d)) #> Error: object 'gamma_2d' not found ll_surface_gl <- matrix(NA, nrow = length(gamma_2d), ncol = length(lambda_2d)) #> Error: object 'gamma_2d' not found ll_surface_dl <- matrix(NA, nrow = length(delta_2d), ncol = length(lambda_2d)) #> Error: object 'delta_2d' not found  # Gamma vs Delta for (i in seq_along(gamma_2d)) {   for (j in seq_along(delta_2d)) {     ll_surface_gd[i, j] <- -llmc(c(gamma_2d[i], delta_2d[j], mle[3]), data)   } } #> Error: object 'gamma_2d' not found  # Gamma vs Lambda for (i in seq_along(gamma_2d)) {   for (j in seq_along(lambda_2d)) {     ll_surface_gl[i, j] <- -llmc(c(gamma_2d[i], mle[2], lambda_2d[j]), data)   } } #> Error: object 'gamma_2d' not found  # Delta vs Lambda for (i in seq_along(delta_2d)) {   for (j in seq_along(lambda_2d)) {     ll_surface_dl[i, j] <- -llmc(c(mle[1], delta_2d[i], lambda_2d[j]), data)   } } #> Error: object 'delta_2d' not found  # Confidence region levels max_ll_gd <- max(ll_surface_gd, na.rm = TRUE) #> Error: object 'll_surface_gd' not found max_ll_gl <- max(ll_surface_gl, na.rm = TRUE) #> Error: object 'll_surface_gl' not found max_ll_dl <- max(ll_surface_dl, na.rm = TRUE) #> Error: object 'll_surface_dl' not found  levels_95_gd <- max_ll_gd - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_gd' not found levels_95_gl <- max_ll_gl - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_gl' not found levels_95_dl <- max_ll_dl - qchisq(0.95, df = 2) / 2 #> Error: object 'max_ll_dl' not found  # Plot   # Gamma vs Delta contour(gamma_2d, delta_2d, ll_surface_gd,         xlab = expression(gamma), ylab = expression(delta),         main = \"Gamma vs Delta\", las = 1,         levels = seq(min(ll_surface_gd, na.rm = TRUE), max_ll_gd, length.out = 20),         col = \"#2E4057\", lwd = 1) #> Error: object 'gamma_2d' not found contour(gamma_2d, delta_2d, ll_surface_gd,         levels = levels_95_gd, col = \"#FF6347\", lwd = 2.5, lty = 1, add = TRUE) #> Error: object 'gamma_2d' not found points(mle[1], mle[2], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[2], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Gamma vs Lambda contour(gamma_2d, lambda_2d, ll_surface_gl,         xlab = expression(gamma), ylab = expression(lambda),         main = \"Gamma vs Lambda\", las = 1,         levels = seq(min(ll_surface_gl, na.rm = TRUE), max_ll_gl, length.out = 20),         col = \"#2E4057\", lwd = 1) #> Error: object 'gamma_2d' not found contour(gamma_2d, lambda_2d, ll_surface_gl,         levels = levels_95_gl, col = \"#FF6347\", lwd = 2.5, lty = 1, add = TRUE) #> Error: object 'gamma_2d' not found points(mle[1], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[1], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Delta vs Lambda contour(delta_2d, lambda_2d, ll_surface_dl,         xlab = expression(delta), ylab = expression(lambda),         main = \"Delta vs Lambda\", las = 1,         levels = seq(min(ll_surface_dl, na.rm = TRUE), max_ll_dl, length.out = 20),         col = \"#2E4057\", lwd = 1) #> Error: object 'delta_2d' not found contour(delta_2d, lambda_2d, ll_surface_dl,         levels = levels_95_dl, col = \"#FF6347\", lwd = 2.5, lty = 1, add = TRUE) #> Error: object 'delta_2d' not found points(mle[2], mle[3], pch = 19, col = \"#8B0000\", cex = 1.5) #> Error: object 'mle' not found points(true_params[2], true_params[3], pch = 17, col = \"#006400\", cex = 1.5) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet grid(col = \"gray90\") #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  legend(\"topright\",        legend = c(\"MLE\", \"True\", \"95% CR\"),        col = c(\"#8B0000\", \"#006400\", \"#FF6347\"),        pch = c(19, 17, NA),        lty = c(NA, NA, 1),        lwd = c(NA, NA, 2.5),        bty = \"n\", cex = 0.8) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"Computes cumulative distribution function (CDF), \\(F(q) = P(X \\le q)\\), standard Beta distribution, using parameterization common generalized distribution families. distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"","code":"pbeta_(q, gamma, delta, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"q Vector quantiles (values generally 0 1). gamma First shape parameter (shape1), \\(\\gamma > 0\\). Can scalar vector. Default: 1.0. delta Second shape parameter delta + 1 (shape2), requires \\(\\delta \\ge 0\\) shape2 >= 1. Can scalar vector. Default: 0.0 (leading shape2 = 1). lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"vector probabilities, \\(F(q)\\), logarithms/complements depending lower_tail log_p. length result determined recycling rule applied arguments (q, gamma, delta). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"function computes CDF Beta distribution parameters shape1 = gamma shape2 = delta + 1. equivalent calling stats::pbeta(q, shape1 = gamma, shape2 = delta + 1, lower.tail = lower_tail, log.p = log_p). distribution arises special case five-parameter Generalized Kumaraswamy (GKw) distribution (pgkw) obtained setting \\(\\alpha = 1\\), \\(\\beta = 1\\), \\(\\lambda = 1\\). therefore also equivalent McDonald (Mc)/Beta Power distribution (pmc) \\(\\lambda = 1\\). function likely calls R's underlying pbeta function ensures consistent parameter recycling handling within C++ environment, matching style functions related families.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation,","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbeta_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CDF of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî pbeta_","text":"","code":"# \\donttest{ # Example values q_vals <- c(0.2, 0.5, 0.8) gamma_par <- 2.0 # Corresponds to shape1 delta_par <- 3.0 # Corresponds to shape2 - 1 shape1 <- gamma_par shape2 <- delta_par + 1  # Calculate CDF using pbeta_ probs <- pbeta_(q_vals, gamma_par, delta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs) #> Error: object 'probs' not found  # Compare with stats::pbeta probs_stats <- stats::pbeta(q_vals, shape1 = shape1, shape2 = shape2) print(paste(\"Max difference vs stats::pbeta:\", max(abs(probs - probs_stats)))) #> Error: object 'probs' not found  # Compare with pgkw setting alpha=1, beta=1, lambda=1 probs_gkw <- pgkw(q_vals, alpha = 1.0, beta = 1.0, gamma = gamma_par,                   delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference vs pgkw:\", max(abs(probs - probs_gkw)))) #> Error: object 'probs' not found  # Compare with pmc setting lambda=1 probs_mc <- pmc(q_vals, gamma = gamma_par, delta = delta_par, lambda = 1.0) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference vs pmc:\", max(abs(probs - probs_mc)))) #> Error: object 'probs' not found  # Calculate upper tail P(X > q) probs_upper <- pbeta_(q_vals, gamma_par, delta_par, lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs_upper) #> Error: object 'probs_upper' not found print(stats::pbeta(q_vals, shape1, shape2, lower.tail = FALSE)) #> [1] 0.73728 0.18750 0.00672  # Calculate log CDF log_probs <- pbeta_(q_vals, gamma_par, delta_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_probs) #> Error: object 'log_probs' not found print(stats::pbeta(q_vals, shape1, shape2, log.p = TRUE)) #> [1] -1.336666453 -0.207639365 -0.006742681  # Plot the CDF curve_q <- seq(0.001, 0.999, length.out = 200) curve_p <- pbeta_(curve_q, gamma = 2, delta = 3) # Beta(2, 4) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt plot(curve_q, curve_p, type = \"l\", main = \"Beta(2, 4) CDF via pbeta_\",      xlab = \"q\", ylab = \"F(q)\", col = \"blue\") #> Error: object 'curve_p' not found curve(stats::pbeta(x, 2, 4), add=TRUE, col=\"red\", lty=2) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet legend(\"bottomright\", legend=c(\"pbeta_(gamma=2, delta=3)\", \"stats::pbeta(shape1=2, shape2=4)\"),        col=c(\"blue\", \"red\"), lty=c(1,2), bty=\"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"Computes cumulative distribution function (CDF), \\(P(X \\le q)\\), Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)). distribution defined interval (0, 1) special case Generalized Kumaraswamy (GKw) distribution \\(\\lambda = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"","code":"pbkw(q, alpha, beta, gamma, delta, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"q Vector quantiles (values generally 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"vector probabilities, \\(F(q)\\), logarithms/complements depending lower_tail log_p. length result determined recycling rule applied arguments (q, alpha, beta, gamma, delta). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"Beta-Kumaraswamy (BKw) distribution special case five-parameter Generalized Kumaraswamy distribution (pgkw) obtained setting shape parameter \\(\\lambda = 1\\). CDF GKw distribution \\(F_{GKw}(q) = I_{y(q)}(\\gamma, \\delta+1)\\), \\(y(q) = [1-(1-q^{\\alpha})^{\\beta}]^{\\lambda}\\) \\(I_x(,b)\\) regularized incomplete beta function (pbeta). Setting \\(\\lambda=1\\) simplifies \\(y(q)\\) \\(1 - (1 - q^\\alpha)^\\beta\\), yielding BKw CDF: $$ F(q; \\alpha, \\beta, \\gamma, \\delta) = I_{1 - (1 - q^\\alpha)^\\beta}(\\gamma, \\delta+1) $$ evaluated using pbeta function.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function (CDF) of the Beta-Kumaraswamy (BKw) Distribution ‚Äî pbkw","text":"","code":"# \\donttest{ # Example values q_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 1.5 gamma_par <- 1.0 delta_par <- 0.5  # Calculate CDF P(X <= q) probs <- pbkw(q_vals, alpha_par, beta_par, gamma_par, delta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs) #> Error: object 'probs' not found  # Calculate upper tail P(X > q) probs_upper <- pbkw(q_vals, alpha_par, beta_par, gamma_par, delta_par,                     lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs_upper) #> Error: object 'probs_upper' not found # Check: probs + probs_upper should be 1 print(probs + probs_upper) #> Error: object 'probs' not found  # Calculate log CDF log_probs <- pbkw(q_vals, alpha_par, beta_par, gamma_par, delta_par,                   log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_probs) #> Error: object 'log_probs' not found # Check: should match log(probs) print(log(probs)) #> Error: object 'probs' not found  # Compare with pgkw setting lambda = 1 probs_gkw <- pgkw(q_vals, alpha_par, beta_par, gamma = gamma_par,                  delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(probs - probs_gkw)))) # Should be near zero #> Error: object 'probs' not found  # Plot the CDF curve_q <- seq(0.01, 0.99, length.out = 200) curve_p <- pbkw(curve_q, alpha = 2, beta = 3, gamma = 0.5, delta = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt plot(curve_q, curve_p, type = \"l\", main = \"BKw CDF Example\",      xlab = \"q\", ylab = \"F(q)\", col = \"blue\", ylim = c(0, 1)) #> Error: object 'curve_p' not found # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"Computes cumulative distribution function (CDF), \\(P(X \\le q)\\), Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)). distribution defined interval (0, 1) special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\) \\(\\delta = 0\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"","code":"pekw(q, alpha, beta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"q Vector quantiles (values generally 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. lambda Shape parameter lambda > 0 (exponent parameter). Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"vector probabilities, \\(F(q)\\), logarithms/complements depending lower_tail log_p. length result determined recycling rule applied arguments (q, alpha, beta, lambda). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"Exponentiated Kumaraswamy (EKw) distribution special case five-parameter Generalized Kumaraswamy distribution (pgkw) obtained setting parameters \\(\\gamma = 1\\) \\(\\delta = 0\\). CDF GKw distribution \\(F_{GKw}(q) = I_{y(q)}(\\gamma, \\delta+1)\\), \\(y(q) = [1-(1-q^{\\alpha})^{\\beta}]^{\\lambda}\\) \\(I_x(,b)\\) regularized incomplete beta function (pbeta). Setting \\(\\gamma=1\\) \\(\\delta=0\\) gives \\(I_{y(q)}(1, 1)\\). Since \\(I_x(1, 1) = x\\), CDF simplifies \\(y(q)\\): $$ F(q; \\alpha, \\beta, \\lambda) = \\bigl[1 - (1 - q^\\alpha)^\\beta \\bigr]^\\lambda $$ \\(0 < q < 1\\). implementation uses closed-form expression efficiency handles lower_tail log_p arguments appropriately.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function (CDF) of the EKw Distribution ‚Äî pekw","text":"","code":"# \\donttest{ # Example values q_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 3.0 lambda_par <- 1.5  # Calculate CDF P(X <= q) probs <- pekw(q_vals, alpha_par, beta_par, lambda_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs) #> Error: object 'probs' not found  # Calculate upper tail P(X > q) probs_upper <- pekw(q_vals, alpha_par, beta_par, lambda_par,                     lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs_upper) #> Error: object 'probs_upper' not found # Check: probs + probs_upper should be 1 print(probs + probs_upper) #> Error: object 'probs' not found  # Calculate log CDF log_probs <- pekw(q_vals, alpha_par, beta_par, lambda_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_probs) #> Error: object 'log_probs' not found # Check: should match log(probs) print(log(probs)) #> Error: object 'probs' not found  # Compare with pgkw setting gamma = 1, delta = 0 probs_gkw <- pgkw(q_vals, alpha_par, beta_par, gamma = 1.0, delta = 0.0,                  lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(probs - probs_gkw)))) # Should be near zero #> Error: object 'probs' not found  # Plot the CDF for different lambda values curve_q <- seq(0.01, 0.99, length.out = 200) curve_p1 <- pekw(curve_q, alpha = 2, beta = 3, lambda = 0.5) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_p2 <- pekw(curve_q, alpha = 2, beta = 3, lambda = 1.0) # standard Kw #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_p3 <- pekw(curve_q, alpha = 2, beta = 3, lambda = 2.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  plot(curve_q, curve_p2, type = \"l\", main = \"EKw CDF Examples (alpha=2, beta=3)\",      xlab = \"q\", ylab = \"F(q)\", col = \"red\", ylim = c(0, 1)) #> Error: object 'curve_p2' not found lines(curve_q, curve_p1, col = \"blue\") #> Error: object 'curve_p1' not found lines(curve_q, curve_p3, col = \"green\") #> Error: object 'curve_p3' not found legend(\"bottomright\", legend = c(\"lambda=0.5\", \"lambda=1.0 (Kw)\", \"lambda=2.0\"),        col = c(\"blue\", \"red\", \"green\"), lty = 1, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"Computes cumulative distribution function (CDF) five-parameter Generalized Kumaraswamy (GKw) distribution, defined interval (0, 1). Calculates \\(P(X \\le q)\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"","code":"pgkw(q, alpha, beta, gamma, delta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"q Vector quantiles (values generally 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"vector probabilities, \\(F(q)\\), logarithms log_p = TRUE. length result determined recycling rule applied arguments (q, alpha, beta, gamma, delta, lambda). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"cumulative distribution function (CDF) Generalized Kumaraswamy (GKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)) given : $$ F(q; \\alpha, \\beta, \\gamma, \\delta, \\lambda) =   I_{x(q)}(\\gamma, \\delta+1) $$ \\(x(q) = [1-(1-q^{\\alpha})^{\\beta}]^{\\lambda}\\) \\(I_x(, b)\\) regularized incomplete beta function, defined : $$ I_x(, b) = \\frac{B_x(, b)}{B(, b)} = \\frac{\\int_0^x t^{-1}(1-t)^{b-1} dt}{\\int_0^1 t^{-1}(1-t)^{b-1} dt} $$ corresponds pbeta function R, \\(F(q; \\alpha, \\beta, \\gamma, \\delta, \\lambda) = \\code{pbeta}(x(q), \\code{shape1} = \\gamma, \\code{shape2} = \\delta+1)\\). GKw distribution includes several special cases, Kumaraswamy, Beta, Exponentiated Kumaraswamy distributions (see dgkw details). function utilizes numerical algorithms computing regularized incomplete beta function accurately, especially near boundaries.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Kumaraswamy Distribution CDF ‚Äî pgkw","text":"","code":"# \\donttest{ # Simple CDF evaluation prob <- pgkw(0.5, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) # Kw case #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(prob) #> Error: object 'prob' not found  # Upper tail probability P(X > q) prob_upper <- pgkw(0.5, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1,                  lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(prob_upper) #> Error: object 'prob_upper' not found # Check: prob + prob_upper should be 1 print(prob + prob_upper) #> Error: object 'prob' not found  # Log probability log_prob <- pgkw(0.5, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1,                  log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_prob) #> Error: object 'log_prob' not found # Check: exp(log_prob) should be prob print(exp(log_prob)) #> Error: object 'log_prob' not found  # Use of vectorized parameters q_vals <- c(0.2, 0.5, 0.8) alphas_vec <- c(0.5, 1.0, 2.0) betas_vec <- c(1.0, 2.0, 3.0) # Vectorizes over q, alpha, beta pgkw(q_vals, alpha = alphas_vec, beta = betas_vec, gamma = 1, delta = 0.5, lambda = 0.5) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Plotting the CDF for special cases x_seq <- seq(0.01, 0.99, by = 0.01) # Standard Kumaraswamy CDF cdf_kw <- pgkw(x_seq, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt # Beta distribution CDF equivalent (Beta(gamma, delta+1)) cdf_beta_equiv <- pgkw(x_seq, alpha = 1, beta = 1, gamma = 2, delta = 3, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt # Compare with stats::pbeta cdf_beta_check <- stats::pbeta(x_seq, shape1 = 2, shape2 = 3 + 1) # max(abs(cdf_beta_equiv - cdf_beta_check)) # Should be close to zero  plot(x_seq, cdf_kw, type = \"l\", ylim = c(0, 1),      main = \"GKw CDF Examples\", ylab = \"F(x)\", xlab = \"x\", col = \"blue\") #> Error: object 'cdf_kw' not found lines(x_seq, cdf_beta_equiv, col = \"red\", lty = 2) #> Error: object 'cdf_beta_equiv' not found legend(\"bottomright\", legend = c(\"Kw(2,3)\", \"Beta(2,4) equivalent\"),        col = c(\"blue\", \"red\"), lty = c(1, 2), bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator ‚Äî %>%","title":"Pipe operator ‚Äî %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator ‚Äî %>%","text":"","code":"lhs %>% rhs"},{"path":"https://evandeilton.github.io/gkwdist/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator ‚Äî %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator ‚Äî %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"Computes cumulative distribution function (CDF), \\(P(X \\le q)\\), Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"","code":"pkkw(q, alpha, beta, delta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"q Vector quantiles (values generally 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"vector probabilities, \\(F(q)\\), logarithms/complements depending lower_tail log_p. length result determined recycling rule applied arguments (q, alpha, beta, delta, lambda). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"Kumaraswamy-Kumaraswamy (kkw) distribution special case five-parameter Generalized Kumaraswamy distribution (pgkw) obtained setting shape parameter \\(\\gamma = 1\\). CDF GKw distribution \\(F_{GKw}(q) = I_{y(q)}(\\gamma, \\delta+1)\\), \\(y(q) = [1-(1-q^{\\alpha})^{\\beta}]^{\\lambda}\\) \\(I_x(,b)\\) regularized incomplete beta function (pbeta). Setting \\(\\gamma=1\\) utilizes property \\(I_x(1, b) = 1 - (1-x)^b\\), yielding kkw CDF: $$ F(q; \\alpha, \\beta, \\delta, \\lambda) = 1 - \\bigl\\{1 - \\bigl[1 - (1 - q^\\alpha)^\\beta\\bigr]^\\lambda\\bigr\\}^{\\delta + 1} $$ \\(0 < q < 1\\). implementation uses closed-form expression efficiency handles lower_tail log_p arguments appropriately.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function (CDF) of the kkw Distribution ‚Äî pkkw","text":"","code":"# \\donttest{ # Example values q_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 3.0 delta_par <- 0.5 lambda_par <- 1.5  # Calculate CDF P(X <= q) probs <- pkkw(q_vals, alpha_par, beta_par, delta_par, lambda_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs) #> Error: object 'probs' not found  # Calculate upper tail P(X > q) probs_upper <- pkkw(q_vals, alpha_par, beta_par, delta_par, lambda_par,                      lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs_upper) #> Error: object 'probs_upper' not found # Check: probs + probs_upper should be 1 print(probs + probs_upper) #> Error: object 'probs' not found  # Calculate log CDF log_probs <- pkkw(q_vals, alpha_par, beta_par, delta_par, lambda_par,                    log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_probs) #> Error: object 'log_probs' not found # Check: should match log(probs) print(log(probs)) #> Error: object 'probs' not found  # Compare with pgkw setting gamma = 1 probs_gkw <- pgkw(q_vals, alpha_par, beta_par, gamma = 1.0,                   delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(probs - probs_gkw)))) # Should be near zero #> Error: object 'probs' not found  # Plot the CDF curve_q <- seq(0.01, 0.99, length.out = 200) curve_p <- pkkw(curve_q, alpha_par, beta_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt plot(curve_q, curve_p, type = \"l\", main = \"kkw CDF Example\",      xlab = \"q\", ylab = \"F(q)\", col = \"blue\", ylim = c(0, 1)) #> Error: object 'curve_p' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"Computes cumulative distribution function (CDF), \\(P(X \\le q)\\), two-parameter Kumaraswamy (Kw) distribution shape parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)). distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"","code":"pkw(q, alpha, beta, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"q Vector quantiles (values generally 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"vector probabilities, \\(F(q)\\), logarithms/complements depending lower_tail log_p. length result determined recycling rule applied arguments (q, alpha, beta). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"cumulative distribution function (CDF) Kumaraswamy (Kw) distribution given : $$ F(x; \\alpha, \\beta) = 1 - (1 - x^\\alpha)^\\beta $$ \\(0 < x < 1\\), \\(\\alpha > 0\\), \\(\\beta > 0\\). Kw distribution special case several generalized distributions: Generalized Kumaraswamy (pgkw) \\(\\gamma=1, \\delta=0, \\lambda=1\\). Exponentiated Kumaraswamy (pekw) \\(\\lambda=1\\). Kumaraswamy-Kumaraswamy (pkkw) \\(\\delta=0, \\lambda=1\\). implementation uses closed-form expression efficiency.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function (CDF) of the Kumaraswamy (Kw) Distribution ‚Äî pkw","text":"","code":"# \\donttest{ # Example values q_vals <- c(0.2, 0.5, 0.8) alpha_par <- 2.0 beta_par <- 3.0  # Calculate CDF P(X <= q) using pkw probs <- pkw(q_vals, alpha_par, beta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs) #> Error: object 'probs' not found  # Calculate upper tail P(X > q) probs_upper <- pkw(q_vals, alpha_par, beta_par, lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs_upper) #> Error: object 'probs_upper' not found # Check: probs + probs_upper should be 1 print(probs + probs_upper) #> Error: object 'probs' not found  # Calculate log CDF log_probs <- pkw(q_vals, alpha_par, beta_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_probs) #> Error: object 'log_probs' not found # Check: should match log(probs) print(log(probs)) #> Error: object 'probs' not found  # Compare with pgkw setting gamma = 1, delta = 0, lambda = 1 probs_gkw <- pgkw(q_vals, alpha_par, beta_par, gamma = 1.0, delta = 0.0,                   lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(probs - probs_gkw)))) # Should be near zero #> Error: object 'probs' not found  # Plot the CDF for different shape parameter combinations curve_q <- seq(0.001, 0.999, length.out = 200) plot(curve_q, pkw(curve_q, alpha = 2, beta = 3), type = \"l\",      main = \"Kumaraswamy CDF Examples\", xlab = \"q\", ylab = \"F(q)\",      col = \"blue\", ylim = c(0, 1)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y, xlabel, ylabel, log): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_q, pkw(curve_q, alpha = 3, beta = 2), col = \"red\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_q, pkw(curve_q, alpha = 0.5, beta = 0.5), col = \"green\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_q, pkw(curve_q, alpha = 5, beta = 1), col = \"purple\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt lines(curve_q, pkw(curve_q, alpha = 1, beta = 3), col = \"orange\") #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in xy.coords(x, y): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"bottomright\", legend = c(\"a=2, b=3\", \"a=3, b=2\", \"a=0.5, b=0.5\", \"a=5, b=1\", \"a=1, b=3\"),        col = c(\"blue\", \"red\", \"green\", \"purple\", \"orange\"), lty = 1, bty = \"n\", ncol = 2) #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"Computes cumulative distribution function (CDF), \\(F(q) = P(X \\le q)\\), McDonald (Mc) distribution (also known Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution defined interval (0, 1) special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\) \\(\\beta = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"","code":"pmc(q, gamma, delta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"q Vector quantiles (values generally 0 1). gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le q)\\), otherwise, \\(P(X > q)\\). log_p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"vector probabilities, \\(F(q)\\), logarithms/complements depending lower_tail log_p. length result determined recycling rule applied arguments (q, gamma, delta, lambda). Returns 0 (-Inf log_p = TRUE) q <= 0 1 (0 log_p = TRUE) q >= 1. Returns NaN invalid parameters.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"McDonald (Mc) distribution special case five-parameter Generalized Kumaraswamy (GKw) distribution (pgkw) obtained setting parameters \\(\\alpha = 1\\) \\(\\beta = 1\\). CDF GKw distribution \\(F_{GKw}(q) = I_{y(q)}(\\gamma, \\delta+1)\\), \\(y(q) = [1-(1-q^{\\alpha})^{\\beta}]^{\\lambda}\\) \\(I_x(,b)\\) regularized incomplete beta function (pbeta). Setting \\(\\alpha=1\\) \\(\\beta=1\\) simplifies \\(y(q)\\) \\(q^\\lambda\\), yielding Mc CDF: $$ F(q; \\gamma, \\delta, \\lambda) = I_{q^\\lambda}(\\gamma, \\delta+1) $$ evaluated using pbeta function pbeta(q^lambda, shape1 = gamma, shape2 = delta + 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/pmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CDF of the McDonald (Mc)/Beta Power Distribution ‚Äî pmc","text":"","code":"# \\donttest{ # Example values q_vals <- c(0.2, 0.5, 0.8) gamma_par <- 2.0 delta_par <- 1.5 lambda_par <- 1.0 # Equivalent to Beta(gamma, delta+1)  # Calculate CDF P(X <= q) using pmc probs <- pmc(q_vals, gamma_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs) #> Error: object 'probs' not found # Compare with Beta CDF print(stats::pbeta(q_vals, shape1 = gamma_par, shape2 = delta_par + 1)) #> [1] 0.1413499 0.6022524 0.9463344  # Calculate upper tail P(X > q) probs_upper <- pmc(q_vals, gamma_par, delta_par, lambda_par,                    lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(probs_upper) #> Error: object 'probs_upper' not found # Check: probs + probs_upper should be 1 print(probs + probs_upper) #> Error: object 'probs' not found  # Calculate log CDF log_probs <- pmc(q_vals, gamma_par, delta_par, lambda_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(log_probs) #> Error: object 'log_probs' not found # Check: should match log(probs) print(log(probs)) #> Error: object 'probs' not found  # Compare with pgkw setting alpha = 1, beta = 1 probs_gkw <- pgkw(q_vals, alpha = 1.0, beta = 1.0, gamma = gamma_par,                   delta = delta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(probs - probs_gkw)))) # Should be near zero #> Error: object 'probs' not found  # Plot the CDF for different lambda values curve_q <- seq(0.01, 0.99, length.out = 200) curve_p1 <- pmc(curve_q, gamma = 2, delta = 3, lambda = 0.5) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_p2 <- pmc(curve_q, gamma = 2, delta = 3, lambda = 1.0) # Beta(2, 4) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve_p3 <- pmc(curve_q, gamma = 2, delta = 3, lambda = 2.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  plot(curve_q, curve_p2, type = \"l\", main = \"Mc/Beta Power CDF (gamma=2, delta=3)\",      xlab = \"q\", ylab = \"F(q)\", col = \"red\", ylim = c(0, 1)) #> Error: object 'curve_p2' not found lines(curve_q, curve_p1, col = \"blue\") #> Error: object 'curve_p1' not found lines(curve_q, curve_p3, col = \"green\") #> Error: object 'curve_p3' not found legend(\"bottomright\", legend = c(\"lambda=0.5\", \"lambda=1.0 (Beta)\", \"lambda=2.0\"),        col = c(\"blue\", \"red\", \"green\"), lty = 1, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"Computes quantile function (inverse CDF) standard Beta distribution, using parameterization common generalized distribution families. finds value q \\(P(X \\le q) = p\\). distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"","code":"qbeta_(p, gamma, delta, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"p Vector probabilities (values 0 1). gamma First shape parameter (shape1), \\(\\gamma > 0\\). Can scalar vector. Default: 1.0. delta Second shape parameter delta + 1 (shape2), requires \\(\\delta \\ge 0\\) shape2 >= 1. Can scalar vector. Default: 0.0 (leading shape2 = 1). lower_tail Logical; TRUE (default), probabilities \\(p = P(X \\le q)\\), otherwise, probabilities \\(p = P(X > q)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, gamma, delta). Returns: 0 p = 0 (p = -Inf log_p = TRUE, lower_tail = TRUE). 1 p = 1 (p = 0 log_p = TRUE, lower_tail = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., gamma <= 0, delta < 0). Boundary return values adjusted accordingly lower_tail = FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"function computes quantiles Beta distribution parameters shape1 = gamma shape2 = delta + 1. equivalent calling stats::qbeta(p, shape1 = gamma, shape2 = delta + 1, lower.tail = lower_tail, log.p = log_p). distribution arises special case five-parameter Generalized Kumaraswamy (GKw) distribution (qgkw) obtained setting \\(\\alpha = 1\\), \\(\\beta = 1\\), \\(\\lambda = 1\\). therefore also equivalent McDonald (Mc)/Beta Power distribution (qmc) \\(\\lambda = 1\\). function likely calls R's underlying qbeta function ensures consistent parameter recycling handling within C++ environment, matching style functions related families. Boundary conditions (p=0, p=1) handled explicitly.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation,","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbeta_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Function of the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî qbeta_","text":"","code":"# \\donttest{ # Example values p_vals <- c(0.1, 0.5, 0.9) gamma_par <- 2.0 # Corresponds to shape1 delta_par <- 3.0 # Corresponds to shape2 - 1 shape1 <- gamma_par shape2 <- delta_par + 1  # Calculate quantiles using qbeta_ quantiles <- qbeta_(p_vals, gamma_par, delta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found  # Compare with stats::qbeta quantiles_stats <- stats::qbeta(p_vals, shape1 = shape1, shape2 = shape2) print(paste(\"Max difference vs stats::qbeta:\", max(abs(quantiles - quantiles_stats)))) #> Error: object 'quantiles' not found  # Compare with qgkw setting alpha=1, beta=1, lambda=1 quantiles_gkw <- qgkw(p_vals, alpha = 1.0, beta = 1.0, gamma = gamma_par,                       delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference vs qgkw:\", max(abs(quantiles - quantiles_gkw)))) #> Error: object 'quantiles' not found  # Compare with qmc setting lambda=1 quantiles_mc <- qmc(p_vals, gamma = gamma_par, delta = delta_par, lambda = 1.0) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference vs qmc:\", max(abs(quantiles - quantiles_mc)))) #> Error: object 'quantiles' not found  # Calculate quantiles for upper tail quantiles_upper <- qbeta_(p_vals, gamma_par, delta_par, lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_upper) #> Error: object 'quantiles_upper' not found print(stats::qbeta(p_vals, shape1, shape2, lower.tail = FALSE)) #> [1] 0.5838904 0.3138102 0.1122350  # Calculate quantiles from log probabilities log_p_vals <- log(p_vals) quantiles_logp <- qbeta_(log_p_vals, gamma_par, delta_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_logp) #> Error: object 'quantiles_logp' not found print(stats::qbeta(log_p_vals, shape1, shape2, log.p = TRUE)) #> [1] 0.1122350 0.3138102 0.5838904  # Verify inverse relationship with pbeta_ p_check <- 0.75 q_calc <- qbeta_(p_check, gamma_par, delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_recalc <- pbeta_(q_calc, gamma_par, delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Original p:\", p_check, \" Recalculated p:\", p_recalc)) #> Error: object 'p_recalc' not found # abs(p_check - p_recalc) < 1e-9 # Should be TRUE  # Boundary conditions print(qbeta_(c(0, 1), gamma_par, delta_par)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qbeta_(c(0, 1), gamma_par, delta_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(qbeta_(c(-Inf, 0), gamma_par, delta_par, log_p = TRUE)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qbeta_(c(-Inf, 0), gamma_par, delta_par, log_p = TRUE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"Computes quantile function (inverse CDF) Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)). finds value q \\(P(X \\le q) = p\\). distribution special case Generalized Kumaraswamy (GKw) distribution parameter \\(\\lambda = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"","code":"qbkw(p, alpha, beta, gamma, delta, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"p Vector probabilities (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lower_tail Logical; TRUE (default), probabilities \\(p = P(X \\le q)\\), otherwise, probabilities \\(p = P(X > q)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, alpha, beta, gamma, delta). Returns: 0 p = 0 (p = -Inf log_p = TRUE, lower_tail = TRUE). 1 p = 1 (p = 0 log_p = TRUE, lower_tail = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., alpha <= 0, beta <= 0, gamma <= 0, delta < 0). Boundary return values adjusted accordingly lower_tail = FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"quantile function \\(Q(p)\\) inverse CDF \\(F(q)\\). CDF BKw (\\(\\lambda=1\\)) distribution \\(F(q) = I_{y(q)}(\\gamma, \\delta+1)\\), \\(y(q) = 1 - (1 - q^\\alpha)^\\beta\\) \\(I_z(,b)\\) regularized incomplete beta function (see pbkw). find quantile \\(q\\), first invert outer Beta part: let \\(y = ^{-1}_{p}(\\gamma, \\delta+1)\\), \\(^{-1}_p(,b)\\) inverse regularized incomplete beta function, computed via qbeta. , invert inner Kumaraswamy part: \\(y = 1 - (1 - q^\\alpha)^\\beta\\), leads \\(q = \\{1 - (1-y)^{1/\\beta}\\}^{1/\\alpha}\\). Substituting \\(y\\) gives quantile function: $$ Q(p) = \\left\\{ 1 - \\left[ 1 - ^{-1}_{p}(\\gamma, \\delta+1) \\right]^{1/\\beta} \\right\\}^{1/\\alpha} $$ function uses formula, calculating \\(^{-1}_{p}(\\gamma, \\delta+1)\\) via qbeta(p, gamma, delta + 1, ...) respecting lower_tail log_p arguments.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Function of the Beta-Kumaraswamy (BKw) Distribution ‚Äî qbkw","text":"","code":"# \\donttest{ # Example values p_vals <- c(0.1, 0.5, 0.9) alpha_par <- 2.0 beta_par <- 1.5 gamma_par <- 1.0 delta_par <- 0.5  # Calculate quantiles quantiles <- qbkw(p_vals, alpha_par, beta_par, gamma_par, delta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found  # Calculate quantiles for upper tail probabilities P(X > q) = p quantiles_upper <- qbkw(p_vals, alpha_par, beta_par, gamma_par, delta_par,                         lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_upper) #> Error: object 'quantiles_upper' not found # Check: qbkw(p, ..., lt=F) == qbkw(1-p, ..., lt=T) print(qbkw(1 - p_vals, alpha_par, beta_par, gamma_par, delta_par)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qbkw(1 - p_vals, alpha_par, beta_par, gamma_par, delta_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Calculate quantiles from log probabilities log_p_vals <- log(p_vals) quantiles_logp <- qbkw(log_p_vals, alpha_par, beta_par, gamma_par, delta_par,                        log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_logp) #> Error: object 'quantiles_logp' not found # Check: should match original quantiles print(quantiles) #> Error: object 'quantiles' not found  # Compare with qgkw setting lambda = 1 quantiles_gkw <- qgkw(p_vals, alpha_par, beta_par, gamma = gamma_par,                      delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(quantiles - quantiles_gkw)))) # Should be near zero #> Error: object 'quantiles' not found  # Verify inverse relationship with pbkw p_check <- 0.75 q_calc <- qbkw(p_check, alpha_par, beta_par, gamma_par, delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_recalc <- pbkw(q_calc, alpha_par, beta_par, gamma_par, delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Original p:\", p_check, \" Recalculated p:\", p_recalc)) #> Error: object 'p_recalc' not found # abs(p_check - p_recalc) < 1e-9 # Should be TRUE  # Boundary conditions print(qbkw(c(0, 1), alpha_par, beta_par, gamma_par, delta_par)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qbkw(c(0, 1), alpha_par, beta_par, gamma_par, delta_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(qbkw(c(-Inf, 0), alpha_par, beta_par, gamma_par, delta_par, log_p = TRUE)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qbkw(c(-Inf, 0), alpha_par, beta_par, gamma_par, delta_par,     log_p = TRUE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"Computes quantile function (inverse CDF) Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)). finds value q \\(P(X \\le q) = p\\). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\) \\(\\delta = 0\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"","code":"qekw(p, alpha, beta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"p Vector probabilities (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. lambda Shape parameter lambda > 0 (exponent parameter). Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(p = P(X \\le q)\\), otherwise, probabilities \\(p = P(X > q)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, alpha, beta, lambda). Returns: 0 p = 0 (p = -Inf log_p = TRUE, lower_tail = TRUE). 1 p = 1 (p = 0 log_p = TRUE, lower_tail = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., alpha <= 0, beta <= 0, lambda <= 0). Boundary return values adjusted accordingly lower_tail = FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"quantile function \\(Q(p)\\) inverse CDF \\(F(q)\\). CDF EKw (\\(\\gamma=1, \\delta=0\\)) distribution \\(F(q) = [1 - (1 - q^\\alpha)^\\beta ]^\\lambda\\) (see pekw). Inverting equation \\(q\\) yields quantile function: $$ Q(p) = \\left\\{ 1 - \\left[ 1 - p^{1/\\lambda} \\right]^{1/\\beta} \\right\\}^{1/\\alpha} $$ function uses closed-form expression correctly handles lower_tail log_p arguments transforming p appropriately applying formula. equivalent general GKw quantile function (qgkw) evaluated \\(\\gamma=1, \\delta=0\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Function of the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî qekw","text":"","code":"# \\donttest{ # Example values p_vals <- c(0.1, 0.5, 0.9) alpha_par <- 2.0 beta_par <- 3.0 lambda_par <- 1.5  # Calculate quantiles quantiles <- qekw(p_vals, alpha_par, beta_par, lambda_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found  # Calculate quantiles for upper tail probabilities P(X > q) = p quantiles_upper <- qekw(p_vals, alpha_par, beta_par, lambda_par,                         lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_upper) #> Error: object 'quantiles_upper' not found # Check: qekw(p, ..., lt=F) == qekw(1-p, ..., lt=T) print(qekw(1 - p_vals, alpha_par, beta_par, lambda_par)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qekw(1 - p_vals, alpha_par, beta_par, lambda_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Calculate quantiles from log probabilities log_p_vals <- log(p_vals) quantiles_logp <- qekw(log_p_vals, alpha_par, beta_par, lambda_par,                        log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_logp) #> Error: object 'quantiles_logp' not found # Check: should match original quantiles print(quantiles) #> Error: object 'quantiles' not found  # Compare with qgkw setting gamma = 1, delta = 0 quantiles_gkw <- qgkw(p_vals, alpha = alpha_par, beta = beta_par,                      gamma = 1.0, delta = 0.0, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(quantiles - quantiles_gkw)))) # Should be near zero #> Error: object 'quantiles' not found  # Verify inverse relationship with pekw p_check <- 0.75 q_calc <- qekw(p_check, alpha_par, beta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_recalc <- pekw(q_calc, alpha_par, beta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Original p:\", p_check, \" Recalculated p:\", p_recalc)) #> Error: object 'p_recalc' not found # abs(p_check - p_recalc) < 1e-9 # Should be TRUE  # Boundary conditions print(qekw(c(0, 1), alpha_par, beta_par, lambda_par)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qekw(c(0, 1), alpha_par, beta_par, lambda_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(qekw(c(-Inf, 0), alpha_par, beta_par, lambda_par, log_p = TRUE)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qekw(c(-Inf, 0), alpha_par, beta_par, lambda_par, log_p = TRUE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"Computes quantile function (inverse CDF) five-parameter Generalized Kumaraswamy (GKw) distribution. Finds value x \\(P(X \\le x) = p\\), X follows GKw distribution.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"","code":"qgkw(p, alpha, beta, gamma, delta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"p Vector probabilities (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(P(X \\le x)\\), otherwise, \\(P(X > x)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, alpha, beta, gamma, delta, lambda). Returns: 0 p = 0 (p = -Inf log_p = TRUE). 1 p = 1 (p = 0 log_p = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., alpha <= 0, beta <= 0, gamma <= 0, delta < 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"quantile function \\(Q(p)\\) inverse CDF \\(F(x)\\). Given \\(F(x) = I_{y(x)}(\\gamma, \\delta+1)\\) \\(y(x) = [1-(1-x^{\\alpha})^{\\beta}]^{\\lambda}\\), quantile function : $$ Q(p) = x = \\left\\{ 1 - \\left[ 1 - \\left( ^{-1}_{p}(\\gamma, \\delta+1) \\right)^{1/\\lambda} \\right]^{1/\\beta} \\right\\}^{1/\\alpha} $$ \\(^{-1}_{p}(, b)\\) inverse regularized incomplete beta function, corresponds quantile function Beta distribution, qbeta. computation proceeds follows: Calculate y = stats::qbeta(p, shape1 = gamma, shape2 = delta + 1, lower.tail = lower_tail, log.p = log_p). Calculate \\(v = y^{1/\\lambda}\\). Calculate \\(w = (1 - v)^{1/\\beta}\\). Note: Requires \\(v \\le 1\\). Calculate \\(q = (1 - w)^{1/\\alpha}\\). Note: Requires \\(w \\le 1\\). Numerical stability maintained handling boundary cases (p = 0, p = 1) directly checking intermediate results (e.g., ensuring arguments powers non-negative).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Kumaraswamy Distribution Quantile Function ‚Äî qgkw","text":"","code":"# \\donttest{ # Basic quantile calculation (median) median_val <- qgkw(0.5, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(median_val) #> Error: object 'median_val' not found  # Computing multiple quantiles probs <- c(0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99) quantiles <- qgkw(probs, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found  # Upper tail quantile (e.g., find x such that P(X > x) = 0.1, which is 90th percentile) q90 <- qgkw(0.1, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1,             lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(q90) #> Error: object 'q90' not found # Check: should match quantile for p = 0.9 with lower_tail = TRUE print(qgkw(0.9, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qgkw(0.9, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Log probabilities median_logp <- qgkw(log(0.5), alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1,                     log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(median_logp) # Should match median_val #> Error: object 'median_logp' not found  # Vectorized parameters alphas_vec <- c(0.5, 1.0, 2.0) betas_vec <- c(1.0, 2.0, 3.0) # Get median for 3 different GKw distributions medians_vec <- qgkw(0.5, alpha = alphas_vec, beta = betas_vec, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(medians_vec) #> Error: object 'medians_vec' not found  # Verify inverse relationship with pgkw p_val <- 0.75 x_val <- qgkw(p_val, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_check <- pgkw(x_val, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Calculated p:\", p_check, \" (Expected:\", p_val, \")\")) #> Error: object 'p_check' not found # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"Computes quantile function (inverse CDF) Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). finds value q \\(P(X \\le q) = p\\). distribution special case Generalized Kumaraswamy (GKw) distribution parameter \\(\\gamma = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"","code":"qkkw(p, alpha, beta, delta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"p Vector probabilities (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(p = P(X \\le q)\\), otherwise, probabilities \\(p = P(X > q)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, alpha, beta, delta, lambda). Returns: 0 p = 0 (p = -Inf log_p = TRUE, lower_tail = TRUE). 1 p = 1 (p = 0 log_p = TRUE, lower_tail = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., alpha <= 0, beta <= 0, delta < 0, lambda <= 0). Boundary return values adjusted accordingly lower_tail = FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"quantile function \\(Q(p)\\) inverse CDF \\(F(q)\\). CDF kkw (\\(\\gamma=1\\)) distribution (see pkkw): $$ F(q) = 1 - \\bigl\\{1 - \\bigl[1 - (1 - q^\\alpha)^\\beta\\bigr]^\\lambda\\bigr\\}^{\\delta + 1} $$ Inverting equation \\(q\\) yields quantile function: $$ Q(p) = \\left[ 1 - \\left\\{ 1 - \\left[ 1 - (1 - p)^{1/(\\delta+1)} \\right]^{1/\\lambda} \\right\\}^{1/\\beta} \\right]^{1/\\alpha} $$ function uses closed-form expression correctly handles lower_tail log_p arguments transforming p appropriately applying formula.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Function of the Kumaraswamy-Kumaraswamy (kkw) Distribution ‚Äî qkkw","text":"","code":"# \\donttest{ # Example values p_vals <- c(0.1, 0.5, 0.9) alpha_par <- 2.0 beta_par <- 3.0 delta_par <- 0.5 lambda_par <- 1.5  # Calculate quantiles quantiles <- qkkw(p_vals, alpha_par, beta_par, delta_par, lambda_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found  # Calculate quantiles for upper tail probabilities P(X > q) = p # e.g., for p=0.1, find q such that P(X > q) = 0.1 (90th percentile) quantiles_upper <- qkkw(p_vals, alpha_par, beta_par, delta_par, lambda_par,                          lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_upper) #> Error: object 'quantiles_upper' not found # Check: qkkw(p, ..., lt=F) == qkkw(1-p, ..., lt=T) print(qkkw(1 - p_vals, alpha_par, beta_par, delta_par, lambda_par)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qkkw(1 - p_vals, alpha_par, beta_par, delta_par, lambda_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Calculate quantiles from log probabilities log_p_vals <- log(p_vals) quantiles_logp <- qkkw(log_p_vals, alpha_par, beta_par, delta_par, lambda_par,                         log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_logp) #> Error: object 'quantiles_logp' not found # Check: should match original quantiles print(quantiles) #> Error: object 'quantiles' not found  # Compare with qgkw setting gamma = 1 quantiles_gkw <- qgkw(p_vals, alpha_par, beta_par, gamma = 1.0,                       delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(quantiles - quantiles_gkw)))) # Should be near zero #> Error: object 'quantiles' not found  # Verify inverse relationship with pkkw p_check <- 0.75 q_calc <- qkkw(p_check, alpha_par, beta_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_recalc <- pkkw(q_calc, alpha_par, beta_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Original p:\", p_check, \" Recalculated p:\", p_recalc)) #> Error: object 'p_recalc' not found # abs(p_check - p_recalc) < 1e-9 # Should be TRUE  # Boundary conditions print(qkkw(c(0, 1), alpha_par, beta_par, delta_par, lambda_par)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qkkw(c(0, 1), alpha_par, beta_par, delta_par, lambda_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(qkkw(c(-Inf, 0), alpha_par, beta_par, delta_par, lambda_par, log_p = TRUE)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qkkw(c(-Inf, 0), alpha_par, beta_par, delta_par, lambda_par,     log_p = TRUE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"Computes quantile function (inverse CDF) two-parameter Kumaraswamy (Kw) distribution shape parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)). finds value q \\(P(X \\le q) = p\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"","code":"qkw(p, alpha, beta, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"p Vector probabilities (values 0 1). alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(p = P(X \\le q)\\), otherwise, probabilities \\(p = P(X > q)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, alpha, beta). Returns: 0 p = 0 (p = -Inf log_p = TRUE, lower_tail = TRUE). 1 p = 1 (p = 0 log_p = TRUE, lower_tail = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., alpha <= 0, beta <= 0). Boundary return values adjusted accordingly lower_tail = FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"quantile function \\(Q(p)\\) inverse CDF \\(F(q)\\). CDF Kumaraswamy distribution \\(F(q) = 1 - (1 - q^\\alpha)^\\beta\\) (see pkw). Inverting equation \\(q\\) yields quantile function: $$ Q(p) = \\left\\{ 1 - (1 - p)^{1/\\beta} \\right\\}^{1/\\alpha} $$ function uses closed-form expression correctly handles lower_tail log_p arguments transforming p appropriately applying formula. equivalent general GKw quantile function (qgkw) evaluated \\(\\gamma=1, \\delta=0, \\lambda=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Function of the Kumaraswamy (Kw) Distribution ‚Äî qkw","text":"","code":"# \\donttest{ # Example values p_vals <- c(0.1, 0.5, 0.9) alpha_par <- 2.0 beta_par <- 3.0  # Calculate quantiles using qkw quantiles <- qkw(p_vals, alpha_par, beta_par) #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found  # Calculate quantiles for upper tail probabilities P(X > q) = p quantiles_upper <- qkw(p_vals, alpha_par, beta_par, lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_upper) #> Error: object 'quantiles_upper' not found  # Calculate quantiles from log probabilities log_p_vals <- log(p_vals) quantiles_logp <- qkw(log_p_vals, alpha_par, beta_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_logp) #> Error: object 'quantiles_logp' not found # Check: should match original quantiles print(quantiles) #> Error: object 'quantiles' not found  # Compare with qgkw setting gamma = 1, delta = 0, lambda = 1 quantiles_gkw <- qgkw(p_vals, alpha = alpha_par, beta = beta_par,                      gamma = 1.0, delta = 0.0, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(quantiles - quantiles_gkw)))) # Should be near zero #> Error: object 'quantiles' not found  # Verify inverse relationship with pkw p_check <- 0.75 q_calc <- qkw(p_check, alpha_par, beta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_recalc <- pkw(q_calc, alpha_par, beta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Original p:\", p_check, \" Recalculated p:\", p_recalc)) #> Error: object 'p_recalc' not found # abs(p_check - p_recalc) < 1e-9 # Should be TRUE  # Boundary conditions print(qkw(c(0, 1), alpha_par, beta_par)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qkw(c(0, 1), alpha_par, beta_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(qkw(c(-Inf, 0), alpha_par, beta_par, log_p = TRUE)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qkw(c(-Inf, 0), alpha_par, beta_par, log_p = TRUE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"Computes quantile function (inverse CDF) McDonald (Mc) distribution (also known Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). finds value q \\(P(X \\le q) = p\\). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\) \\(\\beta = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"","code":"qmc(p, gamma, delta, lambda, lower_tail = TRUE, log_p = FALSE)"},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"p Vector probabilities (values 0 1). gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0. lower_tail Logical; TRUE (default), probabilities \\(p = P(X \\le q)\\), otherwise, probabilities \\(p = P(X > q)\\). log_p Logical; TRUE, probabilities p given \\(\\log(p)\\). Default: FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"vector quantiles corresponding given probabilities p. length result determined recycling rule applied arguments (p, gamma, delta, lambda). Returns: 0 p = 0 (p = -Inf log_p = TRUE, lower_tail = TRUE). 1 p = 1 (p = 0 log_p = TRUE, lower_tail = TRUE). NaN p < 0 p > 1 (corresponding log scale). NaN invalid parameters (e.g., gamma <= 0, delta < 0, lambda <= 0). Boundary return values adjusted accordingly lower_tail = FALSE.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"quantile function \\(Q(p)\\) inverse CDF \\(F(q)\\). CDF Mc (\\(\\alpha=1, \\beta=1\\)) distribution \\(F(q) = I_{q^\\lambda}(\\gamma, \\delta+1)\\), \\(I_z(,b)\\) regularized incomplete beta function (see pmc). find quantile \\(q\\), first invert Beta function part: let \\(y = ^{-1}_{p}(\\gamma, \\delta+1)\\), \\(^{-1}_p(,b)\\) inverse computed via qbeta. solve \\(q^\\lambda = y\\) \\(q\\), yielding quantile function: $$ Q(p) = \\left[ ^{-1}_{p}(\\gamma, \\delta+1) \\right]^{1/\\lambda} $$ function uses formula, calculating \\(^{-1}_{p}(\\gamma, \\delta+1)\\) via qbeta(p, gamma, delta + 1, ...) respecting lower_tail log_p arguments. equivalent general GKw quantile function (qgkw) evaluated \\(\\alpha=1, \\beta=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/qmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile Function of the McDonald (Mc)/Beta Power Distribution ‚Äî qmc","text":"","code":"# \\donttest{ # Example values p_vals <- c(0.1, 0.5, 0.9) gamma_par <- 2.0 delta_par <- 1.5 lambda_par <- 1.0 # Equivalent to Beta(gamma, delta+1)  # Calculate quantiles using qmc quantiles <- qmc(p_vals, gamma_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles) #> Error: object 'quantiles' not found # Compare with Beta quantiles print(stats::qbeta(p_vals, shape1 = gamma_par, shape2 = delta_par + 1)) #> [1] 0.1649288 0.4355544 0.7379563  # Calculate quantiles for upper tail probabilities P(X > q) = p quantiles_upper <- qmc(p_vals, gamma_par, delta_par, lambda_par,                        lower_tail = FALSE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_upper) #> Error: object 'quantiles_upper' not found # Check: qmc(p, ..., lt=F) == qmc(1-p, ..., lt=T) print(qmc(1 - p_vals, gamma_par, delta_par, lambda_par)) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qmc(1 - p_vals, gamma_par, delta_par, lambda_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # Calculate quantiles from log probabilities log_p_vals <- log(p_vals) quantiles_logp <- qmc(log_p_vals, gamma_par, delta_par, lambda_par, log_p = TRUE) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(quantiles_logp) #> Error: object 'quantiles_logp' not found # Check: should match original quantiles print(quantiles) #> Error: object 'quantiles' not found  # Compare with qgkw setting alpha = 1, beta = 1 quantiles_gkw <- qgkw(p_vals, alpha = 1.0, beta = 1.0, gamma = gamma_par,                       delta = delta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Max difference:\", max(abs(quantiles - quantiles_gkw)))) # Should be near zero #> Error: object 'quantiles' not found  # Verify inverse relationship with pmc p_check <- 0.75 q_calc <- qmc(p_check, gamma_par, delta_par, lambda_par) # Use lambda != 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt p_recalc <- pmc(q_calc, gamma_par, delta_par, lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(paste(\"Original p:\", p_check, \" Recalculated p:\", p_recalc)) #> Error: object 'p_recalc' not found # abs(p_check - p_recalc) < 1e-9 # Should be TRUE  # Boundary conditions print(qmc(c(0, 1), gamma_par, delta_par, lambda_par)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qmc(c(0, 1), gamma_par, delta_par, lambda_par)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(qmc(c(-Inf, 0), gamma_par, delta_par, lambda_par, log_p = TRUE)) # Should be 0, 1 #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in print(qmc(c(-Inf, 0), gamma_par, delta_par, lambda_par, log_p = TRUE)): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"Generates random deviates standard Beta distribution, using parameterization common generalized distribution families. distribution parameterized gamma (\\(\\gamma\\)) delta (\\(\\delta\\)), corresponding standard Beta distribution shape parameters shape1 = gamma shape2 = delta + 1. special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\), \\(\\beta = 1\\), \\(\\lambda = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"","code":"rbeta_(n, gamma, delta)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. gamma First shape parameter (shape1), \\(\\gamma > 0\\). Can scalar vector. Default: 1.0. delta Second shape parameter delta + 1 (shape2), requires \\(\\delta \\ge 0\\) shape2 >= 1. Can scalar vector. Default: 0.0 (leading shape2 = 1, .e., Uniform).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"numeric vector length n containing random deviates Beta(\\(\\gamma, \\delta+1\\)) distribution, values (0, 1). length result determined n recycling rule applied parameters (gamma, delta). Returns NaN parameters invalid (e.g., gamma <= 0, delta < 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"function generates samples Beta distribution parameters shape1 = gamma shape2 = delta + 1. equivalent calling stats::rbeta(n, shape1 = gamma, shape2 = delta + 1). distribution arises special case five-parameter Generalized Kumaraswamy (GKw) distribution (rgkw) obtained setting \\(\\alpha = 1\\), \\(\\beta = 1\\), \\(\\lambda = 1\\). therefore also equivalent McDonald (Mc)/Beta Power distribution (rmc) \\(\\lambda = 1\\). function likely calls R's underlying rbeta function ensures consistent parameter recycling handling within C++ environment, matching style functions related families.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"Johnson, N. L., Kotz, S., & Balakrishnan, N. (1995). Continuous Univariate Distributions, Volume 2 (2nd ed.). Wiley. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbeta_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Generation for the Beta Distribution (gamma, delta+1 Parameterization) ‚Äî rbeta_","text":"","code":"# \\donttest{ set.seed(2030) # for reproducibility  # Generate 1000 samples using rbeta_ gamma_par <- 2.0 # Corresponds to shape1 delta_par <- 3.0 # Corresponds to shape2 - 1 shape1 <- gamma_par shape2 <- delta_par + 1  x_sample <- rbeta_(1000, gamma = gamma_par, delta = delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample) #> Error: object 'x_sample' not found  # Compare with stats::rbeta x_sample_stats <- stats::rbeta(1000, shape1 = shape1, shape2 = shape2) # Visually compare histograms or QQ-plots hist(x_sample, main=\"rbeta_ Sample\", freq=FALSE, breaks=30) #> Error: object 'x_sample' not found curve(dbeta_(x, gamma_par, delta_par), add=TRUE, col=\"red\", lwd=2) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt hist(x_sample_stats, main=\"stats::rbeta Sample\", freq=FALSE, breaks=30) curve(stats::dbeta(x, shape1, shape2), add=TRUE, col=\"blue\", lwd=2)  # Compare summary stats (should be similar due to randomness) print(summary(x_sample)) #> Error: object 'x_sample' not found print(summary(x_sample_stats)) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #> 0.007135 0.190328 0.306978 0.335931 0.466661 0.886553   # Compare summary stats with rgkw(alpha=1, beta=1, lambda=1) x_sample_gkw <- rgkw(1000, alpha = 1.0, beta = 1.0, gamma = gamma_par,                      delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rgkw(a=1,b=1,l=1) sample:\") #> [1] \"Summary stats for rgkw(a=1,b=1,l=1) sample:\" print(summary(x_sample_gkw)) #> Error: object 'x_sample_gkw' not found  # Compare summary stats with rmc(lambda=1) x_sample_mc <- rmc(1000, gamma = gamma_par, delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rmc(l=1) sample:\") #> [1] \"Summary stats for rmc(l=1) sample:\" print(summary(x_sample_mc)) #> Error: object 'x_sample_mc' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"Generates random deviates Beta-Kumaraswamy (BKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), gamma (\\(\\gamma\\)), delta (\\(\\delta\\)). distribution special case Generalized Kumaraswamy (GKw) distribution parameter \\(\\lambda = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"","code":"rbkw(n, alpha, beta, gamma, delta)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"vector length n containing random deviates BKw distribution. length result determined n recycling rule applied parameters (alpha, beta, gamma, delta). Returns NaN parameters invalid (e.g., alpha <= 0, beta <= 0, gamma <= 0, delta < 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"generation method uses relationship GKw distribution Beta distribution. general procedure GKw (rgkw) : \\(W \\sim \\mathrm{Beta}(\\gamma, \\delta+1)\\), \\(X = \\{1 - [1 - W^{1/\\lambda}]^{1/\\beta}\\}^{1/\\alpha}\\) follows GKw(\\(\\alpha, \\beta, \\gamma, \\delta, \\lambda\\)) distribution. BKw distribution, \\(\\lambda=1\\). Therefore, algorithm simplifies : Generate \\(V \\sim \\mathrm{Beta}(\\gamma, \\delta+1)\\) using rbeta. Compute BKw variate \\(X = \\{1 - (1 - V)^{1/\\beta}\\}^{1/\\alpha}\\). procedure implemented efficiently, handling parameter recycling needed.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag. (General methods random variate generation).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rbkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Number Generation for the Beta-Kumaraswamy (BKw) Distribution ‚Äî rbkw","text":"","code":"# \\donttest{ set.seed(2026) # for reproducibility  # Generate 1000 random values from a specific BKw distribution alpha_par <- 2.0 beta_par <- 1.5 gamma_par <- 1.0 delta_par <- 0.5  x_sample_bkw <- rbkw(1000, alpha = alpha_par, beta = beta_par,                      gamma = gamma_par, delta = delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample_bkw) #> Error: object 'x_sample_bkw' not found  # Histogram of generated values compared to theoretical density hist(x_sample_bkw, breaks = 30, freq = FALSE, # freq=FALSE for density      main = \"Histogram of BKw Sample\", xlab = \"x\", ylim = c(0, 2.5)) #> Error: object 'x_sample_bkw' not found curve(dbkw(x, alpha = alpha_par, beta = beta_par, gamma = gamma_par,            delta = delta_par),       add = TRUE, col = \"red\", lwd = 2, n = 201) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Comparing empirical and theoretical quantiles (Q-Q plot) prob_points <- seq(0.01, 0.99, by = 0.01) theo_quantiles <- qbkw(prob_points, alpha = alpha_par, beta = beta_par,                        gamma = gamma_par, delta = delta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt emp_quantiles <- quantile(x_sample_bkw, prob_points, type = 7) #> Error: object 'x_sample_bkw' not found  plot(theo_quantiles, emp_quantiles, pch = 16, cex = 0.8,      main = \"Q-Q Plot for BKw Distribution\",      xlab = \"Theoretical Quantiles\", ylab = \"Empirical Quantiles (n=1000)\") #> Error: object 'theo_quantiles' not found abline(a = 0, b = 1, col = \"blue\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Compare summary stats with rgkw(..., lambda=1, ...) # Note: individual values will differ due to randomness x_sample_gkw <- rgkw(1000, alpha = alpha_par, beta = beta_par, gamma = gamma_par,                      delta = delta_par, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rbkw sample:\") #> [1] \"Summary stats for rbkw sample:\" print(summary(x_sample_bkw)) #> Error: object 'x_sample_bkw' not found print(\"Summary stats for rgkw(lambda=1) sample:\") #> [1] \"Summary stats for rgkw(lambda=1) sample:\" print(summary(x_sample_gkw)) # Should be similar #> Error: object 'x_sample_gkw' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"Generates random deviates Exponentiated Kumaraswamy (EKw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\gamma = 1\\) \\(\\delta = 0\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"","code":"rekw(n, alpha, beta, lambda)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. lambda Shape parameter lambda > 0 (exponent parameter). Can scalar vector. Default: 1.0.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"vector length n containing random deviates EKw distribution. length result determined n recycling rule applied parameters (alpha, beta, lambda). Returns NaN parameters invalid (e.g., alpha <= 0, beta <= 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"generation method uses inverse transform (quantile) method. , \\(U\\) random variable following standard Uniform distribution (0, 1), \\(X = Q(U)\\) follows EKw distribution, \\(Q(u)\\) EKw quantile function (qekw): $$ Q(u) = \\left\\{ 1 - \\left[ 1 - u^{1/\\lambda} \\right]^{1/\\beta} \\right\\}^{1/\\alpha} $$ computationally equivalent general GKw generation method (rgkw) specialized \\(\\gamma=1, \\delta=0\\), required Beta(1, 1) random variate equivalent standard Uniform(0, 1) variate. implementation generates \\(U\\) using runif applies transformation .","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"Nadarajah, S., Cordeiro, G. M., & Ortega, E. M. (2012). exponentiated Kumaraswamy distribution. Journal Franklin Institute, 349(3), Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag. (General methods random variate generation).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rekw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Number Generation for the Exponentiated Kumaraswamy (EKw) Distribution ‚Äî rekw","text":"","code":"# \\donttest{ set.seed(2027) # for reproducibility  # Generate 1000 random values from a specific EKw distribution alpha_par <- 2.0 beta_par <- 3.0 lambda_par <- 1.5  x_sample_ekw <- rekw(1000, alpha = alpha_par, beta = beta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample_ekw) #> Error: object 'x_sample_ekw' not found  # Histogram of generated values compared to theoretical density hist(x_sample_ekw, breaks = 30, freq = FALSE, # freq=FALSE for density      main = \"Histogram of EKw Sample\", xlab = \"x\", ylim = c(0, 3.0)) #> Error: object 'x_sample_ekw' not found curve(dekw(x, alpha = alpha_par, beta = beta_par, lambda = lambda_par),       add = TRUE, col = \"red\", lwd = 2, n = 201) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Comparing empirical and theoretical quantiles (Q-Q plot) prob_points <- seq(0.01, 0.99, by = 0.01) theo_quantiles <- qekw(prob_points, alpha = alpha_par, beta = beta_par,                        lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt emp_quantiles <- quantile(x_sample_ekw, prob_points, type = 7) #> Error: object 'x_sample_ekw' not found  plot(theo_quantiles, emp_quantiles, pch = 16, cex = 0.8,      main = \"Q-Q Plot for EKw Distribution\",      xlab = \"Theoretical Quantiles\", ylab = \"Empirical Quantiles (n=1000)\") #> Error: object 'theo_quantiles' not found abline(a = 0, b = 1, col = \"blue\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Compare summary stats with rgkw(..., gamma=1, delta=0, ...) # Note: individual values will differ due to randomness x_sample_gkw <- rgkw(1000, alpha = alpha_par, beta = beta_par, gamma = 1.0,                      delta = 0.0, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rekw sample:\") #> [1] \"Summary stats for rekw sample:\" print(summary(x_sample_ekw)) #> Error: object 'x_sample_ekw' not found print(\"Summary stats for rgkw(gamma=1, delta=0) sample:\") #> [1] \"Summary stats for rgkw(gamma=1, delta=0) sample:\" print(summary(x_sample_gkw)) # Should be similar #> Error: object 'x_sample_gkw' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"Generates random deviates five-parameter Generalized Kumaraswamy (GKw) distribution defined interval (0, 1).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"","code":"rgkw(n, alpha, beta, gamma, delta, lambda)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"vector length n containing random deviates GKw distribution. length result determined n recycling rule applied parameters (alpha, beta, gamma, delta, lambda). Returns NaN parameters invalid (e.g., alpha <= 0, beta <= 0, gamma <= 0, delta < 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"generation method relies transformation property: \\(V \\sim \\mathrm{Beta}(\\gamma, \\delta+1)\\), random variable X defined $$ X = \\left\\{ 1 - \\left[ 1 - V^{1/\\lambda} \\right]^{1/\\beta} \\right\\}^{1/\\alpha} $$ follows GKw(\\(\\alpha, \\beta, \\gamma, \\delta, \\lambda\\)) distribution. algorithm proceeds follows: Generate V stats::rbeta(n, shape1 = gamma, shape2 = delta + 1). Calculate \\(v = V^{1/\\lambda}\\). Calculate \\(w = (1 - v)^{1/\\beta}\\). Calculate \\(x = (1 - w)^{1/\\alpha}\\). Parameters (alpha, beta, gamma, delta, lambda) recycled match length required n. Numerical stability maintained handling potential edge cases transformations.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88.","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rgkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Kumaraswamy Distribution Random Generation ‚Äî rgkw","text":"","code":"# \\donttest{ set.seed(1234) # for reproducibility  # Generate 1000 random values from a specific GKw distribution (Kw case) x_sample <- rgkw(1000, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample) #> Error: object 'x_sample' not found  # Histogram of generated values compared to theoretical density hist(x_sample, breaks = 30, freq = FALSE, # freq=FALSE for density scale      main = \"Histogram of GKw(2,3,1,0,1) Sample\", xlab = \"x\", ylim = c(0, 2.5)) #> Error: object 'x_sample' not found curve(dgkw(x, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1),       add = TRUE, col = \"red\", lwd = 2, n = 201) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Comparing empirical and theoretical quantiles (Q-Q plot) prob_points <- seq(0.01, 0.99, by = 0.01) theo_quantiles <- qgkw(prob_points, alpha = 2, beta = 3, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt emp_quantiles <- quantile(x_sample, prob_points) #> Error: object 'x_sample' not found  plot(theo_quantiles, emp_quantiles, pch = 16, cex = 0.8,      main = \"Q-Q Plot for GKw(2,3,1,0,1)\",      xlab = \"Theoretical Quantiles\", ylab = \"Empirical Quantiles (n=1000)\") #> Error: object 'theo_quantiles' not found abline(a = 0, b = 1, col = \"blue\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Using vectorized parameters: generate 1 value for each alpha alphas_vec <- c(0.5, 1.0, 2.0) n_param <- length(alphas_vec) samples_vec <- rgkw(n_param, alpha = alphas_vec, beta = 2, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(samples_vec) # One sample for each alpha value #> Error: object 'samples_vec' not found # Result length matches n=3, parameters alpha recycled accordingly  # Example with invalid parameters (should produce NaN) invalid_sample <- rgkw(1, alpha = -1, beta = 2, gamma = 1, delta = 0, lambda = 1) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(invalid_sample) #> Error: object 'invalid_sample' not found # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Number Generation for the kkw Distribution ‚Äî rkkw","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"Generates random deviates Kumaraswamy-Kumaraswamy (kkw) distribution parameters alpha (\\(\\alpha\\)), beta (\\(\\beta\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution parameter \\(\\gamma = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"","code":"rkkw(n, alpha, beta, delta, lambda)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"vector length n containing random deviates kkw distribution. length result determined n recycling rule applied parameters (alpha, beta, delta, lambda). Returns NaN parameters invalid (e.g., alpha <= 0, beta <= 0, delta < 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"generation method uses inverse transform method based quantile function (qkkw). kkw quantile function : $$ Q(p) = \\left[ 1 - \\left\\{ 1 - \\left[ 1 - (1 - p)^{1/(\\delta+1)} \\right]^{1/\\lambda} \\right\\}^{1/\\beta} \\right]^{1/\\alpha} $$ Random deviates generated evaluating \\(Q(p)\\) \\(p\\) random variable following standard Uniform distribution (0, 1) (runif). equivalent general method GKw distribution (rgkw) specialized \\(\\gamma=1\\). GKw method generates \\(W \\sim \\mathrm{Beta}(\\gamma, \\delta+1)\\) applies transformations. \\(\\gamma=1\\), \\(W \\sim \\mathrm{Beta}(1, \\delta+1)\\), can generated via \\(W = 1 - V^{1/(\\delta+1)}\\) \\(V \\sim \\mathrm{Unif}(0,1)\\). Substituting \\(W\\) GKw transformation yields result evaluating \\(Q(1-V)\\) (noting \\(p = 1-V\\) also Uniform).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag. (General methods random variate generation).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Number Generation for the kkw Distribution ‚Äî rkkw","text":"","code":"# \\donttest{ set.seed(2025) # for reproducibility  # Generate 1000 random values from a specific kkw distribution alpha_par <- 2.0 beta_par <- 3.0 delta_par <- 0.5 lambda_par <- 1.5  x_sample_kkw <- rkkw(1000, alpha = alpha_par, beta = beta_par,                        delta = delta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample_kkw) #> Error: object 'x_sample_kkw' not found  # Histogram of generated values compared to theoretical density hist(x_sample_kkw, breaks = 30, freq = FALSE, # freq=FALSE for density      main = \"Histogram of kkw Sample\", xlab = \"x\", ylim = c(0, 3.5)) #> Error: object 'x_sample_kkw' not found curve(dkkw(x, alpha = alpha_par, beta = beta_par, delta = delta_par,             lambda = lambda_par),       add = TRUE, col = \"red\", lwd = 2, n = 201) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"topright\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Comparing empirical and theoretical quantiles (Q-Q plot) prob_points <- seq(0.01, 0.99, by = 0.01) theo_quantiles <- qkkw(prob_points, alpha = alpha_par, beta = beta_par,                         delta = delta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt emp_quantiles <- quantile(x_sample_kkw, prob_points, type = 7) # type 7 is default #> Error: object 'x_sample_kkw' not found  plot(theo_quantiles, emp_quantiles, pch = 16, cex = 0.8,      main = \"Q-Q Plot for kkw Distribution\",      xlab = \"Theoretical Quantiles\", ylab = \"Empirical Quantiles (n=1000)\") #> Error: object 'theo_quantiles' not found abline(a = 0, b = 1, col = \"blue\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Compare summary stats with rgkw(..., gamma=1, ...) # Note: individual values will differ due to randomness x_sample_gkw <- rgkw(1000, alpha = alpha_par, beta = beta_par, gamma = 1.0,                      delta = delta_par, lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rkkw sample:\") #> [1] \"Summary stats for rkkw sample:\" print(summary(x_sample_kkw)) #> Error: object 'x_sample_kkw' not found print(\"Summary stats for rgkw(gamma=1) sample:\") #> [1] \"Summary stats for rgkw(gamma=1) sample:\" print(summary(x_sample_gkw)) # Should be similar #> Error: object 'x_sample_gkw' not found # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"Generates random deviates two-parameter Kumaraswamy (Kw) distribution shape parameters alpha (\\(\\alpha\\)) beta (\\(\\beta\\)).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"","code":"rkw(n, alpha, beta)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. alpha Shape parameter alpha > 0. Can scalar vector. Default: 1.0. beta Shape parameter beta > 0. Can scalar vector. Default: 1.0.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"vector length n containing random deviates Kw distribution, values (0, 1). length result determined n recycling rule applied parameters (alpha, beta). Returns NaN parameters invalid (e.g., alpha <= 0, beta <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"generation method uses inverse transform (quantile) method. , \\(U\\) random variable following standard Uniform distribution (0, 1), \\(X = Q(U)\\) follows Kw distribution, \\(Q(p)\\) Kw quantile function (qkw): $$ Q(p) = \\left\\{ 1 - (1 - p)^{1/\\beta} \\right\\}^{1/\\alpha} $$ implementation generates \\(U\\) using runif applies transformation. equivalent general GKw generation method (rgkw) evaluated \\(\\gamma=1, \\delta=0, \\lambda=1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Jones, M. C. (2009). Kumaraswamy's distribution: beta-type distribution tractability advantages. Statistical Methodology, 6(1), 70-81. Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag. (General methods random variate generation).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rkw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Number Generation for the Kumaraswamy (Kw) Distribution ‚Äî rkw","text":"","code":"# \\donttest{ set.seed(2029) # for reproducibility  # Generate 1000 random values from a specific Kw distribution alpha_par <- 2.0 beta_par <- 3.0  x_sample_kw <- rkw(1000, alpha = alpha_par, beta = beta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample_kw) #> Error: object 'x_sample_kw' not found  # Histogram of generated values compared to theoretical density hist(x_sample_kw, breaks = 30, freq = FALSE, # freq=FALSE for density      main = \"Histogram of Kw Sample\", xlab = \"x\", ylim = c(0, 2.5)) #> Error: object 'x_sample_kw' not found curve(dkw(x, alpha = alpha_par, beta = beta_par),       add = TRUE, col = \"red\", lwd = 2, n = 201) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt legend(\"top\", legend = \"Theoretical PDF\", col = \"red\", lwd = 2, bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Comparing empirical and theoretical quantiles (Q-Q plot) prob_points <- seq(0.01, 0.99, by = 0.01) theo_quantiles <- qkw(prob_points, alpha = alpha_par, beta = beta_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt emp_quantiles <- quantile(x_sample_kw, prob_points, type = 7) #> Error: object 'x_sample_kw' not found  plot(theo_quantiles, emp_quantiles, pch = 16, cex = 0.8,      main = \"Q-Q Plot for Kw Distribution\",      xlab = \"Theoretical Quantiles\", ylab = \"Empirical Quantiles (n=1000)\") #> Error: object 'theo_quantiles' not found abline(a = 0, b = 1, col = \"blue\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Compare summary stats with rgkw(..., gamma=1, delta=0, lambda=1) # Note: individual values will differ due to randomness x_sample_gkw <- rgkw(1000, alpha = alpha_par, beta = beta_par, gamma = 1.0,                      delta = 0.0, lambda = 1.0) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rkw sample:\") #> [1] \"Summary stats for rkw sample:\" print(summary(x_sample_kw)) #> Error: object 'x_sample_kw' not found print(\"Summary stats for rgkw(gamma=1, delta=0, lambda=1) sample:\") #> [1] \"Summary stats for rgkw(gamma=1, delta=0, lambda=1) sample:\" print(summary(x_sample_gkw)) # Should be similar #> Error: object 'x_sample_gkw' not found  # }"},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"Generates random deviates McDonald (Mc) distribution (also known Beta Power) parameters gamma (\\(\\gamma\\)), delta (\\(\\delta\\)), lambda (\\(\\lambda\\)). distribution special case Generalized Kumaraswamy (GKw) distribution \\(\\alpha = 1\\) \\(\\beta = 1\\).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"","code":"rmc(n, gamma, delta, lambda)"},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"n Number observations. length(n) > 1, length taken number required. Must non-negative integer. gamma Shape parameter gamma > 0. Can scalar vector. Default: 1.0. delta Shape parameter delta >= 0. Can scalar vector. Default: 0.0. lambda Shape parameter lambda > 0. Can scalar vector. Default: 1.0.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"vector length n containing random deviates Mc distribution, values (0, 1). length result determined n recycling rule applied parameters (gamma, delta, lambda). Returns NaN parameters invalid (e.g., gamma <= 0, delta < 0, lambda <= 0).","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"generation method uses relationship GKw distribution Beta distribution. general procedure GKw (rgkw) : \\(W \\sim \\mathrm{Beta}(\\gamma, \\delta+1)\\), \\(X = \\{1 - [1 - W^{1/\\lambda}]^{1/\\beta}\\}^{1/\\alpha}\\) follows GKw(\\(\\alpha, \\beta, \\gamma, \\delta, \\lambda\\)) distribution. Mc distribution, \\(\\alpha=1\\) \\(\\beta=1\\). Therefore, algorithm simplifies significantly: Generate \\(U \\sim \\mathrm{Beta}(\\gamma, \\delta+1)\\) using rbeta. Compute Mc variate \\(X = U^{1/\\lambda}\\). procedure implemented efficiently, handling parameter recycling needed.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"McDonald, J. B. (1984). generalized functions size distribution income. Econometrica, 52(3), 647-663. Cordeiro, G. M., & de Castro, M. (2011). new family generalized distributions. Journal Statistical Computation Simulation, Kumaraswamy, P. (1980). generalized probability density function double-bounded random processes. Journal Hydrology, 46(1-2), 79-88. Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag. (General methods random variate generation).","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"Lopes, J. E.","code":""},{"path":"https://evandeilton.github.io/gkwdist/reference/rmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Number Generation for the McDonald (Mc)/Beta Power Distribution ‚Äî rmc","text":"","code":"# \\donttest{ set.seed(2028) # for reproducibility  # Generate 1000 random values from a specific Mc distribution gamma_par <- 2.0 delta_par <- 1.5 lambda_par <- 1.0 # Equivalent to Beta(gamma, delta+1)  x_sample_mc <- rmc(1000, gamma = gamma_par, delta = delta_par,                    lambda = lambda_par) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt summary(x_sample_mc) #> Error: object 'x_sample_mc' not found  # Histogram of generated values compared to theoretical density hist(x_sample_mc, breaks = 30, freq = FALSE, # freq=FALSE for density      main = \"Histogram of Mc Sample (Beta Case)\", xlab = \"x\") #> Error: object 'x_sample_mc' not found curve(dmc(x, gamma = gamma_par, delta = delta_par, lambda = lambda_par),       add = TRUE, col = \"red\", lwd = 2, n = 201) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error in eval(expr, envir = ll, enclos = parent.frame()): lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt curve(stats::dbeta(x, gamma_par, delta_par + 1), add=TRUE, col=\"blue\", lty=2) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet legend(\"topright\", legend = c(\"Theoretical Mc PDF\", \"Theoretical Beta PDF\"),        col = c(\"red\", \"blue\"), lwd = c(2,1), lty=c(1,2), bty = \"n\") #> Error in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL,     ...) {    if (!is.null(vfont))         vfont <- c(typeface = pmatch(vfont[1L], Hershey$typeface),             fontindex = pmatch(vfont[2L], Hershey$fontindex))    .External.graphics(C_strWidth, as.graphicsAnnot(s), pmatch(units,         c(\"user\", \"figure\", \"inches\")), cex, font, vfont, ...)})(dots[[1L]][[1L]], cex = dots[[2L]][[1L]], font = dots[[3L]][[1L]],     units = \"user\"): plot.new has not been called yet  # Comparing empirical and theoretical quantiles (Q-Q plot) lambda_par_qq <- 0.7 # Use lambda != 1 for non-Beta case x_sample_mc_qq <- rmc(1000, gamma = gamma_par, delta = delta_par,                       lambda = lambda_par_qq) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt prob_points <- seq(0.01, 0.99, by = 0.01) theo_quantiles <- qmc(prob_points, gamma = gamma_par, delta = delta_par,                       lambda = lambda_par_qq) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt emp_quantiles <- quantile(x_sample_mc_qq, prob_points, type = 7) #> Error: object 'x_sample_mc_qq' not found  plot(theo_quantiles, emp_quantiles, pch = 16, cex = 0.8,      main = \"Q-Q Plot for Mc Distribution\",      xlab = \"Theoretical Quantiles\", ylab = \"Empirical Quantiles (n=1000)\") #> Error: object 'theo_quantiles' not found abline(a = 0, b = 1, col = \"blue\", lty = 2) #> Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet  # Compare summary stats with rgkw(..., alpha=1, beta=1, ...) # Note: individual values will differ due to randomness x_sample_gkw <- rgkw(1000, alpha = 1.0, beta = 1.0, gamma = gamma_par,                      delta = delta_par, lambda = lambda_par_qq) #> Warning: restarting interrupted promise evaluation #> Warning: internal error 1 in R_decompress1 with libdeflate #> Error: lazy-load database '/home/jlopes/R/x86_64-pc-linux-gnu-library/4.5/gkwdist/R/gkwdist.rdb' is corrupt print(\"Summary stats for rmc sample:\") #> [1] \"Summary stats for rmc sample:\" print(summary(x_sample_mc_qq)) #> Error: object 'x_sample_mc_qq' not found print(\"Summary stats for rgkw(alpha=1, beta=1) sample:\") #> [1] \"Summary stats for rgkw(alpha=1, beta=1) sample:\" print(summary(x_sample_gkw)) # Should be similar #> Error: object 'x_sample_gkw' not found  # }"},{"path":[]},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"documentation-improvements-1-0-5","dir":"Changelog","previous_headings":"","what":"Documentation Improvements","title":"gkwdist 1.0.5","text":"Enhanced Examples Likelihood Functions: ll*, gr*, hs* functions now include comprehensive examples demonstrating: Maximum likelihood estimation analytical gradients Univariate profile likelihoods confidence thresholds 2D likelihood surfaces confidence regions (90%, 95%, 99%) Confidence ellipses marginal intervals parameter pairs Numerical vs analytical derivative verification Likelihood ratio tests score tests Professional Visualization Standards: Consistent color scheme across examples Grid-adaptive algorithms computational efficiency Base R - external dependencies required Complete Coverage: Enhanced documentation distribution families (Kw, EKw, KKw, GKw) covering 2 5 parameters Theoretical References: Documentation cites foundational work Carrasco et al.¬†(2010), Jones (2009), Kumaraswamy (1980), standard inference theory Casella & Berger (2002)","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"gkwdist-103","dir":"Changelog","previous_headings":"","what":"gkwdist 1.0.3","title":"gkwdist 1.0.3","text":"Fix zzz.R file removing useless texts","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"enhanced-gkwgetstartvalues-function-1-0-1","dir":"Changelog","previous_headings":"Major Improvements","what":"Enhanced gkwgetstartvalues() Function","title":"gkwdist 1.0.1","text":"Automatically returns correct number parameters family Family-specific initial value strategies better convergence Supported families: \"gkw\", \"bkw\", \"kkw\", \"ekw\", \"mc\", \"kw\", \"beta\" Case-insensitive family names user convenience","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"documentation-enhancements-1-0-1","dir":"Changelog","previous_headings":"Major Improvements","what":"Documentation Enhancements","title":"gkwdist 1.0.1","text":"LaTeX formulas corrected verified proper rendering Eight comprehensive examples using optim() analytical gradients Corrected function signatures: ll*(), gr*(), hs*() functions use (par, data) signature Added performance benchmarks demonstrating 10-50√ó speedup C++ implementation Hierarchical structure diagram distribution families Model selection workflow practical guidelines Removed references deprecated gkwfit() function","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"cran-submission-readiness-1-0-1","dir":"Changelog","previous_headings":"Major Improvements","what":"CRAN Submission Readiness","title":"gkwdist 1.0.1","text":"Proper Authors@R field formatting Removed unused dependencies (numDeriv) Corrected package dependencies (RcppArmadillo LinkingTo) Enhanced description DOI references Fixed maintainer email formatting","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"bug-fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"gkwdist 1.0.1","text":"Fixed function call signatures README examples match actual implementation Corrected parameter passing optimization examples (now consistently use (par, data)) Fixed LaTeX rendering issues \\left/\\right delimiters GitHub Markdown","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"testing-1-0-1","dir":"Changelog","previous_headings":"","what":"Testing","title":"gkwdist 1.0.1","text":"100+ tests covering exported functions Tests 7 distribution families (GKw, BKw, KKw, EKw, MC, Kw, Beta) PDF, CDF, quantile, random generation tests Log-likelihood, gradient, Hessian validation Parameter recovery tests MLE Edge cases boundary condition handling Integration tests PDF-CDF consistency","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"performance-1-0-1","dir":"Changelog","previous_headings":"","what":"Performance","title":"gkwdist 1.0.1","text":"functions implemented C++ maximum computational efficiency Analytical derivatives (gradient Hessian) provide exact computations Optimized numerical stability extreme parameter values","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"notes-1-0-1","dir":"Changelog","previous_headings":"","what":"Notes","title":"gkwdist 1.0.1","text":"initial CRAN submission Package focuses exclusively distribution functions (high-level fitting interface) Companion package gkwreg provides regression modeling capabilities user-facing functions maintain backward compatibility C++ implementation uses RcppArmadillo linear algebra operations Analytical functions use robust log-scale computations prevent overflow/underflow Random generation uses inverse CDF method closed-form solutions exist","code":""},{"path":[]},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"new-features-0-1-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"gkwdist 0.1.0","text":"Initial CRAN release Generalized Kumaraswamy distribution (5 parameters) Six nested sub-families: Beta, Kumaraswamy, Exponentiated-Kumaraswamy, Kumaraswamy-Kumaraswamy, Beta-Kumaraswamy, McDonald distributions Complete set distribution functions (d/p/q/r) Log-likelihood, gradient, Hessian functions families","code":""},{"path":"https://evandeilton.github.io/gkwdist/news/index.html","id":"performance-0-1-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"gkwdist 0.1.0","text":"Optimized C++ implementation via Rcpp Vectorized operations speed","code":""}]
